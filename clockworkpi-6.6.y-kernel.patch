diff -crB linux/arch/arm/boot/dts/nxp/imx/imxrt1050.dtsi ClockworkPi-linux/arch/arm/boot/dts/nxp/imx/imxrt1050.dtsi
*** linux/arch/arm/boot/dts/nxp/imx/imxrt1050.dtsi	2025-01-18 12:31:55.509959665 -0500
--- ClockworkPi-linux/arch/arm/boot/dts/nxp/imx/imxrt1050.dtsi	2025-01-18 12:30:13.035236670 -0500
***************
*** 87,93 ****
  			reg = <0x402c0000 0x4000>;
  			interrupts = <110>;
  			clocks = <&clks IMXRT1050_CLK_IPG_PDOF>,
! 				<&clks IMXRT1050_CLK_AHB_PODF>,
  				<&clks IMXRT1050_CLK_USDHC1>;
  			clock-names = "ipg", "ahb", "per";
  			bus-width = <4>;
--- 87,93 ----
  			reg = <0x402c0000 0x4000>;
  			interrupts = <110>;
  			clocks = <&clks IMXRT1050_CLK_IPG_PDOF>,
! 				<&clks IMXRT1050_CLK_OSC>,
  				<&clks IMXRT1050_CLK_USDHC1>;
  			clock-names = "ipg", "ahb", "per";
  			bus-width = <4>;
Only in ClockworkPi-linux/arch/arm/boot/dts/overlays: clockworkpi-devterm-overlay.dts
Only in ClockworkPi-linux/arch/arm/boot/dts/overlays: clockworkpi-misc-cm5-overlay.dts
Only in ClockworkPi-linux/arch/arm/boot/dts/overlays: clockworkpi-pmu-cm5-overlay.dts
Only in ClockworkPi-linux/arch/arm/boot/dts/overlays: clockworkpi-uconsole-cm5-overlay.dts
Only in ClockworkPi-linux/arch/arm/boot/dts/overlays: clockworkpi-uconsole-overlay.dts
diff -crB linux/arch/arm/boot/dts/overlays/Makefile ClockworkPi-linux/arch/arm/boot/dts/overlays/Makefile
*** linux/arch/arm/boot/dts/overlays/Makefile	2025-01-18 12:31:55.521959525 -0500
--- ClockworkPi-linux/arch/arm/boot/dts/overlays/Makefile	2025-01-18 12:30:13.047236511 -0500
***************
*** 40,45 ****
--- 40,50 ----
  	cap1106.dtbo \
  	chipdip-dac.dtbo \
  	cirrus-wm5102.dtbo \
+ 	clockworkpi-devterm.dtbo \
+ 	clockworkpi-misc-cm5.dtbo \
+ 	clockworkpi-pmu-cm5.dtbo \
+ 	clockworkpi-uconsole-cm5.dtbo \
+ 	clockworkpi-uconsole.dtbo \
  	cm-swap-i2c0.dtbo \
  	cma.dtbo \
  	crystalfontz-cfa050_pi_m.dtbo \
Only in ClockworkPi-linux/arch/arm64/boot/dts/overlays: clockworkpi-devterm-overlay.dts
Only in ClockworkPi-linux/arch/arm64/boot/dts/overlays: clockworkpi-misc-cm5-overlay.dts
Only in ClockworkPi-linux/arch/arm64/boot/dts/overlays: clockworkpi-pmu-cm5-overlay.dts
Only in ClockworkPi-linux/arch/arm64/boot/dts/overlays: clockworkpi-uconsole-cm5-overlay.dts
Only in ClockworkPi-linux/arch/arm64/boot/dts/overlays: clockworkpi-uconsole-overlay.dts
diff -crB linux/arch/arm64/boot/dts/overlays/Makefile ClockworkPi-linux/arch/arm64/boot/dts/overlays/Makefile
*** linux/arch/arm64/boot/dts/overlays/Makefile	2025-01-18 12:31:55.521959525 -0500
--- ClockworkPi-linux/arch/arm64/boot/dts/overlays/Makefile	2025-01-18 12:30:13.047236511 -0500
***************
*** 40,45 ****
--- 40,50 ----
  	cap1106.dtbo \
  	chipdip-dac.dtbo \
  	cirrus-wm5102.dtbo \
+ 	clockworkpi-devterm.dtbo \
+ 	clockworkpi-misc-cm5.dtbo \
+ 	clockworkpi-pmu-cm5.dtbo \
+ 	clockworkpi-uconsole-cm5.dtbo \
+ 	clockworkpi-uconsole.dtbo \
  	cm-swap-i2c0.dtbo \
  	cma.dtbo \
  	crystalfontz-cfa050_pi_m.dtbo \
diff -crB linux/arch/arm64/boot/dts/rockchip/rk3328.dtsi ClockworkPi-linux/arch/arm64/boot/dts/rockchip/rk3328.dtsi
*** linux/arch/arm64/boot/dts/rockchip/rk3328.dtsi	2025-01-18 12:31:56.009953840 -0500
--- ClockworkPi-linux/arch/arm64/boot/dts/rockchip/rk3328.dtsi	2025-01-18 12:30:13.551229797 -0500
***************
*** 304,310 ****
  
  			power-domain@RK3328_PD_HEVC {
  				reg = <RK3328_PD_HEVC>;
- 				clocks = <&cru SCLK_VENC_CORE>;
  				#power-domain-cells = <0>;
  			};
  			power-domain@RK3328_PD_VIDEO {
--- 304,309 ----
diff -crB linux/arch/arm64/configs/bcm2711_defconfig ClockworkPi-linux/arch/arm64/configs/bcm2711_defconfig
*** linux/arch/arm64/configs/bcm2711_defconfig	2025-01-18 12:31:56.045953422 -0500
--- ClockworkPi-linux/arch/arm64/configs/bcm2711_defconfig	2025-01-18 12:30:13.587229317 -0500
***************
*** 1707,1711 ****
--- 1707,1726 ----
  CONFIG_STACK_TRACER=y
  CONFIG_SCHED_TRACER=y
  CONFIG_BLK_DEV_IO_TRACE=y
+ CONFIG_REGMAP_I2C=y
+ CONFIG_INPUT_AXP20X_PEK=y
+ CONFIG_CHARGER_AXP20X=m
+ CONFIG_BATTERY_AXP20X=m
+ CONFIG_AXP20X_POWER=m
+ CONFIG_MFD_AXP20X=y
+ CONFIG_MFD_AXP20X_I2C=y
+ CONFIG_REGULATOR_AXP20X=y
+ CONFIG_DRM_PANEL_CWD686=m
+ CONFIG_DRM_PANEL_CWU50=m
+ CONFIG_BACKLIGHT_OCP8178=m
+ CONFIG_AXP20X_ADC=m
+ CONFIG_TI_ADC081C=m
+ CONFIG_CRYPTO_LIB_ARC4=y
+ CONFIG_CRC_CCITT=y
  # CONFIG_UPROBE_EVENTS is not set
  # CONFIG_STRICT_DEVMEM is not set
diff -crB linux/arch/arm64/configs/bcm2712_defconfig ClockworkPi-linux/arch/arm64/configs/bcm2712_defconfig
*** linux/arch/arm64/configs/bcm2712_defconfig	2025-01-18 12:31:56.045953422 -0500
--- ClockworkPi-linux/arch/arm64/configs/bcm2712_defconfig	2025-01-18 12:30:13.587229317 -0500
***************
*** 1709,1713 ****
--- 1709,1728 ----
  CONFIG_STACK_TRACER=y
  CONFIG_SCHED_TRACER=y
  CONFIG_BLK_DEV_IO_TRACE=y
+ CONFIG_REGMAP_I2C=y
+ CONFIG_INPUT_AXP20X_PEK=y
+ CONFIG_CHARGER_AXP20X=m
+ CONFIG_BATTERY_AXP20X=m
+ CONFIG_AXP20X_POWER=m
+ CONFIG_MFD_AXP20X=y
+ CONFIG_MFD_AXP20X_I2C=y
+ CONFIG_REGULATOR_AXP20X=y
+ CONFIG_DRM_PANEL_CWD686=m
+ CONFIG_DRM_PANEL_CWU50=m
+ CONFIG_BACKLIGHT_OCP8178=m
+ CONFIG_AXP20X_ADC=m
+ CONFIG_TI_ADC081C=m
+ CONFIG_CRYPTO_LIB_ARC4=y
+ CONFIG_CRC_CCITT=y
  # CONFIG_UPROBE_EVENTS is not set
  # CONFIG_STRICT_DEVMEM is not set
diff -crB linux/arch/riscv/include/asm/cacheflush.h ClockworkPi-linux/arch/riscv/include/asm/cacheflush.h
*** linux/arch/riscv/include/asm/cacheflush.h	2025-01-18 12:31:56.745945277 -0500
--- ClockworkPi-linux/arch/riscv/include/asm/cacheflush.h	2025-01-18 12:30:14.527216805 -0500
***************
*** 13,24 ****
  	asm volatile ("fence.i" ::: "memory");
  }
  
- static inline void local_flush_icache_range(unsigned long start,
- 					    unsigned long end)
- {
- 	local_flush_icache_all();
- }
- 
  #define PG_dcache_clean PG_arch_1
  
  static inline void flush_dcache_folio(struct folio *folio)
--- 13,18 ----
diff -crB linux/arch/riscv/include/asm/page.h ClockworkPi-linux/arch/riscv/include/asm/page.h
*** linux/arch/riscv/include/asm/page.h	2025-01-18 12:31:56.749945230 -0500
--- ClockworkPi-linux/arch/riscv/include/asm/page.h	2025-01-18 12:30:14.531216752 -0500
***************
*** 122,128 ****
  
  extern struct kernel_mapping kernel_map;
  extern phys_addr_t phys_ram_base;
- extern unsigned long vmemmap_start_pfn;
  
  #define is_kernel_mapping(x)	\
  	((x) >= kernel_map.virt_addr && (x) < (kernel_map.virt_addr + kernel_map.size))
--- 122,127 ----
diff -crB linux/arch/riscv/include/asm/patch.h ClockworkPi-linux/arch/riscv/include/asm/patch.h
*** linux/arch/riscv/include/asm/patch.h	2025-01-18 12:31:56.749945230 -0500
--- ClockworkPi-linux/arch/riscv/include/asm/patch.h	2025-01-18 12:30:14.531216752 -0500
***************
*** 6,12 ****
  #ifndef _ASM_RISCV_PATCH_H
  #define _ASM_RISCV_PATCH_H
  
- int patch_insn_write(void *addr, const void *insn, size_t len);
  int patch_text_nosync(void *addr, const void *insns, size_t len);
  int patch_text_set_nosync(void *addr, u8 c, size_t len);
  int patch_text(void *addr, u32 *insns, int ninsns);
--- 6,11 ----
diff -crB linux/arch/riscv/include/asm/pgtable.h ClockworkPi-linux/arch/riscv/include/asm/pgtable.h
*** linux/arch/riscv/include/asm/pgtable.h	2025-01-18 12:31:56.753945184 -0500
--- ClockworkPi-linux/arch/riscv/include/asm/pgtable.h	2025-01-18 12:30:14.535216699 -0500
***************
*** 84,90 ****
   * Define vmemmap for pfn_to_page & page_to_pfn calls. Needed if kernel
   * is configured with CONFIG_SPARSEMEM_VMEMMAP enabled.
   */
! #define vmemmap		((struct page *)VMEMMAP_START - vmemmap_start_pfn)
  
  #define PCI_IO_SIZE      SZ_16M
  #define PCI_IO_END       VMEMMAP_START
--- 84,90 ----
   * Define vmemmap for pfn_to_page & page_to_pfn calls. Needed if kernel
   * is configured with CONFIG_SPARSEMEM_VMEMMAP enabled.
   */
! #define vmemmap		((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT))
  
  #define PCI_IO_SIZE      SZ_16M
  #define PCI_IO_END       VMEMMAP_START
diff -crB linux/arch/riscv/kernel/ftrace.c ClockworkPi-linux/arch/riscv/kernel/ftrace.c
*** linux/arch/riscv/kernel/ftrace.c	2025-01-18 12:31:56.757945137 -0500
--- ClockworkPi-linux/arch/riscv/kernel/ftrace.c	2025-01-18 12:30:14.539216646 -0500
***************
*** 8,14 ****
  #include <linux/ftrace.h>
  #include <linux/uaccess.h>
  #include <linux/memory.h>
- #include <linux/stop_machine.h>
  #include <asm/cacheflush.h>
  #include <asm/patch.h>
  
--- 8,13 ----
***************
*** 76,82 ****
  		make_call_t0(hook_pos, target, call);
  
  	/* Replace the auipc-jalr pair at once. Return -EPERM on write error. */
! 	if (patch_insn_write((void *)hook_pos, enable ? call : nops, MCOUNT_INSN_SIZE))
  		return -EPERM;
  
  	return 0;
--- 75,82 ----
  		make_call_t0(hook_pos, target, call);
  
  	/* Replace the auipc-jalr pair at once. Return -EPERM on write error. */
! 	if (patch_text_nosync
! 	    ((void *)hook_pos, enable ? call : nops, MCOUNT_INSN_SIZE))
  		return -EPERM;
  
  	return 0;
***************
*** 88,94 ****
  
  	make_call_t0(rec->ip, addr, call);
  
! 	if (patch_insn_write((void *)rec->ip, call, MCOUNT_INSN_SIZE))
  		return -EPERM;
  
  	return 0;
--- 88,94 ----
  
  	make_call_t0(rec->ip, addr, call);
  
! 	if (patch_text_nosync((void *)rec->ip, call, MCOUNT_INSN_SIZE))
  		return -EPERM;
  
  	return 0;
***************
*** 99,105 ****
  {
  	unsigned int nops[2] = {NOP4, NOP4};
  
! 	if (patch_insn_write((void *)rec->ip, nops, MCOUNT_INSN_SIZE))
  		return -EPERM;
  
  	return 0;
--- 99,105 ----
  {
  	unsigned int nops[2] = {NOP4, NOP4};
  
! 	if (patch_text_nosync((void *)rec->ip, nops, MCOUNT_INSN_SIZE))
  		return -EPERM;
  
  	return 0;
***************
*** 120,128 ****
  	out = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
  	mutex_unlock(&text_mutex);
  
- 	if (!mod)
- 		local_flush_icache_range(rec->ip, rec->ip + MCOUNT_INSN_SIZE);
- 
  	return out;
  }
  
--- 120,125 ----
***************
*** 137,178 ****
  
  	return ret;
  }
- 
- struct ftrace_modify_param {
- 	int command;
- 	atomic_t cpu_count;
- };
- 
- static int __ftrace_modify_code(void *data)
- {
- 	struct ftrace_modify_param *param = data;
- 
- 	if (atomic_inc_return(&param->cpu_count) == num_online_cpus()) {
- 		ftrace_modify_all_code(param->command);
- 		/*
- 		 * Make sure the patching store is effective *before* we
- 		 * increment the counter which releases all waiting CPUs
- 		 * by using the release variant of atomic increment. The
- 		 * release pairs with the call to local_flush_icache_all()
- 		 * on the waiting CPU.
- 		 */
- 		atomic_inc_return_release(&param->cpu_count);
- 	} else {
- 		while (atomic_read(&param->cpu_count) <= num_online_cpus())
- 			cpu_relax();
- 	}
- 
- 	local_flush_icache_all();
- 
- 	return 0;
- }
- 
- void arch_ftrace_update_code(int command)
- {
- 	struct ftrace_modify_param param = { command, ATOMIC_INIT(0) };
- 
- 	stop_machine(__ftrace_modify_code, &param, cpu_online_mask);
- }
  #endif
  
  #ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS
--- 134,139 ----
diff -crB linux/arch/riscv/kernel/patch.c ClockworkPi-linux/arch/riscv/kernel/patch.c
*** linux/arch/riscv/kernel/patch.c	2025-01-18 12:31:56.761945091 -0500
--- ClockworkPi-linux/arch/riscv/kernel/patch.c	2025-01-18 12:30:14.543216592 -0500
***************
*** 196,202 ****
  }
  NOKPROBE_SYMBOL(patch_text_set_nosync);
  
! int patch_insn_write(void *addr, const void *insn, size_t len)
  {
  	size_t patched = 0;
  	size_t size;
--- 196,202 ----
  }
  NOKPROBE_SYMBOL(patch_text_set_nosync);
  
! static int patch_insn_write(void *addr, const void *insn, size_t len)
  {
  	size_t patched = 0;
  	size_t size;
***************
*** 240,263 ****
  	if (atomic_inc_return(&patch->cpu_count) == num_online_cpus()) {
  		for (i = 0; ret == 0 && i < patch->ninsns; i++) {
  			len = GET_INSN_LENGTH(patch->insns[i]);
! 			ret = patch_insn_write(patch->addr + i * len, &patch->insns[i], len);
  		}
! 		/*
! 		 * Make sure the patching store is effective *before* we
! 		 * increment the counter which releases all waiting CPUs
! 		 * by using the release variant of atomic increment. The
! 		 * release pairs with the call to local_flush_icache_all()
! 		 * on the waiting CPU.
! 		 */
! 		atomic_inc_return_release(&patch->cpu_count);
  	} else {
  		while (atomic_read(&patch->cpu_count) <= num_online_cpus())
  			cpu_relax();
  		smp_mb();
  	}
  
- 	local_flush_icache_all();
- 
  	return ret;
  }
  NOKPROBE_SYMBOL(patch_text_cb);
--- 240,255 ----
  	if (atomic_inc_return(&patch->cpu_count) == num_online_cpus()) {
  		for (i = 0; ret == 0 && i < patch->ninsns; i++) {
  			len = GET_INSN_LENGTH(patch->insns[i]);
! 			ret = patch_text_nosync(patch->addr + i * len,
! 						&patch->insns[i], len);
  		}
! 		atomic_inc(&patch->cpu_count);
  	} else {
  		while (atomic_read(&patch->cpu_count) <= num_online_cpus())
  			cpu_relax();
  		smp_mb();
  	}
  
  	return ret;
  }
  NOKPROBE_SYMBOL(patch_text_cb);
diff -crB linux/arch/riscv/kernel/probes/kprobes.c ClockworkPi-linux/arch/riscv/kernel/probes/kprobes.c
*** linux/arch/riscv/kernel/probes/kprobes.c	2025-01-18 12:31:56.761945091 -0500
--- ClockworkPi-linux/arch/riscv/kernel/probes/kprobes.c	2025-01-18 12:30:14.543216592 -0500
***************
*** 29,35 ****
  	p->ainsn.api.restore = (unsigned long)p->addr + offset;
  
  	patch_text_nosync(p->ainsn.api.insn, &p->opcode, 1);
! 	patch_text_nosync((void *)p->ainsn.api.insn + offset, &insn, 1);
  }
  
  static void __kprobes arch_prepare_simulate(struct kprobe *p)
--- 29,35 ----
  	p->ainsn.api.restore = (unsigned long)p->addr + offset;
  
  	patch_text_nosync(p->ainsn.api.insn, &p->opcode, 1);
! 	patch_text_nosync(p->ainsn.api.insn + offset, &insn, 1);
  }
  
  static void __kprobes arch_prepare_simulate(struct kprobe *p)
diff -crB linux/arch/riscv/kernel/traps.c ClockworkPi-linux/arch/riscv/kernel/traps.c
*** linux/arch/riscv/kernel/traps.c	2025-01-18 12:31:56.765945044 -0500
--- ClockworkPi-linux/arch/riscv/kernel/traps.c	2025-01-18 12:30:14.547216539 -0500
***************
*** 34,40 ****
  
  int show_unhandled_signals = 1;
  
! static DEFINE_RAW_SPINLOCK(die_lock);
  
  static void dump_kernel_instr(const char *loglvl, struct pt_regs *regs)
  {
--- 34,40 ----
  
  int show_unhandled_signals = 1;
  
! static DEFINE_SPINLOCK(die_lock);
  
  static void dump_kernel_instr(const char *loglvl, struct pt_regs *regs)
  {
***************
*** 66,72 ****
  
  	oops_enter();
  
! 	raw_spin_lock_irqsave(&die_lock, flags);
  	console_verbose();
  	bust_spinlocks(1);
  
--- 66,72 ----
  
  	oops_enter();
  
! 	spin_lock_irqsave(&die_lock, flags);
  	console_verbose();
  	bust_spinlocks(1);
  
***************
*** 85,91 ****
  
  	bust_spinlocks(0);
  	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);
! 	raw_spin_unlock_irqrestore(&die_lock, flags);
  	oops_exit();
  
  	if (in_interrupt())
--- 85,91 ----
  
  	bust_spinlocks(0);
  	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);
! 	spin_unlock_irqrestore(&die_lock, flags);
  	oops_exit();
  
  	if (in_interrupt())
diff -crB linux/arch/riscv/mm/init.c ClockworkPi-linux/arch/riscv/mm/init.c
*** linux/arch/riscv/mm/init.c	2025-01-18 12:31:56.769944998 -0500
--- ClockworkPi-linux/arch/riscv/mm/init.c	2025-01-18 12:30:14.551216486 -0500
***************
*** 32,38 ****
  #include <asm/ptdump.h>
  #include <asm/sections.h>
  #include <asm/soc.h>
- #include <asm/sparsemem.h>
  #include <asm/tlbflush.h>
  
  #include "../kernel/head.h"
--- 32,37 ----
***************
*** 58,70 ****
  phys_addr_t phys_ram_base __ro_after_init;
  EXPORT_SYMBOL(phys_ram_base);
  
- #ifdef CONFIG_SPARSEMEM_VMEMMAP
- #define VMEMMAP_ADDR_ALIGN	(1ULL << SECTION_SIZE_BITS)
- 
- unsigned long vmemmap_start_pfn __ro_after_init;
- EXPORT_SYMBOL(vmemmap_start_pfn);
- #endif
- 
  unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)]
  							__page_aligned_bss;
  EXPORT_SYMBOL(empty_zero_page);
--- 57,62 ----
***************
*** 229,240 ****
  	 * Make sure we align the start of the memory on a PMD boundary so that
  	 * at worst, we map the linear mapping with PMD mappings.
  	 */
! 	if (!IS_ENABLED(CONFIG_XIP_KERNEL)) {
  		phys_ram_base = memblock_start_of_DRAM() & PMD_MASK;
- #ifdef CONFIG_SPARSEMEM_VMEMMAP
- 		vmemmap_start_pfn = round_down(phys_ram_base, VMEMMAP_ADDR_ALIGN) >> PAGE_SHIFT;
- #endif
- 	}
  
  	/*
  	 * In 64-bit, any use of __va/__pa before this point is wrong as we
--- 221,228 ----
  	 * Make sure we align the start of the memory on a PMD boundary so that
  	 * at worst, we map the linear mapping with PMD mappings.
  	 */
! 	if (!IS_ENABLED(CONFIG_XIP_KERNEL))
  		phys_ram_base = memblock_start_of_DRAM() & PMD_MASK;
  
  	/*
  	 * In 64-bit, any use of __va/__pa before this point is wrong as we
***************
*** 1092,1100 ****
  	kernel_map.xiprom_sz = (uintptr_t)(&_exiprom) - (uintptr_t)(&_xiprom);
  
  	phys_ram_base = CONFIG_PHYS_RAM_BASE;
- #ifdef CONFIG_SPARSEMEM_VMEMMAP
- 	vmemmap_start_pfn = round_down(phys_ram_base, VMEMMAP_ADDR_ALIGN) >> PAGE_SHIFT;
- #endif
  	kernel_map.phys_addr = (uintptr_t)CONFIG_PHYS_RAM_BASE;
  	kernel_map.size = (uintptr_t)(&_end) - (uintptr_t)(&_start);
  
--- 1080,1085 ----
diff -crB linux/arch/x86/kernel/cpu/mshyperv.c ClockworkPi-linux/arch/x86/kernel/cpu/mshyperv.c
*** linux/arch/x86/kernel/cpu/mshyperv.c	2025-01-18 12:31:57.085941322 -0500
--- ClockworkPi-linux/arch/x86/kernel/cpu/mshyperv.c	2025-01-18 12:30:14.883212069 -0500
***************
*** 209,215 ****
--- 209,217 ----
  	if (kexec_in_progress)
  		hyperv_cleanup();
  }
+ #endif /* CONFIG_KEXEC_CORE */
  
+ #ifdef CONFIG_CRASH_DUMP
  static void hv_machine_crash_shutdown(struct pt_regs *regs)
  {
  	if (hv_crash_handler)
***************
*** 221,227 ****
  	/* Disable the hypercall page when there is only 1 active CPU. */
  	hyperv_cleanup();
  }
! #endif /* CONFIG_KEXEC_CORE */
  
  static u64 hv_ref_counter_at_suspend;
  static void (*old_save_sched_clock_state)(void);
--- 223,229 ----
  	/* Disable the hypercall page when there is only 1 active CPU. */
  	hyperv_cleanup();
  }
! #endif /* CONFIG_CRASH_DUMP */
  
  static u64 hv_ref_counter_at_suspend;
  static void (*old_save_sched_clock_state)(void);
***************
*** 550,559 ****
  	no_timer_check = 1;
  #endif
  
! #if IS_ENABLED(CONFIG_HYPERV) && defined(CONFIG_KEXEC_CORE)
  	machine_ops.shutdown = hv_machine_shutdown;
  	machine_ops.crash_shutdown = hv_machine_crash_shutdown;
  #endif
  	if (ms_hyperv.features & HV_ACCESS_TSC_INVARIANT) {
  		/*
  		 * Writing to synthetic MSR 0x40000118 updates/changes the
--- 552,565 ----
  	no_timer_check = 1;
  #endif
  
! #if IS_ENABLED(CONFIG_HYPERV)
! #if defined(CONFIG_KEXEC_CORE)
  	machine_ops.shutdown = hv_machine_shutdown;
+ #endif
+ #if defined(CONFIG_CRASH_DUMP)
  	machine_ops.crash_shutdown = hv_machine_crash_shutdown;
  #endif
+ #endif
  	if (ms_hyperv.features & HV_ACCESS_TSC_INVARIANT) {
  		/*
  		 * Writing to synthetic MSR 0x40000118 updates/changes the
diff -crB linux/arch/x86/kernel/fpu/regset.c ClockworkPi-linux/arch/x86/kernel/fpu/regset.c
*** linux/arch/x86/kernel/fpu/regset.c	2025-01-18 12:31:57.097941183 -0500
--- ClockworkPi-linux/arch/x86/kernel/fpu/regset.c	2025-01-18 12:30:14.895211910 -0500
***************
*** 190,197 ****
  	struct fpu *fpu = &target->thread.fpu;
  	struct cet_user_state *cetregs;
  
! 	if (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK) ||
! 	    !ssp_active(target, regset))
  		return -ENODEV;
  
  	sync_fpstate(fpu);
--- 190,196 ----
  	struct fpu *fpu = &target->thread.fpu;
  	struct cet_user_state *cetregs;
  
! 	if (!cpu_feature_enabled(X86_FEATURE_USER_SHSTK))
  		return -ENODEV;
  
  	sync_fpstate(fpu);
diff -crB linux/arch/x86/kernel/kexec-bzimage64.c ClockworkPi-linux/arch/x86/kernel/kexec-bzimage64.c
*** linux/arch/x86/kernel/kexec-bzimage64.c	2025-01-18 12:31:57.101941136 -0500
--- ClockworkPi-linux/arch/x86/kernel/kexec-bzimage64.c	2025-01-18 12:30:14.899211856 -0500
***************
*** 263,273 ****
--- 263,275 ----
  	memset(&params->hd0_info, 0, sizeof(params->hd0_info));
  	memset(&params->hd1_info, 0, sizeof(params->hd1_info));
  
+ #ifdef CONFIG_CRASH_DUMP
  	if (image->type == KEXEC_TYPE_CRASH) {
  		ret = crash_setup_memmap_entries(image, params);
  		if (ret)
  			return ret;
  	} else
+ #endif
  		setup_e820_entries(params);
  
  	nr_e820_entries = params->e820_entries;
***************
*** 428,439 ****
--- 430,443 ----
  		return ERR_PTR(-EINVAL);
  	}
  
+ #ifdef CONFIG_CRASH_DUMP
  	/* Allocate and load backup region */
  	if (image->type == KEXEC_TYPE_CRASH) {
  		ret = crash_load_segments(image);
  		if (ret)
  			return ERR_PTR(ret);
  	}
+ #endif
  
  	/*
  	 * Load purgatory. For 64bit entry point, purgatory  code can be
diff -crB linux/arch/x86/kernel/kvm.c ClockworkPi-linux/arch/x86/kernel/kvm.c
*** linux/arch/x86/kernel/kvm.c	2025-01-18 12:31:57.101941136 -0500
--- ClockworkPi-linux/arch/x86/kernel/kvm.c	2025-01-18 12:30:14.903211803 -0500
***************
*** 769,775 ****
   * won't be valid. In cases like kexec, in which you install a new kernel, this
   * means a random memory location will be kept being written.
   */
! #ifdef CONFIG_KEXEC_CORE
  static void kvm_crash_shutdown(struct pt_regs *regs)
  {
  	kvm_guest_cpu_offline(true);
--- 769,775 ----
   * won't be valid. In cases like kexec, in which you install a new kernel, this
   * means a random memory location will be kept being written.
   */
! #ifdef CONFIG_CRASH_DUMP
  static void kvm_crash_shutdown(struct pt_regs *regs)
  {
  	kvm_guest_cpu_offline(true);
***************
*** 852,858 ****
  	kvm_guest_cpu_init();
  #endif
  
! #ifdef CONFIG_KEXEC_CORE
  	machine_ops.crash_shutdown = kvm_crash_shutdown;
  #endif
  
--- 852,858 ----
  	kvm_guest_cpu_init();
  #endif
  
! #ifdef CONFIG_CRASH_DUMP
  	machine_ops.crash_shutdown = kvm_crash_shutdown;
  #endif
  
diff -crB linux/arch/x86/kernel/machine_kexec_64.c ClockworkPi-linux/arch/x86/kernel/machine_kexec_64.c
*** linux/arch/x86/kernel/machine_kexec_64.c	2025-01-18 12:31:57.101941136 -0500
--- ClockworkPi-linux/arch/x86/kernel/machine_kexec_64.c	2025-01-18 12:30:14.903211803 -0500
***************
*** 545,550 ****
--- 545,552 ----
  }
  #endif /* CONFIG_KEXEC_FILE */
  
+ #ifdef CONFIG_CRASH_DUMP
+ 
  static int
  kexec_mark_range(unsigned long start, unsigned long end, bool protect)
  {
***************
*** 589,594 ****
--- 591,597 ----
  {
  	kexec_mark_crashkres(false);
  }
+ #endif
  
  /*
   * During a traditional boot under SME, SME will encrypt the kernel,
diff -crB linux/arch/x86/kernel/Makefile ClockworkPi-linux/arch/x86/kernel/Makefile
*** linux/arch/x86/kernel/Makefile	2025-01-18 12:31:57.069941508 -0500
--- ClockworkPi-linux/arch/x86/kernel/Makefile	2025-01-18 12:30:14.867212282 -0500
***************
*** 99,107 ****
  obj-$(CONFIG_RETHOOK)		+= rethook.o
  obj-$(CONFIG_CRASH_CORE)	+= crash_core_$(BITS).o
  obj-$(CONFIG_KEXEC_CORE)	+= machine_kexec_$(BITS).o
! obj-$(CONFIG_KEXEC_CORE)	+= relocate_kernel_$(BITS).o crash.o
  obj-$(CONFIG_KEXEC_FILE)	+= kexec-bzimage64.o
! obj-$(CONFIG_CRASH_DUMP)	+= crash_dump_$(BITS).o
  obj-y				+= kprobes/
  obj-$(CONFIG_MODULES)		+= module.o
  obj-$(CONFIG_X86_32)		+= doublefault_32.o
--- 99,107 ----
  obj-$(CONFIG_RETHOOK)		+= rethook.o
  obj-$(CONFIG_CRASH_CORE)	+= crash_core_$(BITS).o
  obj-$(CONFIG_KEXEC_CORE)	+= machine_kexec_$(BITS).o
! obj-$(CONFIG_KEXEC_CORE)	+= relocate_kernel_$(BITS).o
  obj-$(CONFIG_KEXEC_FILE)	+= kexec-bzimage64.o
! obj-$(CONFIG_CRASH_DUMP)	+= crash_dump_$(BITS).o crash.o
  obj-y				+= kprobes/
  obj-$(CONFIG_MODULES)		+= module.o
  obj-$(CONFIG_X86_32)		+= doublefault_32.o
diff -crB linux/arch/x86/kernel/reboot.c ClockworkPi-linux/arch/x86/kernel/reboot.c
*** linux/arch/x86/kernel/reboot.c	2025-01-18 12:31:57.105941090 -0500
--- ClockworkPi-linux/arch/x86/kernel/reboot.c	2025-01-18 12:30:14.907211750 -0500
***************
*** 796,802 ****
  	.emergency_restart = native_machine_emergency_restart,
  	.restart = native_machine_restart,
  	.halt = native_machine_halt,
! #ifdef CONFIG_KEXEC_CORE
  	.crash_shutdown = native_machine_crash_shutdown,
  #endif
  };
--- 796,802 ----
  	.emergency_restart = native_machine_emergency_restart,
  	.restart = native_machine_restart,
  	.halt = native_machine_halt,
! #ifdef CONFIG_CRASH_DUMP
  	.crash_shutdown = native_machine_crash_shutdown,
  #endif
  };
***************
*** 826,832 ****
  	machine_ops.halt();
  }
  
! #ifdef CONFIG_KEXEC_CORE
  void machine_crash_shutdown(struct pt_regs *regs)
  {
  	machine_ops.crash_shutdown(regs);
--- 826,832 ----
  	machine_ops.halt();
  }
  
! #ifdef CONFIG_CRASH_DUMP
  void machine_crash_shutdown(struct pt_regs *regs)
  {
  	machine_ops.crash_shutdown(regs);
diff -crB linux/arch/x86/kernel/setup.c ClockworkPi-linux/arch/x86/kernel/setup.c
*** linux/arch/x86/kernel/setup.c	2025-01-18 12:31:57.109941043 -0500
--- ClockworkPi-linux/arch/x86/kernel/setup.c	2025-01-18 12:30:14.907211750 -0500
***************
*** 547,553 ****
  	bool high = false;
  	int ret;
  
! 	if (!IS_ENABLED(CONFIG_KEXEC_CORE))
  		return;
  
  	total_mem = memblock_phys_mem_size();
--- 547,553 ----
  	bool high = false;
  	int ret;
  
! 	if (!IS_ENABLED(CONFIG_CRASH_RESERVE))
  		return;
  
  	total_mem = memblock_phys_mem_size();
diff -crB linux/arch/x86/kernel/smp.c ClockworkPi-linux/arch/x86/kernel/smp.c
*** linux/arch/x86/kernel/smp.c	2025-01-18 12:31:57.109941043 -0500
--- ClockworkPi-linux/arch/x86/kernel/smp.c	2025-01-18 12:30:14.911211697 -0500
***************
*** 282,288 ****
  	.smp_cpus_done		= native_smp_cpus_done,
  
  	.stop_other_cpus	= native_stop_other_cpus,
! #if defined(CONFIG_KEXEC_CORE)
  	.crash_stop_other_cpus	= kdump_nmi_shootdown_cpus,
  #endif
  	.smp_send_reschedule	= native_smp_send_reschedule,
--- 282,288 ----
  	.smp_cpus_done		= native_smp_cpus_done,
  
  	.stop_other_cpus	= native_stop_other_cpus,
! #if defined(CONFIG_CRASH_DUMP)
  	.crash_stop_other_cpus	= kdump_nmi_shootdown_cpus,
  #endif
  	.smp_send_reschedule	= native_smp_send_reschedule,
diff -crB linux/arch/x86/mm/numa.c ClockworkPi-linux/arch/x86/mm/numa.c
*** linux/arch/x86/mm/numa.c	2025-01-18 12:31:57.157940486 -0500
--- ClockworkPi-linux/arch/x86/mm/numa.c	2025-01-18 12:30:14.959211058 -0500
***************
*** 492,498 ****
  	for_each_reserved_mem_region(mb_region) {
  		int nid = memblock_get_region_node(mb_region);
  
! 		if (nid != NUMA_NO_NODE)
  			node_set(nid, reserved_nodemask);
  	}
  
--- 492,498 ----
  	for_each_reserved_mem_region(mb_region) {
  		int nid = memblock_get_region_node(mb_region);
  
! 		if (nid != MAX_NUMNODES)
  			node_set(nid, reserved_nodemask);
  	}
  
***************
*** 613,621 ****
  	nodes_clear(node_online_map);
  	memset(&numa_meminfo, 0, sizeof(numa_meminfo));
  	WARN_ON(memblock_set_node(0, ULLONG_MAX, &memblock.memory,
! 				  NUMA_NO_NODE));
  	WARN_ON(memblock_set_node(0, ULLONG_MAX, &memblock.reserved,
! 				  NUMA_NO_NODE));
  	/* In case that parsing SRAT failed. */
  	WARN_ON(memblock_clear_hotplug(0, ULLONG_MAX));
  	numa_reset_distance();
--- 613,621 ----
  	nodes_clear(node_online_map);
  	memset(&numa_meminfo, 0, sizeof(numa_meminfo));
  	WARN_ON(memblock_set_node(0, ULLONG_MAX, &memblock.memory,
! 				  MAX_NUMNODES));
  	WARN_ON(memblock_set_node(0, ULLONG_MAX, &memblock.reserved,
! 				  MAX_NUMNODES));
  	/* In case that parsing SRAT failed. */
  	WARN_ON(memblock_clear_hotplug(0, ULLONG_MAX));
  	numa_reset_distance();
diff -crB linux/arch/x86/xen/enlighten_hvm.c ClockworkPi-linux/arch/x86/xen/enlighten_hvm.c
*** linux/arch/x86/xen/enlighten_hvm.c	2025-01-18 12:31:57.181940207 -0500
--- ClockworkPi-linux/arch/x86/xen/enlighten_hvm.c	2025-01-18 12:30:14.983210739 -0500
***************
*** 141,147 ****
--- 141,149 ----
  	if (kexec_in_progress)
  		xen_reboot(SHUTDOWN_soft_reset);
  }
+ #endif
  
+ #ifdef CONFIG_CRASH_DUMP
  static void xen_hvm_crash_shutdown(struct pt_regs *regs)
  {
  	native_machine_crash_shutdown(regs);
***************
*** 229,234 ****
--- 231,238 ----
  
  #ifdef CONFIG_KEXEC_CORE
  	machine_ops.shutdown = xen_hvm_shutdown;
+ #endif
+ #ifdef CONFIG_CRASH_DUMP
  	machine_ops.crash_shutdown = xen_hvm_crash_shutdown;
  #endif
  }
diff -crB linux/arch/x86/xen/mmu_pv.c ClockworkPi-linux/arch/x86/xen/mmu_pv.c
*** linux/arch/x86/xen/mmu_pv.c	2025-01-18 12:31:57.185940160 -0500
--- ClockworkPi-linux/arch/x86/xen/mmu_pv.c	2025-01-18 12:30:14.987210686 -0500
***************
*** 2517,2523 ****
  }
  EXPORT_SYMBOL_GPL(xen_remap_pfn);
  
! #ifdef CONFIG_KEXEC_CORE
  phys_addr_t paddr_vmcoreinfo_note(void)
  {
  	if (xen_pv_domain())
--- 2517,2523 ----
  }
  EXPORT_SYMBOL_GPL(xen_remap_pfn);
  
! #ifdef CONFIG_VMCORE_INFO
  phys_addr_t paddr_vmcoreinfo_note(void)
  {
  	if (xen_pv_domain())
diff -crB linux/block/bfq-iosched.c ClockworkPi-linux/block/bfq-iosched.c
*** linux/block/bfq-iosched.c	2025-01-18 12:31:57.265939231 -0500
--- ClockworkPi-linux/block/bfq-iosched.c	2025-01-18 12:30:15.015210314 -0500
***************
*** 6843,6866 ****
  		if (new_bfqq == waker_bfqq) {
  			/*
  			 * If waker_bfqq is in the merge chain, and current
! 			 * is the only process, waker_bfqq can be freed.
  			 */
  			if (bfqq_process_refs(waker_bfqq) == 1)
  				return NULL;
! 
! 			return waker_bfqq;
  		}
  
  		new_bfqq = new_bfqq->new_bfqq;
  	}
  
- 	/*
- 	 * If waker_bfqq is not in the merge chain, and it's procress reference
- 	 * is 0, waker_bfqq can be freed.
- 	 */
- 	if (bfqq_process_refs(waker_bfqq) == 0)
- 		return NULL;
- 
  	return waker_bfqq;
  }
  
--- 6843,6858 ----
  		if (new_bfqq == waker_bfqq) {
  			/*
  			 * If waker_bfqq is in the merge chain, and current
! 			 * is the only procress.
  			 */
  			if (bfqq_process_refs(waker_bfqq) == 1)
  				return NULL;
! 			break;
  		}
  
  		new_bfqq = new_bfqq->new_bfqq;
  	}
  
  	return waker_bfqq;
  }
  
diff -crB linux/drivers/acpi/resource.c ClockworkPi-linux/drivers/acpi/resource.c
*** linux/drivers/acpi/resource.c	2025-01-18 12:31:57.493936581 -0500
--- ClockworkPi-linux/drivers/acpi/resource.c	2025-01-18 12:30:15.251207178 -0500
***************
*** 440,452 ****
  		},
  	},
  	{
- 		/* Asus Vivobook X1504VAP */
- 		.matches = {
- 			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
- 			DMI_MATCH(DMI_BOARD_NAME, "X1504VAP"),
- 		},
- 	},
- 	{
  		/* Asus Vivobook X1704VAP */
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
--- 440,445 ----
***************
*** 640,656 ****
  			DMI_MATCH(DMI_BOARD_NAME, "GMxHGxx"),
  		},
  	},
- 	{
- 		/*
- 		 * TongFang GM5HG0A in case of the SKIKK Vanaheim relabel the
- 		 * board-name is changed, so check OEM strings instead. Note
- 		 * OEM string matches are always exact matches.
- 		 * https://bugzilla.kernel.org/show_bug.cgi?id=219614
- 		 */
- 		.matches = {
- 			DMI_EXACT_MATCH(DMI_OEM_STRING, "GM5HG0A"),
- 		},
- 	},
  	{ }
  };
  
--- 633,638 ----
diff -crB linux/drivers/base/topology.c ClockworkPi-linux/drivers/base/topology.c
*** linux/drivers/base/topology.c	2025-01-18 12:31:57.561935791 -0500
--- ClockworkPi-linux/drivers/base/topology.c	2025-01-18 12:30:15.315206328 -0500
***************
*** 27,43 ****
  			   loff_t off, size_t count)				\
  {										\
  	struct device *dev = kobj_to_dev(kobj);                                 \
- 	cpumask_var_t mask;							\
- 	ssize_t n;								\
  										\
! 	if (!alloc_cpumask_var(&mask, GFP_KERNEL))				\
! 		return -ENOMEM;							\
! 										\
! 	cpumask_copy(mask, topology_##mask(dev->id));				\
! 	n = cpumap_print_bitmask_to_buf(buf, mask, off, count);			\
! 	free_cpumask_var(mask);							\
! 										\
! 	return n;								\
  }										\
  										\
  static ssize_t name##_list_read(struct file *file, struct kobject *kobj,	\
--- 27,35 ----
  			   loff_t off, size_t count)				\
  {										\
  	struct device *dev = kobj_to_dev(kobj);                                 \
  										\
! 	return cpumap_print_bitmask_to_buf(buf, topology_##mask(dev->id),	\
! 					   off, count);                         \
  }										\
  										\
  static ssize_t name##_list_read(struct file *file, struct kobject *kobj,	\
***************
*** 45,61 ****
  				loff_t off, size_t count)			\
  {										\
  	struct device *dev = kobj_to_dev(kobj);					\
- 	cpumask_var_t mask;							\
- 	ssize_t n;								\
- 										\
- 	if (!alloc_cpumask_var(&mask, GFP_KERNEL))				\
- 		return -ENOMEM;							\
- 										\
- 	cpumask_copy(mask, topology_##mask(dev->id));				\
- 	n = cpumap_print_list_to_buf(buf, mask, off, count);			\
- 	free_cpumask_var(mask);							\
  										\
! 	return n;								\
  }
  
  define_id_show_func(physical_package_id, "%d");
--- 37,45 ----
  				loff_t off, size_t count)			\
  {										\
  	struct device *dev = kobj_to_dev(kobj);					\
  										\
! 	return cpumap_print_list_to_buf(buf, topology_##mask(dev->id),		\
! 					off, count);				\
  }
  
  define_id_show_func(physical_package_id, "%d");
diff -crB linux/drivers/bluetooth/btnxpuart.c ClockworkPi-linux/drivers/bluetooth/btnxpuart.c
*** linux/drivers/bluetooth/btnxpuart.c	2025-01-18 12:31:57.593935419 -0500
--- ClockworkPi-linux/drivers/bluetooth/btnxpuart.c	2025-01-18 12:30:15.351205850 -0500
***************
*** 1280,1286 ****
  
  	while ((skb = nxp_dequeue(nxpdev))) {
  		len = serdev_device_write_buf(serdev, skb->data, skb->len);
- 		serdev_device_wait_until_sent(serdev, 0);
  		hdev->stat.byte_tx += len;
  
  		skb_pull(skb, len);
--- 1280,1285 ----
diff -crB linux/drivers/cpuidle/cpuidle-riscv-sbi.c ClockworkPi-linux/drivers/cpuidle/cpuidle-riscv-sbi.c
*** linux/drivers/cpuidle/cpuidle-riscv-sbi.c	2025-01-18 12:31:57.901931840 -0500
--- ClockworkPi-linux/drivers/cpuidle/cpuidle-riscv-sbi.c	2025-01-18 12:30:15.667201652 -0500
***************
*** 534,545 ****
  	int cpu, ret;
  	struct cpuidle_driver *drv;
  	struct cpuidle_device *dev;
! 	struct device_node *pds_node;
  
  	/* Detect OSI support based on CPU DT nodes */
  	sbi_cpuidle_use_osi = true;
  	for_each_possible_cpu(cpu) {
! 		struct device_node *np __free(device_node) = of_cpu_device_node_get(cpu);
  		if (np &&
  		    of_property_present(np, "power-domains") &&
  		    of_property_present(np, "power-domain-names")) {
--- 534,545 ----
  	int cpu, ret;
  	struct cpuidle_driver *drv;
  	struct cpuidle_device *dev;
! 	struct device_node *np, *pds_node;
  
  	/* Detect OSI support based on CPU DT nodes */
  	sbi_cpuidle_use_osi = true;
  	for_each_possible_cpu(cpu) {
! 		np = of_cpu_device_node_get(cpu);
  		if (np &&
  		    of_property_present(np, "power-domains") &&
  		    of_property_present(np, "power-domain-names")) {
diff -crB linux/drivers/gpu/drm/amd/amdkfd/kfd_debug.c ClockworkPi-linux/drivers/gpu/drm/amd/amdkfd/kfd_debug.c
*** linux/drivers/gpu/drm/amd/amdkfd/kfd_debug.c	2025-01-18 12:31:58.249927800 -0500
--- ClockworkPi-linux/drivers/gpu/drm/amd/amdkfd/kfd_debug.c	2025-01-18 12:30:16.031196817 -0500
***************
*** 349,375 ****
  {
  	uint32_t spi_dbg_cntl = pdd->spi_dbg_override | pdd->spi_dbg_launch_mode;
  	uint32_t flags = pdd->process->dbg_flags;
- 	struct amdgpu_device *adev = pdd->dev->adev;
- 	int r;
  
  	if (!kfd_dbg_is_per_vmid_supported(pdd->dev))
  		return 0;
  
- 	if (!pdd->proc_ctx_cpu_ptr) {
- 			r = amdgpu_amdkfd_alloc_gtt_mem(adev,
- 				AMDGPU_MES_PROC_CTX_SIZE,
- 				&pdd->proc_ctx_bo,
- 				&pdd->proc_ctx_gpu_addr,
- 				&pdd->proc_ctx_cpu_ptr,
- 				false);
- 		if (r) {
- 			dev_err(adev->dev,
- 			"failed to allocate process context bo\n");
- 			return r;
- 		}
- 		memset(pdd->proc_ctx_cpu_ptr, 0, AMDGPU_MES_PROC_CTX_SIZE);
- 	}
- 
  	return amdgpu_mes_set_shader_debugger(pdd->dev->adev, pdd->proc_ctx_gpu_addr, spi_dbg_cntl,
  						pdd->watch_points, flags, sq_trap_en);
  }
--- 349,358 ----
diff -crB linux/drivers/gpu/drm/amd/display/dc/dc.h ClockworkPi-linux/drivers/gpu/drm/amd/display/dc/dc.h
*** linux/drivers/gpu/drm/amd/display/dc/dc.h	2025-01-18 12:31:58.289927336 -0500
--- ClockworkPi-linux/drivers/gpu/drm/amd/display/dc/dc.h	2025-01-18 12:30:16.071196286 -0500
***************
*** 49,55 ****
  
  #define DC_VER "3.2.247"
  
! #define MAX_SURFACES 4
  #define MAX_PLANES 6
  #define MAX_STREAMS 6
  #define MIN_VIEWPORT_SIZE 12
--- 49,55 ----
  
  #define DC_VER "3.2.247"
  
! #define MAX_SURFACES 3
  #define MAX_PLANES 6
  #define MAX_STREAMS 6
  #define MIN_VIEWPORT_SIZE 12
diff -crB linux/drivers/gpu/drm/amd/display/dc/dml/dml_inline_defs.h ClockworkPi-linux/drivers/gpu/drm/amd/display/dc/dml/dml_inline_defs.h
*** linux/drivers/gpu/drm/amd/display/dc/dml/dml_inline_defs.h	2025-01-18 12:31:58.381926268 -0500
--- ClockworkPi-linux/drivers/gpu/drm/amd/display/dc/dml/dml_inline_defs.h	2025-01-18 12:30:16.171194959 -0500
***************
*** 66,80 ****
  
  static inline double dml_ceil(double a, double granularity)
  {
- 	if (granularity == 0)
- 		return 0;
  	return (double) dcn_bw_ceil2(a, granularity);
  }
  
  static inline double dml_floor(double a, double granularity)
  {
- 	if (granularity == 0)
- 		return 0;
  	return (double) dcn_bw_floor2(a, granularity);
  }
  
--- 66,76 ----
***************
*** 118,132 ****
  
  static inline double dml_ceil_ex(double x, double granularity)
  {
- 	if (granularity == 0)
- 		return 0;
  	return (double) dcn_bw_ceil2(x, granularity);
  }
  
  static inline double dml_floor_ex(double x, double granularity)
  {
- 	if (granularity == 0)
- 		return 0;
  	return (double) dcn_bw_floor2(x, granularity);
  }
  
--- 114,124 ----
diff -crB linux/drivers/gpu/drm/mediatek/Kconfig ClockworkPi-linux/drivers/gpu/drm/mediatek/Kconfig
*** linux/drivers/gpu/drm/mediatek/Kconfig	2025-01-18 12:32:01.353891836 -0500
--- ClockworkPi-linux/drivers/gpu/drm/mediatek/Kconfig	2025-01-18 12:30:19.275153848 -0500
***************
*** 10,15 ****
--- 10,18 ----
  	select DRM_KMS_HELPER
  	select DRM_MIPI_DSI
  	select DRM_PANEL
+ 	select MEMORY
+ 	select MTK_SMI
+ 	select PHY_MTK_MIPI_DSI
  	select VIDEOMODE_HELPERS
  	help
  	  Choose this option if you have a Mediatek SoCs.
***************
*** 20,25 ****
--- 23,29 ----
  config DRM_MEDIATEK_DP
  	tristate "DRM DPTX Support for MediaTek SoCs"
  	depends on DRM_MEDIATEK
+ 	select PHY_MTK_DP
  	select DRM_DISPLAY_HELPER
  	select DRM_DISPLAY_DP_HELPER
  	select DRM_DP_AUX_BUS
***************
*** 30,34 ****
--- 34,39 ----
  	tristate "DRM HDMI Support for Mediatek SoCs"
  	depends on DRM_MEDIATEK
  	select SND_SOC_HDMI_CODEC if SND_SOC
+ 	select PHY_MTK_HDMI
  	help
  	  DRM/KMS HDMI driver for Mediatek SoCs
diff -crB linux/drivers/gpu/drm/mediatek/mtk_disp_ovl.c ClockworkPi-linux/drivers/gpu/drm/mediatek/mtk_disp_ovl.c
*** linux/drivers/gpu/drm/mediatek/mtk_disp_ovl.c	2025-01-18 12:32:01.353891836 -0500
--- ClockworkPi-linux/drivers/gpu/drm/mediatek/mtk_disp_ovl.c	2025-01-18 12:30:19.275153848 -0500
***************
*** 403,431 ****
  	}
  }
  
- static void mtk_ovl_afbc_layer_config(struct mtk_disp_ovl *ovl,
- 				      unsigned int idx,
- 				      struct mtk_plane_pending_state *pending,
- 				      struct cmdq_pkt *cmdq_pkt)
- {
- 	unsigned int pitch_msb = pending->pitch >> 16;
- 	unsigned int hdr_pitch = pending->hdr_pitch;
- 	unsigned int hdr_addr = pending->hdr_addr;
- 
- 	if (pending->modifier != DRM_FORMAT_MOD_LINEAR) {
- 		mtk_ddp_write_relaxed(cmdq_pkt, hdr_addr, &ovl->cmdq_reg, ovl->regs,
- 				      DISP_REG_OVL_HDR_ADDR(ovl, idx));
- 		mtk_ddp_write_relaxed(cmdq_pkt,
- 				      OVL_PITCH_MSB_2ND_SUBBUF | pitch_msb,
- 				      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_PITCH_MSB(idx));
- 		mtk_ddp_write_relaxed(cmdq_pkt, hdr_pitch, &ovl->cmdq_reg, ovl->regs,
- 				      DISP_REG_OVL_HDR_PITCH(ovl, idx));
- 	} else {
- 		mtk_ddp_write_relaxed(cmdq_pkt, pitch_msb,
- 				      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_PITCH_MSB(idx));
- 	}
- }
- 
  void mtk_ovl_layer_config(struct device *dev, unsigned int idx,
  			  struct mtk_plane_state *state,
  			  struct cmdq_pkt *cmdq_pkt)
--- 403,408 ----
***************
*** 433,444 ****
  	struct mtk_disp_ovl *ovl = dev_get_drvdata(dev);
  	struct mtk_plane_pending_state *pending = &state->pending;
  	unsigned int addr = pending->addr;
! 	unsigned int pitch_lsb = pending->pitch & GENMASK(15, 0);
  	unsigned int fmt = pending->format;
  	unsigned int offset = (pending->y << 16) | pending->x;
  	unsigned int src_size = (pending->height << 16) | pending->width;
  	unsigned int ignore_pixel_alpha = 0;
  	unsigned int con;
  
  	if (!pending->enable) {
  		mtk_ovl_layer_off(dev, idx, cmdq_pkt);
--- 410,433 ----
  	struct mtk_disp_ovl *ovl = dev_get_drvdata(dev);
  	struct mtk_plane_pending_state *pending = &state->pending;
  	unsigned int addr = pending->addr;
! 	unsigned int hdr_addr = pending->hdr_addr;
! 	unsigned int pitch = pending->pitch;
! 	unsigned int hdr_pitch = pending->hdr_pitch;
  	unsigned int fmt = pending->format;
  	unsigned int offset = (pending->y << 16) | pending->x;
  	unsigned int src_size = (pending->height << 16) | pending->width;
  	unsigned int ignore_pixel_alpha = 0;
  	unsigned int con;
+ 	bool is_afbc = pending->modifier != DRM_FORMAT_MOD_LINEAR;
+ 	union overlay_pitch {
+ 		struct split_pitch {
+ 			u16 lsb;
+ 			u16 msb;
+ 		} split_pitch;
+ 		u32 pitch;
+ 	} overlay_pitch;
+ 
+ 	overlay_pitch.pitch = pitch;
  
  	if (!pending->enable) {
  		mtk_ovl_layer_off(dev, idx, cmdq_pkt);
***************
*** 468,479 ****
  	}
  
  	if (ovl->data->supports_afbc)
! 		mtk_ovl_set_afbc(ovl, cmdq_pkt, idx,
! 				 pending->modifier != DRM_FORMAT_MOD_LINEAR);
  
  	mtk_ddp_write_relaxed(cmdq_pkt, con, &ovl->cmdq_reg, ovl->regs,
  			      DISP_REG_OVL_CON(idx));
! 	mtk_ddp_write_relaxed(cmdq_pkt, pitch_lsb | ignore_pixel_alpha,
  			      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_PITCH(idx));
  	mtk_ddp_write_relaxed(cmdq_pkt, src_size, &ovl->cmdq_reg, ovl->regs,
  			      DISP_REG_OVL_SRC_SIZE(idx));
--- 457,467 ----
  	}
  
  	if (ovl->data->supports_afbc)
! 		mtk_ovl_set_afbc(ovl, cmdq_pkt, idx, is_afbc);
  
  	mtk_ddp_write_relaxed(cmdq_pkt, con, &ovl->cmdq_reg, ovl->regs,
  			      DISP_REG_OVL_CON(idx));
! 	mtk_ddp_write_relaxed(cmdq_pkt, overlay_pitch.split_pitch.lsb | ignore_pixel_alpha,
  			      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_PITCH(idx));
  	mtk_ddp_write_relaxed(cmdq_pkt, src_size, &ovl->cmdq_reg, ovl->regs,
  			      DISP_REG_OVL_SRC_SIZE(idx));
***************
*** 482,489 ****
  	mtk_ddp_write_relaxed(cmdq_pkt, addr, &ovl->cmdq_reg, ovl->regs,
  			      DISP_REG_OVL_ADDR(ovl, idx));
  
! 	if (ovl->data->supports_afbc)
! 		mtk_ovl_afbc_layer_config(ovl, idx, pending, cmdq_pkt);
  
  	mtk_ovl_set_bit_depth(dev, idx, fmt, cmdq_pkt);
  	mtk_ovl_layer_on(dev, idx, cmdq_pkt);
--- 470,488 ----
  	mtk_ddp_write_relaxed(cmdq_pkt, addr, &ovl->cmdq_reg, ovl->regs,
  			      DISP_REG_OVL_ADDR(ovl, idx));
  
! 	if (is_afbc) {
! 		mtk_ddp_write_relaxed(cmdq_pkt, hdr_addr, &ovl->cmdq_reg, ovl->regs,
! 				      DISP_REG_OVL_HDR_ADDR(ovl, idx));
! 		mtk_ddp_write_relaxed(cmdq_pkt,
! 				      OVL_PITCH_MSB_2ND_SUBBUF | overlay_pitch.split_pitch.msb,
! 				      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_PITCH_MSB(idx));
! 		mtk_ddp_write_relaxed(cmdq_pkt, hdr_pitch, &ovl->cmdq_reg, ovl->regs,
! 				      DISP_REG_OVL_HDR_PITCH(ovl, idx));
! 	} else {
! 		mtk_ddp_write_relaxed(cmdq_pkt,
! 				      overlay_pitch.split_pitch.msb,
! 				      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_PITCH_MSB(idx));
! 	}
  
  	mtk_ovl_set_bit_depth(dev, idx, fmt, cmdq_pkt);
  	mtk_ovl_layer_on(dev, idx, cmdq_pkt);
diff -crB linux/drivers/gpu/drm/mediatek/mtk_dp.c ClockworkPi-linux/drivers/gpu/drm/mediatek/mtk_dp.c
*** linux/drivers/gpu/drm/mediatek/mtk_dp.c	2025-01-18 12:32:01.353891836 -0500
--- ClockworkPi-linux/drivers/gpu/drm/mediatek/mtk_dp.c	2025-01-18 12:30:19.279153795 -0500
***************
*** 458,473 ****
  				   enum dp_pixelformat color_format)
  {
  	u32 val;
! 	u32 misc0_color;
  
  	switch (color_format) {
  	case DP_PIXELFORMAT_YUV422:
  		val = PIXEL_ENCODE_FORMAT_DP_ENC0_P0_YCBCR422;
- 		misc0_color = DP_COLOR_FORMAT_YCbCr422;
  		break;
  	case DP_PIXELFORMAT_RGB:
  		val = PIXEL_ENCODE_FORMAT_DP_ENC0_P0_RGB;
- 		misc0_color = DP_COLOR_FORMAT_RGB;
  		break;
  	default:
  		drm_warn(mtk_dp->drm_dev, "Unsupported color format: %d\n",
--- 458,475 ----
  				   enum dp_pixelformat color_format)
  {
  	u32 val;
! 
! 	/* update MISC0 */
! 	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3034,
! 			   color_format << DP_TEST_COLOR_FORMAT_SHIFT,
! 			   DP_TEST_COLOR_FORMAT_MASK);
  
  	switch (color_format) {
  	case DP_PIXELFORMAT_YUV422:
  		val = PIXEL_ENCODE_FORMAT_DP_ENC0_P0_YCBCR422;
  		break;
  	case DP_PIXELFORMAT_RGB:
  		val = PIXEL_ENCODE_FORMAT_DP_ENC0_P0_RGB;
  		break;
  	default:
  		drm_warn(mtk_dp->drm_dev, "Unsupported color format: %d\n",
***************
*** 475,485 ****
  		return -EINVAL;
  	}
  
- 	/* update MISC0 */
- 	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3034,
- 			   misc0_color,
- 			   DP_TEST_COLOR_FORMAT_MASK);
- 
  	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_303C,
  			   val, PIXEL_ENCODE_FORMAT_DP_ENC0_P0_MASK);
  	return 0;
--- 477,482 ----
***************
*** 2005,2010 ****
--- 2002,2008 ----
  	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
  	enum drm_connector_status ret = connector_status_disconnected;
  	bool enabled = mtk_dp->enabled;
+ 	u8 sink_count = 0;
  
  	if (!mtk_dp->train_info.cable_plugged_in)
  		return ret;
***************
*** 2019,2026 ****
  	 * function, we just need to check the HPD connection to check
  	 * whether we connect to a sink device.
  	 */
! 
! 	if (drm_dp_read_sink_count(&mtk_dp->aux) > 0)
  		ret = connector_status_connected;
  
  	if (!enabled)
--- 2017,2024 ----
  	 * function, we just need to check the HPD connection to check
  	 * whether we connect to a sink device.
  	 */
! 	drm_dp_dpcd_readb(&mtk_dp->aux, DP_SINK_COUNT, &sink_count);
! 	if (DP_GET_SINK_COUNT(sink_count))
  		ret = connector_status_connected;
  
  	if (!enabled)
***************
*** 2312,2330 ****
  {
  	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
  	u32 bpp = info->color_formats & DRM_COLOR_FORMAT_YCBCR422 ? 16 : 24;
! 	u32 lane_count_min = mtk_dp->train_info.lane_count;
! 	u32 rate = drm_dp_bw_code_to_link_rate(mtk_dp->train_info.link_rate) *
! 		   lane_count_min;
  
! 	/*
! 	 *FEC overhead is approximately 2.4% from DP 1.4a spec 2.2.1.4.2.
! 	 *The down-spread amplitude shall either be disabled (0.0%) or up
! 	 *to 0.5% from 1.4a 3.5.2.6. Add up to approximately 3% total overhead.
! 	 *
! 	 *Because rate is already divided by 10,
! 	 *mode->clock does not need to be multiplied by 10
! 	 */
! 	if ((rate * 97 / 100) < (mode->clock * bpp / 8))
  		return MODE_CLOCK_HIGH;
  
  	return MODE_OK;
--- 2310,2321 ----
  {
  	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
  	u32 bpp = info->color_formats & DRM_COLOR_FORMAT_YCBCR422 ? 16 : 24;
! 	u32 rate = min_t(u32, drm_dp_max_link_rate(mtk_dp->rx_cap) *
! 			      drm_dp_max_lane_count(mtk_dp->rx_cap),
! 			 drm_dp_bw_code_to_link_rate(mtk_dp->max_linkrate) *
! 			 mtk_dp->max_lanes);
  
! 	if (rate < mode->clock * bpp / 8)
  		return MODE_CLOCK_HIGH;
  
  	return MODE_OK;
***************
*** 2365,2373 ****
  	struct drm_display_mode *mode = &crtc_state->adjusted_mode;
  	struct drm_display_info *display_info =
  		&conn_state->connector->display_info;
! 	u32 lane_count_min = mtk_dp->train_info.lane_count;
! 	u32 rate = drm_dp_bw_code_to_link_rate(mtk_dp->train_info.link_rate) *
! 		   lane_count_min;
  
  	*num_input_fmts = 0;
  
--- 2356,2365 ----
  	struct drm_display_mode *mode = &crtc_state->adjusted_mode;
  	struct drm_display_info *display_info =
  		&conn_state->connector->display_info;
! 	u32 rate = min_t(u32, drm_dp_max_link_rate(mtk_dp->rx_cap) *
! 			      drm_dp_max_lane_count(mtk_dp->rx_cap),
! 			 drm_dp_bw_code_to_link_rate(mtk_dp->max_linkrate) *
! 			 mtk_dp->max_lanes);
  
  	*num_input_fmts = 0;
  
***************
*** 2376,2383 ****
  	 * datarate of YUV422 and sink device supports YUV422, we output YUV422
  	 * format. Use this condition, we can support more resolution.
  	 */
! 	if (((rate * 97 / 100) < (mode->clock * 24 / 8)) &&
! 	    ((rate * 97 / 100) > (mode->clock * 16 / 8)) &&
  	    (display_info->color_formats & DRM_COLOR_FORMAT_YCBCR422)) {
  		input_fmts = kcalloc(1, sizeof(*input_fmts), GFP_KERNEL);
  		if (!input_fmts)
--- 2368,2375 ----
  	 * datarate of YUV422 and sink device supports YUV422, we output YUV422
  	 * format. Use this condition, we can support more resolution.
  	 */
! 	if ((rate < (mode->clock * 24 / 8)) &&
! 	    (rate > (mode->clock * 16 / 8)) &&
  	    (display_info->color_formats & DRM_COLOR_FORMAT_YCBCR422)) {
  		input_fmts = kcalloc(1, sizeof(*input_fmts), GFP_KERNEL);
  		if (!input_fmts)
diff -crB linux/drivers/gpu/drm/mediatek/mtk_drm_drv.c ClockworkPi-linux/drivers/gpu/drm/mediatek/mtk_drm_drv.c
*** linux/drivers/gpu/drm/mediatek/mtk_drm_drv.c	2025-01-18 12:32:01.357891789 -0500
--- ClockworkPi-linux/drivers/gpu/drm/mediatek/mtk_drm_drv.c	2025-01-18 12:30:19.283153742 -0500
***************
*** 633,640 ****
  err_free:
  	private->drm = NULL;
  	drm_dev_put(drm);
- 	for (i = 0; i < private->data->mmsys_dev_num; i++)
- 		private->all_drm_private[i]->drm = NULL;
  	return ret;
  }
  
--- 633,638 ----
diff -crB linux/drivers/gpu/drm/panel/Kconfig ClockworkPi-linux/drivers/gpu/drm/panel/Kconfig
*** linux/drivers/gpu/drm/panel/Kconfig	2025-01-18 12:32:01.849886101 -0500
--- ClockworkPi-linux/drivers/gpu/drm/panel/Kconfig	2025-01-18 12:30:19.491150994 -0500
***************
*** 76,81 ****
--- 76,107 ----
  	  Say Y here if you want to support for BOE TV101WUM and AUO KD101N80
  	  45NA WUXGA PANEL DSI Video Mode panel
  
+ 
+ config DRM_PANEL_CWD686
+ 	tristate "CWD686 panel"
+ 	depends on OF
+ 	depends on DRM_MIPI_DSI
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	help
+ 	  Say Y here if you want to enable support for CWD686 panel.
+ 	  The panel has a 480x1280 resolution and uses 24 bit RGB per pixel.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called panel-cwd686.
+ 
+ config DRM_PANEL_CWU50
+ 	tristate "CWU50 panel"
+ 	depends on OF
+ 	depends on DRM_MIPI_DSI
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	help
+ 	  Say Y here if you want to enable support for CWU50 panel.
+ 	  The panel has a 720x1280 resolution and uses 24 bit RGB per pixel.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called panel-cwu50.
+ 
+ 
  config DRM_PANEL_DSI_CM
  	tristate "Generic DSI command mode panels"
  	depends on OF
diff -crB linux/drivers/gpu/drm/panel/Makefile ClockworkPi-linux/drivers/gpu/drm/panel/Makefile
*** linux/drivers/gpu/drm/panel/Makefile	2025-01-18 12:32:01.849886101 -0500
--- ClockworkPi-linux/drivers/gpu/drm/panel/Makefile	2025-01-18 12:30:19.491150994 -0500
***************
*** 88,90 ****
--- 88,92 ----
  obj-$(CONFIG_DRM_PANEL_WAVESHARE_TOUCHSCREEN) += panel-waveshare-dsi.o
  obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
  obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+ obj-$(CONFIG_DRM_PANEL_CWD686) += panel-cwd686.o
+ obj-$(CONFIG_DRM_PANEL_CWU50) += panel-cwu50.o
Only in ClockworkPi-linux/drivers/gpu/drm/panel: panel-cwd686.c
Only in ClockworkPi-linux/drivers/gpu/drm/panel: panel-cwu50.c
diff -crB linux/drivers/gpu/drm/vc4/vc4_dsi.c ClockworkPi-linux/drivers/gpu/drm/vc4/vc4_dsi.c
*** linux/drivers/gpu/drm/vc4/vc4_dsi.c	2025-01-18 12:32:02.049883790 -0500
--- ClockworkPi-linux/drivers/gpu/drm/vc4/vc4_dsi.c	2025-01-18 12:30:19.635149091 -0500
***************
*** 759,765 ****
  			 (dsi->lanes > 1 ? DSI1_STAT_PHY_D1_STOP : 0) |
  			 (dsi->lanes > 2 ? DSI1_STAT_PHY_D2_STOP : 0) |
  			 (dsi->lanes > 3 ? DSI1_STAT_PHY_D3_STOP : 0));
! 	int ret;
  	bool ulps_currently_enabled = (DSI_PORT_READ(PHY_AFEC0) &
  				       DSI_PORT_BIT(PHY_AFEC0_LATCH_ULPS));
  
--- 759,765 ----
  			 (dsi->lanes > 1 ? DSI1_STAT_PHY_D1_STOP : 0) |
  			 (dsi->lanes > 2 ? DSI1_STAT_PHY_D2_STOP : 0) |
  			 (dsi->lanes > 3 ? DSI1_STAT_PHY_D3_STOP : 0));
! 	int ret, i = 0;
  	bool ulps_currently_enabled = (DSI_PORT_READ(PHY_AFEC0) &
  				       DSI_PORT_BIT(PHY_AFEC0_LATCH_ULPS));
  
***************
*** 787,800 ****
  
  	DSI_PORT_WRITE(STAT, stat_stop);
  	DSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);
! 	ret = wait_for((DSI_PORT_READ(STAT) & stat_stop) == stat_stop, 200);
! 	if (ret) {
! 		dev_warn(&dsi->pdev->dev,
! 			 "Timeout waiting for DSI STOP entry: STAT 0x%08x",
! 			 DSI_PORT_READ(STAT));
! 		DSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);
! 		return;
  	}
  }
  
  static u32
--- 787,801 ----
  
  	DSI_PORT_WRITE(STAT, stat_stop);
  	DSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);
! 	while(wait_for((DSI_PORT_READ(STAT) & stat_stop) == stat_stop, 200)){
! 		if(i++ == 10) {
! 			DSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);
! 			break;
! 		}
  	}
+ 	if(i > 0)
+ 		dev_warn(&dsi->pdev->dev, "Timeout waiting for DSI STOP entry: STAT 0x%08x %d", DSI_PORT_READ(STAT), i);
+ 	return;
  }
  
  static u32
diff -crB linux/drivers/hwmon/drivetemp.c ClockworkPi-linux/drivers/hwmon/drivetemp.c
*** linux/drivers/hwmon/drivetemp.c	2025-01-18 12:32:02.149882635 -0500
--- ClockworkPi-linux/drivers/hwmon/drivetemp.c	2025-01-18 12:30:19.739147717 -0500
***************
*** 165,171 ****
  {
  	u8 scsi_cmd[MAX_COMMAND_SIZE];
  	enum req_op op;
- 	int err;
  
  	memset(scsi_cmd, 0, sizeof(scsi_cmd));
  	scsi_cmd[0] = ATA_16;
--- 165,170 ----
***************
*** 193,203 ****
  	scsi_cmd[12] = lba_high;
  	scsi_cmd[14] = ata_command;
  
! 	err = scsi_execute_cmd(st->sdev, scsi_cmd, op, st->smartdata,
! 			       ATA_SECT_SIZE, HZ, 5, NULL);
! 	if (err > 0)
! 		err = -EIO;
! 	return err;
  }
  
  static int drivetemp_ata_command(struct drivetemp_data *st, u8 feature,
--- 192,199 ----
  	scsi_cmd[12] = lba_high;
  	scsi_cmd[14] = ata_command;
  
! 	return scsi_execute_cmd(st->sdev, scsi_cmd, op, st->smartdata,
! 				ATA_SECT_SIZE, HZ, 5, NULL);
  }
  
  static int drivetemp_ata_command(struct drivetemp_data *st, u8 feature,
diff -crB linux/drivers/iio/adc/ad7124.c ClockworkPi-linux/drivers/iio/adc/ad7124.c
*** linux/drivers/iio/adc/ad7124.c	2025-01-18 12:32:02.265881295 -0500
--- ClockworkPi-linux/drivers/iio/adc/ad7124.c	2025-01-18 12:30:19.855146184 -0500
***************
*** 923,931 ****
  		 * set all channels to this default value.
  		 */
  		ad7124_set_channel_odr(st, i, 10);
- 
- 		/* Disable all channels to prevent unintended conversions. */
- 		ad_sd_write_reg(&st->sd, AD7124_CHANNEL(i), 2, 0);
  	}
  
  	return ret;
--- 923,928 ----
diff -crB linux/drivers/iio/adc/at91_adc.c ClockworkPi-linux/drivers/iio/adc/at91_adc.c
*** linux/drivers/iio/adc/at91_adc.c	2025-01-18 12:32:02.269881249 -0500
--- ClockworkPi-linux/drivers/iio/adc/at91_adc.c	2025-01-18 12:30:19.863146078 -0500
***************
*** 984,990 ****
  	return ret;
  
  err:
! 	input_free_device(input);
  	return ret;
  }
  
--- 984,990 ----
  	return ret;
  
  err:
! 	input_free_device(st->ts_input);
  	return ret;
  }
  
diff -crB linux/drivers/iio/adc/rockchip_saradc.c ClockworkPi-linux/drivers/iio/adc/rockchip_saradc.c
*** linux/drivers/iio/adc/rockchip_saradc.c	2025-01-18 12:32:02.281881111 -0500
--- ClockworkPi-linux/drivers/iio/adc/rockchip_saradc.c	2025-01-18 12:30:19.871145973 -0500
***************
*** 368,375 ****
  	int ret;
  	int i, j = 0;
  
- 	memset(&data, 0, sizeof(data));
- 
  	mutex_lock(&info->lock);
  
  	for_each_set_bit(i, i_dev->active_scan_mask, i_dev->masklength) {
--- 368,373 ----
diff -crB linux/drivers/iio/adc/ti-ads124s08.c ClockworkPi-linux/drivers/iio/adc/ti-ads124s08.c
*** linux/drivers/iio/adc/ti-ads124s08.c	2025-01-18 12:32:02.285881064 -0500
--- ClockworkPi-linux/drivers/iio/adc/ti-ads124s08.c	2025-01-18 12:30:19.875145920 -0500
***************
*** 183,191 ****
  	struct ads124s_private *priv = iio_priv(indio_dev);
  
  	if (priv->reset_gpio) {
! 		gpiod_set_value_cansleep(priv->reset_gpio, 0);
  		udelay(200);
! 		gpiod_set_value_cansleep(priv->reset_gpio, 1);
  	} else {
  		return ads124s_write_cmd(indio_dev, ADS124S08_CMD_RESET);
  	}
--- 183,191 ----
  	struct ads124s_private *priv = iio_priv(indio_dev);
  
  	if (priv->reset_gpio) {
! 		gpiod_set_value(priv->reset_gpio, 0);
  		udelay(200);
! 		gpiod_set_value(priv->reset_gpio, 1);
  	} else {
  		return ads124s_write_cmd(indio_dev, ADS124S08_CMD_RESET);
  	}
diff -crB linux/drivers/iio/adc/ti-ads8688.c ClockworkPi-linux/drivers/iio/adc/ti-ads8688.c
*** linux/drivers/iio/adc/ti-ads8688.c	2025-01-18 12:32:02.285881064 -0500
--- ClockworkPi-linux/drivers/iio/adc/ti-ads8688.c	2025-01-18 12:30:19.879145867 -0500
***************
*** 382,388 ****
  	struct iio_poll_func *pf = p;
  	struct iio_dev *indio_dev = pf->indio_dev;
  	/* Ensure naturally aligned timestamp */
! 	u16 buffer[ADS8688_MAX_CHANNELS + sizeof(s64)/sizeof(u16)] __aligned(8) = { };
  	int i, j = 0;
  
  	for (i = 0; i < indio_dev->masklength; i++) {
--- 382,388 ----
  	struct iio_poll_func *pf = p;
  	struct iio_dev *indio_dev = pf->indio_dev;
  	/* Ensure naturally aligned timestamp */
! 	u16 buffer[ADS8688_MAX_CHANNELS + sizeof(s64)/sizeof(u16)] __aligned(8);
  	int i, j = 0;
  
  	for (i = 0; i < indio_dev->masklength; i++) {
diff -crB linux/drivers/iio/dummy/iio_simple_dummy_buffer.c ClockworkPi-linux/drivers/iio/dummy/iio_simple_dummy_buffer.c
*** linux/drivers/iio/dummy/iio_simple_dummy_buffer.c	2025-01-18 12:32:02.305880833 -0500
--- ClockworkPi-linux/drivers/iio/dummy/iio_simple_dummy_buffer.c	2025-01-18 12:30:19.899145603 -0500
***************
*** 48,54 ****
  	int i = 0, j;
  	u16 *data;
  
! 	data = kzalloc(indio_dev->scan_bytes, GFP_KERNEL);
  	if (!data)
  		goto done;
  
--- 48,54 ----
  	int i = 0, j;
  	u16 *data;
  
! 	data = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);
  	if (!data)
  		goto done;
  
diff -crB linux/drivers/iio/gyro/fxas21002c_core.c ClockworkPi-linux/drivers/iio/gyro/fxas21002c_core.c
*** linux/drivers/iio/gyro/fxas21002c_core.c	2025-01-18 12:32:02.309880787 -0500
--- ClockworkPi-linux/drivers/iio/gyro/fxas21002c_core.c	2025-01-18 12:30:19.903145550 -0500
***************
*** 730,750 ****
  	int ret;
  
  	mutex_lock(&data->lock);
- 	ret = fxas21002c_pm_get(data);
- 	if (ret < 0)
- 		goto out_unlock;
- 
  	ret = regmap_bulk_read(data->regmap, FXAS21002C_REG_OUT_X_MSB,
  			       data->buffer, CHANNEL_SCAN_MAX * sizeof(s16));
  	if (ret < 0)
! 		goto out_pm_put;
  
  	iio_push_to_buffers_with_timestamp(indio_dev, data->buffer,
  					   data->timestamp);
  
- out_pm_put:
- 	fxas21002c_pm_put(data);
- 
  out_unlock:
  	mutex_unlock(&data->lock);
  
--- 730,743 ----
  	int ret;
  
  	mutex_lock(&data->lock);
  	ret = regmap_bulk_read(data->regmap, FXAS21002C_REG_OUT_X_MSB,
  			       data->buffer, CHANNEL_SCAN_MAX * sizeof(s16));
  	if (ret < 0)
! 		goto out_unlock;
  
  	iio_push_to_buffers_with_timestamp(indio_dev, data->buffer,
  					   data->timestamp);
  
  out_unlock:
  	mutex_unlock(&data->lock);
  
diff -crB linux/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c ClockworkPi-linux/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c
*** linux/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c	2025-01-18 12:32:02.321880649 -0500
--- ClockworkPi-linux/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c	2025-01-18 12:30:19.915145391 -0500
***************
*** 17,23 ****
  #include <linux/regmap.h>
  
  #include <linux/iio/iio.h>
- #include <linux/iio/common/inv_sensors_timestamp.h>
  
  #include "inv_icm42600.h"
  #include "inv_icm42600_buffer.h"
--- 17,22 ----
***************
*** 726,733 ****
  static int inv_icm42600_resume(struct device *dev)
  {
  	struct inv_icm42600_state *st = dev_get_drvdata(dev);
- 	struct inv_sensors_timestamp *gyro_ts = iio_priv(st->indio_gyro);
- 	struct inv_sensors_timestamp *accel_ts = iio_priv(st->indio_accel);
  	int ret;
  
  	mutex_lock(&st->lock);
--- 725,730 ----
***************
*** 748,759 ****
  		goto out_unlock;
  
  	/* restore FIFO data streaming */
! 	if (st->fifo.on) {
! 		inv_sensors_timestamp_reset(gyro_ts);
! 		inv_sensors_timestamp_reset(accel_ts);
  		ret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,
  				   INV_ICM42600_FIFO_CONFIG_STREAM);
- 	}
  
  out_unlock:
  	mutex_unlock(&st->lock);
--- 745,753 ----
  		goto out_unlock;
  
  	/* restore FIFO data streaming */
! 	if (st->fifo.on)
  		ret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,
  				   INV_ICM42600_FIFO_CONFIG_STREAM);
  
  out_unlock:
  	mutex_unlock(&st->lock);
diff -crB linux/drivers/iio/imu/kmx61.c ClockworkPi-linux/drivers/iio/imu/kmx61.c
*** linux/drivers/iio/imu/kmx61.c	2025-01-18 12:32:02.321880649 -0500
--- ClockworkPi-linux/drivers/iio/imu/kmx61.c	2025-01-18 12:30:19.915145391 -0500
***************
*** 1192,1198 ****
  	struct kmx61_data *data = kmx61_get_data(indio_dev);
  	int bit, ret, i = 0;
  	u8 base;
! 	s16 buffer[8] = { };
  
  	if (indio_dev == data->acc_indio_dev)
  		base = KMX61_ACC_XOUT_L;
--- 1192,1198 ----
  	struct kmx61_data *data = kmx61_get_data(indio_dev);
  	int bit, ret, i = 0;
  	u8 base;
! 	s16 buffer[8];
  
  	if (indio_dev == data->acc_indio_dev)
  		base = KMX61_ACC_XOUT_L;
diff -crB linux/drivers/iio/inkern.c ClockworkPi-linux/drivers/iio/inkern.c
*** linux/drivers/iio/inkern.c	2025-01-18 12:32:02.325880603 -0500
--- ClockworkPi-linux/drivers/iio/inkern.c	2025-01-18 12:30:19.919145338 -0500
***************
*** 514,520 ****
  	return chans;
  
  error_free_chans:
! 	for (i = 0; i < mapind; i++)
  		iio_device_put(chans[i].indio_dev);
  	kfree(chans);
  error_ret:
--- 514,520 ----
  	return chans;
  
  error_free_chans:
! 	for (i = 0; i < nummaps; i++)
  		iio_device_put(chans[i].indio_dev);
  	kfree(chans);
  error_ret:
diff -crB linux/drivers/iio/light/vcnl4035.c ClockworkPi-linux/drivers/iio/light/vcnl4035.c
*** linux/drivers/iio/light/vcnl4035.c	2025-01-18 12:32:02.337880464 -0500
--- ClockworkPi-linux/drivers/iio/light/vcnl4035.c	2025-01-18 12:30:19.931145180 -0500
***************
*** 105,111 ****
  	struct iio_dev *indio_dev = pf->indio_dev;
  	struct vcnl4035_data *data = iio_priv(indio_dev);
  	/* Ensure naturally aligned timestamp */
! 	u8 buffer[ALIGN(sizeof(u16), sizeof(s64)) + sizeof(s64)]  __aligned(8) = { };
  	int ret;
  
  	ret = regmap_read(data->regmap, VCNL4035_ALS_DATA, (int *)buffer);
--- 105,111 ----
  	struct iio_dev *indio_dev = pf->indio_dev;
  	struct vcnl4035_data *data = iio_priv(indio_dev);
  	/* Ensure naturally aligned timestamp */
! 	u8 buffer[ALIGN(sizeof(u16), sizeof(s64)) + sizeof(s64)]  __aligned(8);
  	int ret;
  
  	ret = regmap_read(data->regmap, VCNL4035_ALS_DATA, (int *)buffer);
diff -crB linux/drivers/iio/pressure/zpa2326.c ClockworkPi-linux/drivers/iio/pressure/zpa2326.c
*** linux/drivers/iio/pressure/zpa2326.c	2025-01-18 12:32:02.349880325 -0500
--- ClockworkPi-linux/drivers/iio/pressure/zpa2326.c	2025-01-18 12:30:19.943145021 -0500
***************
*** 586,593 ****
  	}   sample;
  	int err;
  
- 	memset(&sample, 0, sizeof(sample));
- 
  	if (test_bit(0, indio_dev->active_scan_mask)) {
  		/* Get current pressure from hardware FIFO. */
  		err = zpa2326_dequeue_pressure(indio_dev, &sample.pressure);
--- 586,591 ----
diff -crB linux/drivers/md/dm-ebs-target.c ClockworkPi-linux/drivers/md/dm-ebs-target.c
*** linux/drivers/md/dm-ebs-target.c	2025-01-18 12:32:02.681876492 -0500
--- ClockworkPi-linux/drivers/md/dm-ebs-target.c	2025-01-18 12:30:20.351139637 -0500
***************
*** 442,448 ****
  static struct target_type ebs_target = {
  	.name		 = "ebs",
  	.version	 = {1, 0, 1},
! 	.features	 = 0,
  	.module		 = THIS_MODULE,
  	.ctr		 = ebs_ctr,
  	.dtr		 = ebs_dtr,
--- 442,448 ----
  static struct target_type ebs_target = {
  	.name		 = "ebs",
  	.version	 = {1, 0, 1},
! 	.features	 = DM_TARGET_PASSES_INTEGRITY,
  	.module		 = THIS_MODULE,
  	.ctr		 = ebs_ctr,
  	.dtr		 = ebs_dtr,
diff -crB linux/drivers/md/dm-thin.c ClockworkPi-linux/drivers/md/dm-thin.c
*** linux/drivers/md/dm-thin.c	2025-01-18 12:32:02.693876353 -0500
--- ClockworkPi-linux/drivers/md/dm-thin.c	2025-01-18 12:30:20.363139478 -0500
***************
*** 2334,2342 ****
  	struct thin_c *tc = NULL;
  
  	rcu_read_lock();
! 	tc = list_first_or_null_rcu(&pool->active_thins, struct thin_c, list);
! 	if (tc)
  		thin_get(tc);
  	rcu_read_unlock();
  
  	return tc;
--- 2334,2343 ----
  	struct thin_c *tc = NULL;
  
  	rcu_read_lock();
! 	if (!list_empty(&pool->active_thins)) {
! 		tc = list_entry_rcu(pool->active_thins.next, struct thin_c, list);
  		thin_get(tc);
+ 	}
  	rcu_read_unlock();
  
  	return tc;
diff -crB linux/drivers/md/dm-verity-fec.c ClockworkPi-linux/drivers/md/dm-verity-fec.c
*** linux/drivers/md/dm-verity-fec.c	2025-01-18 12:32:02.693876353 -0500
--- ClockworkPi-linux/drivers/md/dm-verity-fec.c	2025-01-18 12:30:20.363139478 -0500
***************
*** 60,78 ****
   * to the data block. Caller is responsible for releasing buf.
   */
  static u8 *fec_read_parity(struct dm_verity *v, u64 rsb, int index,
! 			   unsigned int *offset, unsigned int par_buf_offset,
! 			  struct dm_buffer **buf)
  {
  	u64 position, block, rem;
  	u8 *res;
  
- 	/* We have already part of parity bytes read, skip to the next block */
- 	if (par_buf_offset)
- 		index++;
- 
  	position = (index + rsb) * v->fec->roots;
  	block = div64_u64_rem(position, v->fec->io_size, &rem);
! 	*offset = par_buf_offset ? 0 : (unsigned int)rem;
  
  	res = dm_bufio_read(v->fec->bufio, block, buf);
  	if (IS_ERR(res)) {
--- 60,73 ----
   * to the data block. Caller is responsible for releasing buf.
   */
  static u8 *fec_read_parity(struct dm_verity *v, u64 rsb, int index,
! 			   unsigned int *offset, struct dm_buffer **buf)
  {
  	u64 position, block, rem;
  	u8 *res;
  
  	position = (index + rsb) * v->fec->roots;
  	block = div64_u64_rem(position, v->fec->io_size, &rem);
! 	*offset = (unsigned int)rem;
  
  	res = dm_bufio_read(v->fec->bufio, block, buf);
  	if (IS_ERR(res)) {
***************
*** 132,142 ****
  {
  	int r, corrected = 0, res;
  	struct dm_buffer *buf;
! 	unsigned int n, i, offset, par_buf_offset = 0;
! 	u8 *par, *block, par_buf[DM_VERITY_FEC_RSM - DM_VERITY_FEC_MIN_RSN];
  
! 	par = fec_read_parity(v, rsb, block_offset, &offset,
! 			      par_buf_offset, &buf);
  	if (IS_ERR(par))
  		return PTR_ERR(par);
  
--- 127,136 ----
  {
  	int r, corrected = 0, res;
  	struct dm_buffer *buf;
! 	unsigned int n, i, offset;
! 	u8 *par, *block;
  
! 	par = fec_read_parity(v, rsb, block_offset, &offset, &buf);
  	if (IS_ERR(par))
  		return PTR_ERR(par);
  
***************
*** 146,153 ****
  	 */
  	fec_for_each_buffer_rs_block(fio, n, i) {
  		block = fec_buffer_rs_block(v, fio, n, i);
! 		memcpy(&par_buf[par_buf_offset], &par[offset], v->fec->roots - par_buf_offset);
! 		res = fec_decode_rs8(v, fio, block, par_buf, neras);
  		if (res < 0) {
  			r = res;
  			goto error;
--- 140,146 ----
  	 */
  	fec_for_each_buffer_rs_block(fio, n, i) {
  		block = fec_buffer_rs_block(v, fio, n, i);
! 		res = fec_decode_rs8(v, fio, block, &par[offset], neras);
  		if (res < 0) {
  			r = res;
  			goto error;
***************
*** 160,180 ****
  		if (block_offset >= 1 << v->data_dev_block_bits)
  			goto done;
  
! 		/* Read the next block when we run out of parity bytes */
! 		offset += (v->fec->roots - par_buf_offset);
! 		/* Check if parity bytes are split between blocks */
! 		if (offset < v->fec->io_size && (offset + v->fec->roots) > v->fec->io_size) {
! 			par_buf_offset = v->fec->io_size - offset;
! 			memcpy(par_buf, &par[offset], par_buf_offset);
! 			offset += par_buf_offset;
! 		} else
! 			par_buf_offset = 0;
! 
  		if (offset >= v->fec->io_size) {
  			dm_bufio_release(buf);
  
! 			par = fec_read_parity(v, rsb, block_offset, &offset,
! 					      par_buf_offset, &buf);
  			if (IS_ERR(par))
  				return PTR_ERR(par);
  		}
--- 153,164 ----
  		if (block_offset >= 1 << v->data_dev_block_bits)
  			goto done;
  
! 		/* read the next block when we run out of parity bytes */
! 		offset += v->fec->roots;
  		if (offset >= v->fec->io_size) {
  			dm_bufio_release(buf);
  
! 			par = fec_read_parity(v, rsb, block_offset, &offset, &buf);
  			if (IS_ERR(par))
  				return PTR_ERR(par);
  		}
***************
*** 759,765 ****
  		return -E2BIG;
  	}
  
! 	f->io_size = 1 << v->data_dev_block_bits;
  
  	f->bufio = dm_bufio_client_create(f->dev->bdev,
  					  f->io_size,
--- 743,752 ----
  		return -E2BIG;
  	}
  
! 	if ((f->roots << SECTOR_SHIFT) & ((1 << v->data_dev_block_bits) - 1))
! 		f->io_size = 1 << v->data_dev_block_bits;
! 	else
! 		f->io_size = v->fec->roots << SECTOR_SHIFT;
  
  	f->bufio = dm_bufio_client_create(f->dev->bdev,
  					  f->io_size,
diff -crB linux/drivers/md/persistent-data/dm-array.c ClockworkPi-linux/drivers/md/persistent-data/dm-array.c
*** linux/drivers/md/persistent-data/dm-array.c	2025-01-18 12:32:02.701876261 -0500
--- ClockworkPi-linux/drivers/md/persistent-data/dm-array.c	2025-01-18 12:30:20.375139320 -0500
***************
*** 917,943 ****
  	if (c->block)
  		unlock_ablock(c->info, c->block);
  
  	c->index = 0;
  
  	r = dm_btree_cursor_get_value(&c->cursor, &key, &value_le);
  	if (r) {
  		DMERR("dm_btree_cursor_get_value failed");
! 		goto out;
  
  	} else {
  		r = get_ablock(c->info, le64_to_cpu(value_le), &c->block, &c->ab);
  		if (r) {
  			DMERR("get_ablock failed");
! 			goto out;
  		}
  	}
  
- 	return 0;
- 
- out:
- 	dm_btree_cursor_end(&c->cursor);
- 	c->block = NULL;
- 	c->ab = NULL;
  	return r;
  }
  
--- 917,939 ----
  	if (c->block)
  		unlock_ablock(c->info, c->block);
  
+ 	c->block = NULL;
+ 	c->ab = NULL;
  	c->index = 0;
  
  	r = dm_btree_cursor_get_value(&c->cursor, &key, &value_le);
  	if (r) {
  		DMERR("dm_btree_cursor_get_value failed");
! 		dm_btree_cursor_end(&c->cursor);
  
  	} else {
  		r = get_ablock(c->info, le64_to_cpu(value_le), &c->block, &c->ab);
  		if (r) {
  			DMERR("get_ablock failed");
! 			dm_btree_cursor_end(&c->cursor);
  		}
  	}
  
  	return r;
  }
  
***************
*** 960,969 ****
  
  void dm_array_cursor_end(struct dm_array_cursor *c)
  {
! 	if (c->block)
  		unlock_ablock(c->info, c->block);
! 
! 	dm_btree_cursor_end(&c->cursor);
  }
  EXPORT_SYMBOL_GPL(dm_array_cursor_end);
  
--- 956,965 ----
  
  void dm_array_cursor_end(struct dm_array_cursor *c)
  {
! 	if (c->block) {
  		unlock_ablock(c->info, c->block);
! 		dm_btree_cursor_end(&c->cursor);
! 	}
  }
  EXPORT_SYMBOL_GPL(dm_array_cursor_end);
  
***************
*** 1003,1009 ****
  		}
  
  		count -= remaining;
- 		c->index += (remaining - 1);
  		r = dm_array_cursor_next(c);
  
  	} while (!r);
--- 999,1004 ----
diff -crB linux/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h ClockworkPi-linux/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h
*** linux/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h	2025-01-18 12:32:02.977873074 -0500
--- ClockworkPi-linux/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h	2025-01-18 12:30:20.655135625 -0500
***************
*** 129,144 ****
  		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
  		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
  	},
- 	{
- 		.fourcc		    = V4L2_PIX_FMT_YUV422P,
- 		/* 128 alignment to ensure U/V planes are 64 byte aligned. */
- 		.align		    = 128,
- 		.bit_depth	    = 8,
- 		.plane_factor	    = { P3(1), P3(0.5), P3(0.5) },
- 		.num_planes	    = 1,
- 		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
- 		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
- 	},
  	/* Multiplane YUV formats */
  	{
  		.fourcc		    = V4L2_PIX_FMT_YUV420M,
--- 129,134 ----
diff -crB linux/drivers/misc/mchp_pci1xxxx/mchp_pci1xxxx_gpio.c ClockworkPi-linux/drivers/misc/mchp_pci1xxxx/mchp_pci1xxxx_gpio.c
*** linux/drivers/misc/mchp_pci1xxxx/mchp_pci1xxxx_gpio.c	2025-01-18 12:32:03.277869614 -0500
--- ClockworkPi-linux/drivers/misc/mchp_pci1xxxx/mchp_pci1xxxx_gpio.c	2025-01-18 12:30:20.963131561 -0500
***************
*** 148,154 ****
  		pci1xxx_assign_bit(priv->reg_base, OPENDRAIN_OFFSET(offset), (offset % 32), true);
  		break;
  	default:
! 		ret = -ENOTSUPP;
  		break;
  	}
  	spin_unlock_irqrestore(&priv->lock, flags);
--- 148,154 ----
  		pci1xxx_assign_bit(priv->reg_base, OPENDRAIN_OFFSET(offset), (offset % 32), true);
  		break;
  	default:
! 		ret = -EOPNOTSUPP;
  		break;
  	}
  	spin_unlock_irqrestore(&priv->lock, flags);
***************
*** 277,283 ****
  			writel(BIT(bit), priv->reg_base + INTR_STATUS_OFFSET(gpiobank));
  			spin_unlock_irqrestore(&priv->lock, flags);
  			irq = irq_find_mapping(gc->irq.domain, (bit + (gpiobank * 32)));
! 			handle_nested_irq(irq);
  		}
  	}
  	spin_lock_irqsave(&priv->lock, flags);
--- 277,283 ----
  			writel(BIT(bit), priv->reg_base + INTR_STATUS_OFFSET(gpiobank));
  			spin_unlock_irqrestore(&priv->lock, flags);
  			irq = irq_find_mapping(gc->irq.domain, (bit + (gpiobank * 32)));
! 			generic_handle_irq(irq);
  		}
  	}
  	spin_lock_irqsave(&priv->lock, flags);
diff -crB linux/drivers/net/ethernet/amd/pds_core/devlink.c ClockworkPi-linux/drivers/net/ethernet/amd/pds_core/devlink.c
*** linux/drivers/net/ethernet/amd/pds_core/devlink.c	2025-01-18 12:32:03.493867123 -0500
--- ClockworkPi-linux/drivers/net/ethernet/amd/pds_core/devlink.c	2025-01-18 12:30:21.179128714 -0500
***************
*** 117,123 ****
  	if (err && err != -EIO)
  		return err;
  
! 	listlen = min(fw_list.num_fw_slots, ARRAY_SIZE(fw_list.fw_names));
  	for (i = 0; i < listlen; i++) {
  		if (i < ARRAY_SIZE(fw_slotnames))
  			strscpy(buf, fw_slotnames[i], sizeof(buf));
--- 117,123 ----
  	if (err && err != -EIO)
  		return err;
  
! 	listlen = fw_list.num_fw_slots;
  	for (i = 0; i < listlen; i++) {
  		if (i < ARRAY_SIZE(fw_slotnames))
  			strscpy(buf, fw_slotnames[i], sizeof(buf));
diff -crB linux/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c ClockworkPi-linux/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c
*** linux/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c	2025-01-18 12:32:03.561866339 -0500
--- ClockworkPi-linux/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c	2025-01-18 12:30:21.255127713 -0500
***************
*** 159,165 ****
  
  	rc = hwrm_req_replace(bp, req, fw_msg->msg, fw_msg->msg_len);
  	if (rc)
! 		goto drop_req;
  
  	hwrm_req_timeout(bp, req, fw_msg->timeout);
  	resp = hwrm_req_hold(bp, req);
--- 159,165 ----
  
  	rc = hwrm_req_replace(bp, req, fw_msg->msg, fw_msg->msg_len);
  	if (rc)
! 		return rc;
  
  	hwrm_req_timeout(bp, req, fw_msg->timeout);
  	resp = hwrm_req_hold(bp, req);
***************
*** 171,177 ****
  
  		memcpy(fw_msg->resp, resp, resp_len);
  	}
- drop_req:
  	hwrm_req_drop(bp, req);
  	return rc;
  }
--- 171,176 ----
diff -crB linux/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c ClockworkPi-linux/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
*** linux/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c	2025-01-18 12:32:03.613865739 -0500
--- ClockworkPi-linux/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c	2025-01-18 12:30:21.307127027 -0500
***************
*** 1799,1808 ****
  	struct adapter *adap = container_of(t, struct adapter, tids);
  	struct sk_buff *skb;
  
! 	if (tid_out_of_range(&adap->tids, tid)) {
! 		dev_err(adap->pdev_dev, "tid %d out of range\n", tid);
! 		return;
! 	}
  
  	if (t->tid_tab[tid - adap->tids.tid_base]) {
  		t->tid_tab[tid - adap->tids.tid_base] = NULL;
--- 1799,1805 ----
  	struct adapter *adap = container_of(t, struct adapter, tids);
  	struct sk_buff *skb;
  
! 	WARN_ON(tid_out_of_range(&adap->tids, tid));
  
  	if (t->tid_tab[tid - adap->tids.tid_base]) {
  		t->tid_tab[tid - adap->tids.tid_base] = NULL;
diff -crB linux/drivers/net/ethernet/google/gve/gve_main.c ClockworkPi-linux/drivers/net/ethernet/google/gve/gve_main.c
*** linux/drivers/net/ethernet/google/gve/gve_main.c	2025-01-18 12:32:03.693864816 -0500
--- ClockworkPi-linux/drivers/net/ethernet/google/gve/gve_main.c	2025-01-18 12:30:21.375126131 -0500
***************
*** 2009,2026 ****
  
  static void gve_set_netdev_xdp_features(struct gve_priv *priv)
  {
- 	xdp_features_t xdp_features;
- 
  	if (priv->queue_format == GVE_GQI_QPL_FORMAT) {
! 		xdp_features = NETDEV_XDP_ACT_BASIC;
! 		xdp_features |= NETDEV_XDP_ACT_REDIRECT;
! 		xdp_features |= NETDEV_XDP_ACT_NDO_XMIT;
! 		xdp_features |= NETDEV_XDP_ACT_XSK_ZEROCOPY;
  	} else {
! 		xdp_features = 0;
  	}
- 
- 	xdp_set_features_flag(priv->dev, xdp_features);
  }
  
  static int gve_init_priv(struct gve_priv *priv, bool skip_describe_device)
--- 2009,2022 ----
  
  static void gve_set_netdev_xdp_features(struct gve_priv *priv)
  {
  	if (priv->queue_format == GVE_GQI_QPL_FORMAT) {
! 		priv->dev->xdp_features = NETDEV_XDP_ACT_BASIC;
! 		priv->dev->xdp_features |= NETDEV_XDP_ACT_REDIRECT;
! 		priv->dev->xdp_features |= NETDEV_XDP_ACT_NDO_XMIT;
! 		priv->dev->xdp_features |= NETDEV_XDP_ACT_XSK_ZEROCOPY;
  	} else {
! 		priv->dev->xdp_features = 0;
  	}
  }
  
  static int gve_init_priv(struct gve_priv *priv, bool skip_describe_device)
diff -crB linux/drivers/net/ethernet/intel/ice/ice_ptp_consts.h ClockworkPi-linux/drivers/net/ethernet/intel/ice/ice_ptp_consts.h
*** linux/drivers/net/ethernet/intel/ice/ice_ptp_consts.h	2025-01-18 12:32:03.829863248 -0500
--- ClockworkPi-linux/drivers/net/ethernet/intel/ice/ice_ptp_consts.h	2025-01-18 12:30:21.471124866 -0500
***************
*** 359,367 ****
  		/* rx_desk_rsgb_par */
  		644531250, /* 644.53125 MHz Reed Solomon gearbox */
  		/* tx_desk_rsgb_pcs */
! 		390625000, /* 390.625 MHz Reed Solomon gearbox */
  		/* rx_desk_rsgb_pcs */
! 		390625000, /* 390.625 MHz Reed Solomon gearbox */
  		/* tx_fixed_delay */
  		1620,
  		/* pmd_adj_divisor */
--- 359,367 ----
  		/* rx_desk_rsgb_par */
  		644531250, /* 644.53125 MHz Reed Solomon gearbox */
  		/* tx_desk_rsgb_pcs */
! 		644531250, /* 644.53125 MHz Reed Solomon gearbox */
  		/* rx_desk_rsgb_pcs */
! 		644531250, /* 644.53125 MHz Reed Solomon gearbox */
  		/* tx_fixed_delay */
  		1620,
  		/* pmd_adj_divisor */
diff -crB linux/drivers/net/ethernet/intel/igc/igc_base.c ClockworkPi-linux/drivers/net/ethernet/intel/igc/igc_base.c
*** linux/drivers/net/ethernet/intel/igc/igc_base.c	2025-01-18 12:32:03.861862879 -0500
--- ClockworkPi-linux/drivers/net/ethernet/intel/igc/igc_base.c	2025-01-18 12:30:21.491124603 -0500
***************
*** 68,78 ****
  	u32 eecd = rd32(IGC_EECD);
  	u16 size;
  
! 	/* failed to read reg and got all F's */
! 	if (!(~eecd))
! 		return -ENXIO;
! 
! 	size = FIELD_GET(IGC_EECD_SIZE_EX_MASK, eecd);
  
  	/* Added to a constant, "size" becomes the left-shift value
  	 * for setting word_size.
--- 68,75 ----
  	u32 eecd = rd32(IGC_EECD);
  	u16 size;
  
! 	size = (u16)((eecd & IGC_EECD_SIZE_EX_MASK) >>
! 		     IGC_EECD_SIZE_EX_SHIFT);
  
  	/* Added to a constant, "size" becomes the left-shift value
  	 * for setting word_size.
***************
*** 165,171 ****
  	phy->reset_delay_us	= 100;
  
  	/* set lan id */
! 	hw->bus.func = FIELD_GET(IGC_STATUS_FUNC_MASK, rd32(IGC_STATUS));
  
  	/* Make sure the PHY is in a good state. Several people have reported
  	 * firmware leaving the PHY's page select register set to something
--- 162,169 ----
  	phy->reset_delay_us	= 100;
  
  	/* set lan id */
! 	hw->bus.func = (rd32(IGC_STATUS) & IGC_STATUS_FUNC_MASK) >>
! 			IGC_STATUS_FUNC_SHIFT;
  
  	/* Make sure the PHY is in a good state. Several people have reported
  	 * firmware leaving the PHY's page select register set to something
***************
*** 225,232 ****
  
  	/* NVM initialization */
  	ret_val = igc_init_nvm_params_base(hw);
- 	if (ret_val)
- 		goto out;
  	switch (hw->mac.type) {
  	case igc_i225:
  		ret_val = igc_init_nvm_params_i225(hw);
--- 223,228 ----
diff -crB linux/drivers/net/ethernet/intel/igc/igc_i225.c ClockworkPi-linux/drivers/net/ethernet/intel/igc/igc_i225.c
*** linux/drivers/net/ethernet/intel/igc/igc_i225.c	2025-01-18 12:32:03.865862833 -0500
--- ClockworkPi-linux/drivers/net/ethernet/intel/igc/igc_i225.c	2025-01-18 12:30:21.495124550 -0500
***************
*** 579,586 ****
  
  			/* Calculate tw_system (nsec). */
  			if (speed == SPEED_100) {
! 				tw_system = FIELD_GET(IGC_TW_SYSTEM_100_MASK,
! 						      rd32(IGC_EEE_SU)) * 500;
  			} else {
  				tw_system = (rd32(IGC_EEE_SU) &
  					     IGC_TW_SYSTEM_1000_MASK) * 500;
--- 579,587 ----
  
  			/* Calculate tw_system (nsec). */
  			if (speed == SPEED_100) {
! 				tw_system = ((rd32(IGC_EEE_SU) &
! 					     IGC_TW_SYSTEM_100_MASK) >>
! 					     IGC_TW_SYSTEM_100_SHIFT) * 500;
  			} else {
  				tw_system = (rd32(IGC_EEE_SU) &
  					     IGC_TW_SYSTEM_1000_MASK) * 500;
diff -crB linux/drivers/net/ethernet/intel/igc/igc_main.c ClockworkPi-linux/drivers/net/ethernet/intel/igc/igc_main.c
*** linux/drivers/net/ethernet/intel/igc/igc_main.c	2025-01-18 12:32:03.865862833 -0500
--- ClockworkPi-linux/drivers/net/ethernet/intel/igc/igc_main.c	2025-01-18 12:30:21.495124550 -0500
***************
*** 3708,3714 ****
  	}
  
  	if (rule->filter.match_flags & IGC_FILTER_FLAG_VLAN_TCI) {
! 		int prio = FIELD_GET(VLAN_PRIO_MASK, rule->filter.vlan_tci);
  
  		err = igc_add_vlan_prio_filter(adapter, prio, rule->action);
  		if (err)
--- 3708,3715 ----
  	}
  
  	if (rule->filter.match_flags & IGC_FILTER_FLAG_VLAN_TCI) {
! 		int prio = (rule->filter.vlan_tci & VLAN_PRIO_MASK) >>
! 			   VLAN_PRIO_SHIFT;
  
  		err = igc_add_vlan_prio_filter(adapter, prio, rule->action);
  		if (err)
***************
*** 3730,3736 ****
  		igc_del_etype_filter(adapter, rule->filter.etype);
  
  	if (rule->filter.match_flags & IGC_FILTER_FLAG_VLAN_TCI) {
! 		int prio = FIELD_GET(VLAN_PRIO_MASK, rule->filter.vlan_tci);
  
  		igc_del_vlan_prio_filter(adapter, prio);
  	}
--- 3731,3738 ----
  		igc_del_etype_filter(adapter, rule->filter.etype);
  
  	if (rule->filter.match_flags & IGC_FILTER_FLAG_VLAN_TCI) {
! 		int prio = (rule->filter.vlan_tci & VLAN_PRIO_MASK) >>
! 			   VLAN_PRIO_SHIFT;
  
  		igc_del_vlan_prio_filter(adapter, prio);
  	}
diff -crB linux/drivers/net/ethernet/intel/igc/igc_phy.c ClockworkPi-linux/drivers/net/ethernet/intel/igc/igc_phy.c
*** linux/drivers/net/ethernet/intel/igc/igc_phy.c	2025-01-18 12:32:03.869862787 -0500
--- ClockworkPi-linux/drivers/net/ethernet/intel/igc/igc_phy.c	2025-01-18 12:30:21.495124550 -0500
***************
*** 727,733 ****
   */
  s32 igc_write_phy_reg_gpy(struct igc_hw *hw, u32 offset, u16 data)
  {
! 	u8 dev_addr = FIELD_GET(GPY_MMD_MASK, offset);
  	s32 ret_val;
  
  	offset = offset & GPY_REG_MASK;
--- 727,733 ----
   */
  s32 igc_write_phy_reg_gpy(struct igc_hw *hw, u32 offset, u16 data)
  {
! 	u8 dev_addr = (offset & GPY_MMD_MASK) >> GPY_MMD_SHIFT;
  	s32 ret_val;
  
  	offset = offset & GPY_REG_MASK;
***************
*** 758,764 ****
   */
  s32 igc_read_phy_reg_gpy(struct igc_hw *hw, u32 offset, u16 *data)
  {
! 	u8 dev_addr = FIELD_GET(GPY_MMD_MASK, offset);
  	s32 ret_val;
  
  	offset = offset & GPY_REG_MASK;
--- 758,764 ----
   */
  s32 igc_read_phy_reg_gpy(struct igc_hw *hw, u32 offset, u16 *data)
  {
! 	u8 dev_addr = (offset & GPY_MMD_MASK) >> GPY_MMD_SHIFT;
  	s32 ret_val;
  
  	offset = offset & GPY_REG_MASK;
diff -crB linux/drivers/net/ethernet/mellanox/mlx5/core/cmd.c ClockworkPi-linux/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
*** linux/drivers/net/ethernet/mellanox/mlx5/core/cmd.c	2025-01-18 12:32:04.201858961 -0500
--- ClockworkPi-linux/drivers/net/ethernet/mellanox/mlx5/core/cmd.c	2025-01-18 12:30:21.567123601 -0500
***************
*** 1006,1012 ****
  				complete(&ent->done);
  			}
  			up(&cmd->vars.sem);
- 			complete(&ent->slotted);
  			return;
  		}
  	} else {
--- 1006,1011 ----
diff -crB linux/drivers/net/ethernet/stmicro/stmmac/dwmac-tegra.c ClockworkPi-linux/drivers/net/ethernet/stmicro/stmmac/dwmac-tegra.c
*** linux/drivers/net/ethernet/stmicro/stmmac/dwmac-tegra.c	2025-01-18 12:32:04.509855413 -0500
--- ClockworkPi-linux/drivers/net/ethernet/stmicro/stmmac/dwmac-tegra.c	2025-01-18 12:30:21.835120070 -0500
***************
*** 1,5 ****
  // SPDX-License-Identifier: GPL-2.0-only
- #include <linux/iommu.h>
  #include <linux/platform_device.h>
  #include <linux/of.h>
  #include <linux/module.h>
--- 1,4 ----
***************
*** 20,27 ****
  	struct reset_control *rst_mac;
  	struct reset_control *rst_pcs;
  
- 	u32 iommu_sid;
- 
  	void __iomem *hv;
  	void __iomem *regs;
  	void __iomem *xpcs;
--- 19,24 ----
***************
*** 53,58 ****
--- 50,56 ----
  #define MGBE_WRAP_COMMON_INTR_ENABLE	0x8704
  #define MAC_SBD_INTR			BIT(2)
  #define MGBE_WRAP_AXI_ASID0_CTRL	0x8400
+ #define MGBE_SID			0x6
  
  static int __maybe_unused tegra_mgbe_suspend(struct device *dev)
  {
***************
*** 86,92 ****
  	writel(MAC_SBD_INTR, mgbe->regs + MGBE_WRAP_COMMON_INTR_ENABLE);
  
  	/* Program SID */
! 	writel(mgbe->iommu_sid, mgbe->hv + MGBE_WRAP_AXI_ASID0_CTRL);
  
  	value = readl(mgbe->xpcs + XPCS_WRAP_UPHY_STATUS);
  	if ((value & XPCS_WRAP_UPHY_STATUS_TX_P_UP) == 0) {
--- 84,90 ----
  	writel(MAC_SBD_INTR, mgbe->regs + MGBE_WRAP_COMMON_INTR_ENABLE);
  
  	/* Program SID */
! 	writel(MGBE_SID, mgbe->hv + MGBE_WRAP_AXI_ASID0_CTRL);
  
  	value = readl(mgbe->xpcs + XPCS_WRAP_UPHY_STATUS);
  	if ((value & XPCS_WRAP_UPHY_STATUS_TX_P_UP) == 0) {
***************
*** 243,254 ****
  	if (IS_ERR(mgbe->xpcs))
  		return PTR_ERR(mgbe->xpcs);
  
- 	/* get controller's stream id from iommu property in device tree */
- 	if (!tegra_dev_iommu_get_stream_id(mgbe->dev, &mgbe->iommu_sid)) {
- 		dev_err(mgbe->dev, "failed to get iommu stream id\n");
- 		return -EINVAL;
- 	}
- 
  	res.addr = mgbe->regs;
  	res.irq = irq;
  
--- 241,246 ----
***************
*** 354,360 ****
  	writel(MAC_SBD_INTR, mgbe->regs + MGBE_WRAP_COMMON_INTR_ENABLE);
  
  	/* Program SID */
! 	writel(mgbe->iommu_sid, mgbe->hv + MGBE_WRAP_AXI_ASID0_CTRL);
  
  	plat->flags |= STMMAC_FLAG_SERDES_UP_AFTER_PHY_LINKUP;
  
--- 346,352 ----
  	writel(MAC_SBD_INTR, mgbe->regs + MGBE_WRAP_COMMON_INTR_ENABLE);
  
  	/* Program SID */
! 	writel(MGBE_SID, mgbe->hv + MGBE_WRAP_AXI_ASID0_CTRL);
  
  	plat->flags |= STMMAC_FLAG_SERDES_UP_AFTER_PHY_LINKUP;
  
diff -crB linux/drivers/net/ethernet/wangxun/libwx/wx_hw.c ClockworkPi-linux/drivers/net/ethernet/wangxun/libwx/wx_hw.c
*** linux/drivers/net/ethernet/wangxun/libwx/wx_hw.c	2025-01-18 12:32:04.553854907 -0500
--- ClockworkPi-linux/drivers/net/ethernet/wangxun/libwx/wx_hw.c	2025-01-18 12:30:21.875119543 -0500
***************
*** 242,266 ****
  	status = read_poll_timeout(rd32, hicr, hicr & WX_MNG_MBOX_CTL_FWRDY, 1000,
  				   timeout * 1000, false, wx, WX_MNG_MBOX_CTL);
  
- 	buf[0] = rd32(wx, WX_MNG_MBOX);
- 	if ((buf[0] & 0xff0000) >> 16 == 0x80) {
- 		wx_err(wx, "Unknown FW command: 0x%x\n", buffer[0] & 0xff);
- 		status = -EINVAL;
- 		goto rel_out;
- 	}
- 
  	/* Check command completion */
  	if (status) {
! 		wx_err(wx, "Command has failed with no status valid.\n");
  		wx_dbg(wx, "write value:\n");
  		for (i = 0; i < dword_len; i++)
  			wx_dbg(wx, "%x ", buffer[i]);
  		wx_dbg(wx, "read value:\n");
  		for (i = 0; i < dword_len; i++)
  			wx_dbg(wx, "%x ", buf[i]);
- 		wx_dbg(wx, "\ncheck: %x %x\n", buffer[0] & 0xff, ~buf[0] >> 24);
- 
- 		goto rel_out;
  	}
  
  	if (!return_data)
--- 242,268 ----
  	status = read_poll_timeout(rd32, hicr, hicr & WX_MNG_MBOX_CTL_FWRDY, 1000,
  				   timeout * 1000, false, wx, WX_MNG_MBOX_CTL);
  
  	/* Check command completion */
  	if (status) {
! 		wx_dbg(wx, "Command has failed with no status valid.\n");
! 
! 		buf[0] = rd32(wx, WX_MNG_MBOX);
! 		if ((buffer[0] & 0xff) != (~buf[0] >> 24)) {
! 			status = -EINVAL;
! 			goto rel_out;
! 		}
! 		if ((buf[0] & 0xff0000) >> 16 == 0x80) {
! 			wx_dbg(wx, "It's unknown cmd.\n");
! 			status = -EINVAL;
! 			goto rel_out;
! 		}
! 
  		wx_dbg(wx, "write value:\n");
  		for (i = 0; i < dword_len; i++)
  			wx_dbg(wx, "%x ", buffer[i]);
  		wx_dbg(wx, "read value:\n");
  		for (i = 0; i < dword_len; i++)
  			wx_dbg(wx, "%x ", buf[i]);
  	}
  
  	if (!return_data)
diff -crB linux/drivers/net/ieee802154/ca8210.c ClockworkPi-linux/drivers/net/ieee802154/ca8210.c
*** linux/drivers/net/ieee802154/ca8210.c	2025-01-18 12:32:04.581854584 -0500
--- ClockworkPi-linux/drivers/net/ieee802154/ca8210.c	2025-01-18 12:30:21.903119174 -0500
***************
*** 3078,3088 ****
  	spi_set_drvdata(priv->spi, priv);
  	if (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS)) {
  		cascoda_api_upstream = ca8210_test_int_driver_write;
! 		ret = ca8210_test_interface_init(priv);
! 		if (ret) {
! 			dev_crit(&spi_device->dev, "ca8210_test_interface_init failed\n");
! 			goto error;
! 		}
  	} else {
  		cascoda_api_upstream = NULL;
  	}
--- 3078,3084 ----
  	spi_set_drvdata(priv->spi, priv);
  	if (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS)) {
  		cascoda_api_upstream = ca8210_test_int_driver_write;
! 		ca8210_test_interface_init(priv);
  	} else {
  		cascoda_api_upstream = NULL;
  	}
diff -crB linux/drivers/platform/x86/amd/pmc/pmc.c ClockworkPi-linux/drivers/platform/x86/amd/pmc/pmc.c
*** linux/drivers/platform/x86/amd/pmc/pmc.c	2025-01-18 12:32:05.645842339 -0500
--- ClockworkPi-linux/drivers/platform/x86/amd/pmc/pmc.c	2025-01-18 12:30:22.903106012 -0500
***************
*** 878,887 ****
  {
  	struct amd_pmc_dev *pdev = dev_get_drvdata(dev);
  
- 	/*
- 	 * Must be called only from the same set of dev_pm_ops handlers
- 	 * as i8042_pm_suspend() is called: currently just from .suspend.
- 	 */
  	if (pdev->disable_8042_wakeup && !disable_workarounds) {
  		int rc = amd_pmc_wa_irq1(pdev);
  
--- 878,883 ----
***************
*** 894,902 ****
  	return 0;
  }
  
! static const struct dev_pm_ops amd_pmc_pm = {
! 	.suspend = amd_pmc_suspend_handler,
! };
  
  static const struct pci_device_id pmc_pci_ids[] = {
  	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_PS) },
--- 890,896 ----
  	return 0;
  }
  
! static DEFINE_SIMPLE_DEV_PM_OPS(amd_pmc_pm, amd_pmc_suspend_handler, NULL);
  
  static const struct pci_device_id pmc_pci_ids[] = {
  	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_PS) },
diff -crB linux/drivers/pmdomain/imx/gpcv2.c ClockworkPi-linux/drivers/pmdomain/imx/gpcv2.c
*** linux/drivers/pmdomain/imx/gpcv2.c	2025-01-18 12:32:05.689841832 -0500
--- ClockworkPi-linux/drivers/pmdomain/imx/gpcv2.c	2025-01-18 12:30:22.943105486 -0500
***************
*** 1449,1460 ****
  		.max_register   = SZ_4K,
  	};
  	struct device *dev = &pdev->dev;
! 	struct device_node *pgc_np __free(device_node) =
! 		of_get_child_by_name(dev->of_node, "pgc");
  	struct regmap *regmap;
  	void __iomem *base;
  	int ret;
  
  	if (!pgc_np) {
  		dev_err(dev, "No power domains specified in DT\n");
  		return -EINVAL;
--- 1449,1460 ----
  		.max_register   = SZ_4K,
  	};
  	struct device *dev = &pdev->dev;
! 	struct device_node *pgc_np, *np;
  	struct regmap *regmap;
  	void __iomem *base;
  	int ret;
  
+ 	pgc_np = of_get_child_by_name(dev->of_node, "pgc");
  	if (!pgc_np) {
  		dev_err(dev, "No power domains specified in DT\n");
  		return -EINVAL;
***************
*** 1471,1477 ****
  		return ret;
  	}
  
! 	for_each_child_of_node_scoped(pgc_np, np) {
  		struct platform_device *pd_pdev;
  		struct imx_pgc_domain *domain;
  		u32 domain_index;
--- 1471,1477 ----
  		return ret;
  	}
  
! 	for_each_child_of_node(pgc_np, np) {
  		struct platform_device *pd_pdev;
  		struct imx_pgc_domain *domain;
  		u32 domain_index;
***************
*** 1482,1487 ****
--- 1482,1488 ----
  		ret = of_property_read_u32(np, "reg", &domain_index);
  		if (ret) {
  			dev_err(dev, "Failed to read 'reg' property\n");
+ 			of_node_put(np);
  			return ret;
  		}
  
***************
*** 1496,1501 ****
--- 1497,1503 ----
  						domain_index);
  		if (!pd_pdev) {
  			dev_err(dev, "Failed to allocate platform device\n");
+ 			of_node_put(np);
  			return -ENOMEM;
  		}
  
***************
*** 1504,1509 ****
--- 1506,1512 ----
  					       sizeof(domain_data->domains[domain_index]));
  		if (ret) {
  			platform_device_put(pd_pdev);
+ 			of_node_put(np);
  			return ret;
  		}
  
***************
*** 1520,1525 ****
--- 1523,1529 ----
  		ret = platform_device_add(pd_pdev);
  		if (ret) {
  			platform_device_put(pd_pdev);
+ 			of_node_put(np);
  			return ret;
  		}
  	}
diff -crB linux/drivers/power/supply/axp20x_ac_power.c ClockworkPi-linux/drivers/power/supply/axp20x_ac_power.c
*** linux/drivers/power/supply/axp20x_ac_power.c	2025-01-18 12:32:05.709841602 -0500
--- ClockworkPi-linux/drivers/power/supply/axp20x_ac_power.c	2025-01-18 12:30:22.963105223 -0500
***************
*** 52,57 ****
--- 52,60 ----
  {
  	struct axp20x_ac_power *power = devid;
  
+ 	regmap_update_bits(power->regmap, AXP20X_VBUS_IPSOUT_MGMT, 0x03, 0x00);
+ 	regmap_update_bits(power->regmap, AXP20X_VBUS_IPSOUT_MGMT, 0x03, 0x03);
+ 
  	power_supply_changed(power->supply);
  
  	return IRQ_HANDLED;
diff -crB linux/drivers/power/supply/axp20x_battery.c ClockworkPi-linux/drivers/power/supply/axp20x_battery.c
*** linux/drivers/power/supply/axp20x_battery.c	2025-01-18 12:32:05.709841602 -0500
--- ClockworkPi-linux/drivers/power/supply/axp20x_battery.c	2025-01-18 12:30:22.963105223 -0500
***************
*** 55,60 ****
--- 55,64 ----
  
  #define AXP20X_V_OFF_MASK		GENMASK(2, 0)
  
+ #define AXP228_FULL_CAPACITY_CALIBRATE_EN BIT(5)
+ #define AXP228_CAPACITY_CALIBRATE BIT(4)
+ #define AXP228_CALIBRATE_MASK (BIT(4) | BIT(5))
+ 
  struct axp20x_batt_ps;
  
  struct axp_data {
***************
*** 74,79 ****
--- 78,86 ----
  	struct iio_channel *batt_v;
  	/* Maximum constant charge current */
  	unsigned int max_ccc;
+   int energy_full_design;
+   int current_now;
+   int voltage_now;
  	const struct axp_data	*data;
  };
  
***************
*** 275,280 ****
--- 282,288 ----
  
  		/* IIO framework gives mA but Power Supply framework gives uA */
  		val->intval *= 1000;
+     axp20x_batt->current_now = val->intval;
  		break;
  
  	case POWER_SUPPLY_PROP_CAPACITY:
***************
*** 323,330 ****
--- 331,390 ----
  
  		/* IIO framework gives mV but Power Supply framework gives uV */
  		val->intval *= 1000;
+     axp20x_batt->current_now = val->intval;
  		break;
  
+ 	case POWER_SUPPLY_PROP_ENERGY_FULL:
+ 	case POWER_SUPPLY_PROP_ENERGY_NOW:
+   case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+ 		/* When no battery is present, return 0 */
+ 		ret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_OP_MODE,
+ 				  &reg);
+ 		if (ret)
+ 			return ret;
+ 
+ 		if (!(reg & AXP20X_PWR_OP_BATT_PRESENT)) {
+ 			val->intval = 0;
+ 			return 0;
+ 		}
+ 
+ 		if(psp == POWER_SUPPLY_PROP_ENERGY_FULL) {
+       // TODO
+ 			val->intval = axp20x_batt->energy_full_design;
+ 			return 0;
+ 		}
+ 
+     if(psp == POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN) {
+       val->intval = axp20x_batt->energy_full_design;
+       return 0;
+     }
+ 
+ 		ret = regmap_read(axp20x_batt->regmap, AXP20X_FG_RES, &reg);
+ 		if (ret)
+ 			return ret;
+ 
+ 		if (axp20x_batt->data->has_fg_valid && !(reg & AXP22X_FG_VALID))
+ 			return -EINVAL;
+ 
+ 		val1 = reg & AXP209_FG_PERCENT;
+     val1 = max(min(val1, 100), 0);
+ 		val->intval = (val1 * ((long long int)axp20x_batt->energy_full_design)) / 100;
+ 		break;
+ 
+   case POWER_SUPPLY_PROP_CALIBRATE:
+     // report both calibrate enable flag and calibration status
+ 		ret = regmap_read(axp20x_batt->regmap, AXP20X_CC_CTRL, &reg);
+     if (ret)
+       return ret;
+     val1 = reg & AXP228_CALIBRATE_MASK;
+     val->intval = val1;
+     break;
+ 
+   case POWER_SUPPLY_PROP_POWER_NOW:
+     val->intval = (axp20x_batt->voltage_now / 10000) * axp20x_batt->current_now;
+     val->intval = val->intval / 100; // uW
+     break;
+ 
  	default:
  		return -EINVAL;
  	}
***************
*** 453,458 ****
--- 513,519 ----
  				   const union power_supply_propval *val)
  {
  	struct axp20x_batt_ps *axp20x_batt = power_supply_get_drvdata(psy);
+   int val1;
  
  	switch (psp) {
  	case POWER_SUPPLY_PROP_VOLTAGE_MIN:
***************
*** 467,472 ****
--- 528,543 ----
  	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
  		return axp20x_set_max_constant_charge_current(axp20x_batt,
  							      val->intval);
+ 
+   case POWER_SUPPLY_PROP_CALIBRATE:
+     if (val->intval) {
+       // enable calibrate
+       val1 = AXP228_FULL_CAPACITY_CALIBRATE_EN | AXP228_CAPACITY_CALIBRATE;
+     } else {
+       // disable calibrate
+       val1 = 0;
+     }
+     return regmap_update_bits(axp20x_batt->regmap, AXP20X_CC_CTRL, AXP228_CALIBRATE_MASK, val1);
  	case POWER_SUPPLY_PROP_STATUS:
  		switch (val->intval) {
  		case POWER_SUPPLY_STATUS_CHARGING:
***************
*** 496,501 ****
--- 567,577 ----
  	POWER_SUPPLY_PROP_VOLTAGE_MAX,
  	POWER_SUPPLY_PROP_VOLTAGE_MIN,
  	POWER_SUPPLY_PROP_CAPACITY,
+ 	POWER_SUPPLY_PROP_ENERGY_FULL,
+ 	POWER_SUPPLY_PROP_ENERGY_NOW,
+   POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+ 	POWER_SUPPLY_PROP_CALIBRATE,
+   POWER_SUPPLY_PROP_POWER_NOW,
  };
  
  static int axp20x_battery_prop_writeable(struct power_supply *psy,
***************
*** 505,511 ****
  	       psp == POWER_SUPPLY_PROP_VOLTAGE_MIN ||
  	       psp == POWER_SUPPLY_PROP_VOLTAGE_MAX ||
  	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT ||
! 	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX;
  }
  
  static const struct power_supply_desc axp20x_batt_ps_desc = {
--- 581,588 ----
  	       psp == POWER_SUPPLY_PROP_VOLTAGE_MIN ||
  	       psp == POWER_SUPPLY_PROP_VOLTAGE_MAX ||
  	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT ||
! 	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX ||
!          psp == POWER_SUPPLY_PROP_CALIBRATE;
  }
  
  static const struct power_supply_desc axp20x_batt_ps_desc = {
***************
*** 615,620 ****
--- 692,698 ----
  	if (!power_supply_get_battery_info(axp20x_batt->batt, &info)) {
  		int vmin = info->voltage_min_design_uv;
  		int ccc = info->constant_charge_current_max_ua;
+     int cfd = info->charge_full_design_uah;
  
  		if (vmin > 0 && axp20x_set_voltage_min_design(axp20x_batt,
  							      vmin))
***************
*** 632,638 ****
  			axp20x_batt->max_ccc = ccc;
  			axp20x_set_constant_charge_current(axp20x_batt, ccc);
  		}
! 	}
  
  	/*
  	 * Update max CCC to a valid value if battery info is present or set it
--- 710,731 ----
  			axp20x_batt->max_ccc = ccc;
  			axp20x_set_constant_charge_current(axp20x_batt, ccc);
  		}
! 
! 
!     axp20x_batt->energy_full_design = info->energy_full_design_uwh;
!     // tell pmic about our battery
!     if (cfd) {
!       // [14:8], [7:0], cfd = Value * 1.456mAh
!       cfd = cfd / 1456;
!       regmap_update_bits(axp20x_batt->regmap, AXP288_FG_DES_CAP0_REG, 0xff, cfd & 0xff);
!       regmap_update_bits(axp20x_batt->regmap, AXP288_FG_DES_CAP1_REG, 0xff, BIT(7) | ((cfd >> 8) & 0xff));
!     } else {
!       dev_warn(axp20x_batt->dev, "charge full design is not set");
!     }
! 	} else {
!     axp20x_batt->energy_full_design = 8000000;
!     dev_warn(axp20x_batt->dev, "energy full design is not set, default to %d\n", axp20x_batt->energy_full_design);
!   }
  
  	/*
  	 * Update max CCC to a valid value if battery info is present or set it
***************
*** 641,646 ****
--- 734,745 ----
  	axp20x_get_constant_charge_current(axp20x_batt,
  					   &axp20x_batt->max_ccc);
  
+ 	regmap_update_bits(axp20x_batt->regmap, AXP20X_VBUS_IPSOUT_MGMT, 0x03, 0x03);
+ 	regmap_update_bits(axp20x_batt->regmap, AXP20X_OFF_CTRL, 0x08, 0x08);
+ 	regmap_update_bits(axp20x_batt->regmap, AXP20X_CHRG_CTRL2, 0x30, 0x20);
+ 	regmap_update_bits(axp20x_batt->regmap, AXP20X_PEK_KEY, 0x0f, 0x0b);
+ 	regmap_update_bits(axp20x_batt->regmap, AXP20X_GPIO0_CTRL, 0x07, 0x00);
+ 
  	return 0;
  }
  
diff -crB linux/drivers/staging/iio/frequency/ad9832.c ClockworkPi-linux/drivers/staging/iio/frequency/ad9832.c
*** linux/drivers/staging/iio/frequency/ad9832.c	2025-01-18 12:32:06.485832683 -0500
--- ClockworkPi-linux/drivers/staging/iio/frequency/ad9832.c	2025-01-18 12:30:23.527097810 -0500
***************
*** 158,164 ****
  static int ad9832_write_phase(struct ad9832_state *st,
  			      unsigned long addr, unsigned long phase)
  {
! 	if (phase >= BIT(AD9832_PHASE_BITS))
  		return -EINVAL;
  
  	st->phase_data[0] = cpu_to_be16((AD9832_CMD_PHA8BITSW << CMD_SHIFT) |
--- 158,164 ----
  static int ad9832_write_phase(struct ad9832_state *st,
  			      unsigned long addr, unsigned long phase)
  {
! 	if (phase > BIT(AD9832_PHASE_BITS))
  		return -EINVAL;
  
  	st->phase_data[0] = cpu_to_be16((AD9832_CMD_PHA8BITSW << CMD_SHIFT) |
diff -crB linux/drivers/staging/iio/frequency/ad9834.c ClockworkPi-linux/drivers/staging/iio/frequency/ad9834.c
*** linux/drivers/staging/iio/frequency/ad9834.c	2025-01-18 12:32:06.485832683 -0500
--- ClockworkPi-linux/drivers/staging/iio/frequency/ad9834.c	2025-01-18 12:30:23.527097810 -0500
***************
*** 131,137 ****
  static int ad9834_write_phase(struct ad9834_state *st,
  			      unsigned long addr, unsigned long phase)
  {
! 	if (phase >= BIT(AD9834_PHASE_BITS))
  		return -EINVAL;
  	st->data = cpu_to_be16(addr | phase);
  
--- 131,137 ----
  static int ad9834_write_phase(struct ad9834_state *st,
  			      unsigned long addr, unsigned long phase)
  {
! 	if (phase > BIT(AD9834_PHASE_BITS))
  		return -EINVAL;
  	st->data = cpu_to_be16(addr | phase);
  
diff -crB linux/drivers/staging/vc04_services/bcm2835-audio/bcm2835.c ClockworkPi-linux/drivers/staging/vc04_services/bcm2835-audio/bcm2835.c
*** linux/drivers/staging/vc04_services/bcm2835-audio/bcm2835.c	2025-01-18 12:32:06.693830293 -0500
--- ClockworkPi-linux/drivers/staging/vc04_services/bcm2835-audio/bcm2835.c	2025-01-18 12:30:23.759094761 -0500
***************
*** 10,16 ****
  #include "bcm2835.h"
  #include <soc/bcm2835/raspberrypi-firmware.h>
  
! static bool enable_hdmi, enable_hdmi0, enable_hdmi1;
  static bool enable_headphones = true;
  static int num_channels = MAX_SUBSTREAMS;
  
--- 10,16 ----
  #include "bcm2835.h"
  #include <soc/bcm2835/raspberrypi-firmware.h>
  
! static bool enable_hdmi = true, enable_hdmi0, enable_hdmi1;
  static bool enable_headphones = true;
  static int num_channels = MAX_SUBSTREAMS;
  
diff -crB linux/drivers/thermal/thermal_of.c ClockworkPi-linux/drivers/thermal/thermal_of.c
*** linux/drivers/thermal/thermal_of.c	2025-01-18 12:32:06.773829374 -0500
--- ClockworkPi-linux/drivers/thermal/thermal_of.c	2025-01-18 12:30:23.859093447 -0500
***************
*** 203,209 ****
  				goto out;
  			}
  
- 			of_node_put(sensor_specs.np);
  			if ((sensor == sensor_specs.np) && id == (sensor_specs.args_count ?
  								  sensor_specs.args[0] : 0)) {
  				pr_debug("sensor %pOFn id=%d belongs to %pOFn\n", sensor, id, child);
--- 203,208 ----
diff -crB linux/drivers/tty/serial/8250/8250_core.c ClockworkPi-linux/drivers/tty/serial/8250/8250_core.c
*** linux/drivers/tty/serial/8250/8250_core.c	2025-01-18 12:32:06.825828777 -0500
--- ClockworkPi-linux/drivers/tty/serial/8250/8250_core.c	2025-01-18 12:30:23.895092974 -0500
***************
*** 1146,1154 ****
  			uart->dl_write = up->dl_write;
  
  		if (uart->port.type != PORT_8250_CIR) {
- 			if (uart_console_registered(&uart->port))
- 				pm_runtime_get_sync(uart->port.dev);
- 
  			if (serial8250_isa_config != NULL)
  				serial8250_isa_config(0, &uart->port,
  						&uart->capabilities);
--- 1146,1151 ----
diff -crB linux/drivers/ufs/core/ufshcd.c ClockworkPi-linux/drivers/ufs/core/ufshcd.c
*** linux/drivers/ufs/core/ufshcd.c	2025-01-18 12:32:06.913827766 -0500
--- ClockworkPi-linux/drivers/ufs/core/ufshcd.c	2025-01-18 12:30:23.971091975 -0500
***************
*** 8795,8800 ****
--- 8795,8801 ----
  		ufshcd_device_reset(hba);
  		ufs_put_device_desc(hba);
  		ufshcd_hba_stop(hba);
+ 		ufshcd_vops_reinit_notify(hba);
  		ret = ufshcd_hba_enable(hba);
  		if (ret) {
  			dev_err(hba->dev, "Host controller enable failed\n");
diff -crB linux/drivers/ufs/core/ufshcd-priv.h ClockworkPi-linux/drivers/ufs/core/ufshcd-priv.h
*** linux/drivers/ufs/core/ufshcd-priv.h	2025-01-18 12:32:06.913827766 -0500
--- ClockworkPi-linux/drivers/ufs/core/ufshcd-priv.h	2025-01-18 12:30:23.967092027 -0500
***************
*** 242,247 ****
--- 242,253 ----
  		hba->vops->config_scaling_param(hba, p, data);
  }
  
+ static inline void ufshcd_vops_reinit_notify(struct ufs_hba *hba)
+ {
+ 	if (hba->vops && hba->vops->reinit_notify)
+ 		hba->vops->reinit_notify(hba);
+ }
+ 
  static inline int ufshcd_vops_mcq_config_resource(struct ufs_hba *hba)
  {
  	if (hba->vops && hba->vops->mcq_config_resource)
diff -crB linux/drivers/ufs/host/ufs-qcom.c ClockworkPi-linux/drivers/ufs/host/ufs-qcom.c
*** linux/drivers/ufs/host/ufs-qcom.c	2025-01-18 12:32:06.917827720 -0500
--- ClockworkPi-linux/drivers/ufs/host/ufs-qcom.c	2025-01-18 12:30:23.975091922 -0500
***************
*** 455,465 ****
  		dev_warn(hba->dev, "%s: host reset returned %d\n",
  				  __func__, ret);
  
- 	if (phy->power_count) {
- 		phy_power_off(phy);
- 		phy_exit(phy);
- 	}
- 
  	/* phy initialization - calibrate the phy */
  	ret = phy_init(phy);
  	if (ret) {
--- 455,460 ----
***************
*** 1643,1648 ****
--- 1638,1650 ----
  }
  #endif
  
+ static void ufs_qcom_reinit_notify(struct ufs_hba *hba)
+ {
+ 	struct ufs_qcom_host *host = ufshcd_get_variant(hba);
+ 
+ 	phy_power_off(host->generic_phy);
+ }
+ 
  /* Resources */
  static const struct ufshcd_res_info ufs_res_info[RES_MAX] = {
  	{.name = "ufs_mem",},
***************
*** 1885,1890 ****
--- 1887,1893 ----
  	.device_reset		= ufs_qcom_device_reset,
  	.config_scaling_param = ufs_qcom_config_scaling_param,
  	.program_key		= ufs_qcom_ice_program_key,
+ 	.reinit_notify		= ufs_qcom_reinit_notify,
  	.mcq_config_resource	= ufs_qcom_mcq_config_resource,
  	.get_hba_mac		= ufs_qcom_get_hba_mac,
  	.op_runtime_config	= ufs_qcom_op_runtime_config,
diff -crB linux/drivers/usb/chipidea/ci_hdrc_imx.c ClockworkPi-linux/drivers/usb/chipidea/ci_hdrc_imx.c
*** linux/drivers/usb/chipidea/ci_hdrc_imx.c	2025-01-18 12:32:06.933827536 -0500
--- ClockworkPi-linux/drivers/usb/chipidea/ci_hdrc_imx.c	2025-01-18 12:30:23.999091607 -0500
***************
*** 362,390 ****
  		data->pinctrl = devm_pinctrl_get(dev);
  		if (PTR_ERR(data->pinctrl) == -ENODEV)
  			data->pinctrl = NULL;
! 		else if (IS_ERR(data->pinctrl)) {
! 			ret = dev_err_probe(dev, PTR_ERR(data->pinctrl),
  					     "pinctrl get failed\n");
- 			goto err_put;
- 		}
  
  		data->hsic_pad_regulator =
  				devm_regulator_get_optional(dev, "hsic");
  		if (PTR_ERR(data->hsic_pad_regulator) == -ENODEV) {
  			/* no pad regulator is needed */
  			data->hsic_pad_regulator = NULL;
! 		} else if (IS_ERR(data->hsic_pad_regulator)) {
! 			ret = dev_err_probe(dev, PTR_ERR(data->hsic_pad_regulator),
  					     "Get HSIC pad regulator error\n");
- 			goto err_put;
- 		}
  
  		if (data->hsic_pad_regulator) {
  			ret = regulator_enable(data->hsic_pad_regulator);
  			if (ret) {
  				dev_err(dev,
  					"Failed to enable HSIC pad regulator\n");
! 				goto err_put;
  			}
  		}
  	}
--- 362,386 ----
  		data->pinctrl = devm_pinctrl_get(dev);
  		if (PTR_ERR(data->pinctrl) == -ENODEV)
  			data->pinctrl = NULL;
! 		else if (IS_ERR(data->pinctrl))
! 			return dev_err_probe(dev, PTR_ERR(data->pinctrl),
  					     "pinctrl get failed\n");
  
  		data->hsic_pad_regulator =
  				devm_regulator_get_optional(dev, "hsic");
  		if (PTR_ERR(data->hsic_pad_regulator) == -ENODEV) {
  			/* no pad regulator is needed */
  			data->hsic_pad_regulator = NULL;
! 		} else if (IS_ERR(data->hsic_pad_regulator))
! 			return dev_err_probe(dev, PTR_ERR(data->hsic_pad_regulator),
  					     "Get HSIC pad regulator error\n");
  
  		if (data->hsic_pad_regulator) {
  			ret = regulator_enable(data->hsic_pad_regulator);
  			if (ret) {
  				dev_err(dev,
  					"Failed to enable HSIC pad regulator\n");
! 				return ret;
  			}
  		}
  	}
***************
*** 398,411 ****
  			dev_err(dev,
  				"pinctrl_hsic_idle lookup failed, err=%ld\n",
  					PTR_ERR(pinctrl_hsic_idle));
! 			ret = PTR_ERR(pinctrl_hsic_idle);
! 			goto err_put;
  		}
  
  		ret = pinctrl_select_state(data->pinctrl, pinctrl_hsic_idle);
  		if (ret) {
  			dev_err(dev, "hsic_idle select failed, err=%d\n", ret);
! 			goto err_put;
  		}
  
  		data->pinctrl_hsic_active = pinctrl_lookup_state(data->pinctrl,
--- 394,406 ----
  			dev_err(dev,
  				"pinctrl_hsic_idle lookup failed, err=%ld\n",
  					PTR_ERR(pinctrl_hsic_idle));
! 			return PTR_ERR(pinctrl_hsic_idle);
  		}
  
  		ret = pinctrl_select_state(data->pinctrl, pinctrl_hsic_idle);
  		if (ret) {
  			dev_err(dev, "hsic_idle select failed, err=%d\n", ret);
! 			return ret;
  		}
  
  		data->pinctrl_hsic_active = pinctrl_lookup_state(data->pinctrl,
***************
*** 414,421 ****
  			dev_err(dev,
  				"pinctrl_hsic_active lookup failed, err=%ld\n",
  					PTR_ERR(data->pinctrl_hsic_active));
! 			ret = PTR_ERR(data->pinctrl_hsic_active);
! 			goto err_put;
  		}
  	}
  
--- 409,415 ----
  			dev_err(dev,
  				"pinctrl_hsic_active lookup failed, err=%ld\n",
  					PTR_ERR(data->pinctrl_hsic_active));
! 			return PTR_ERR(data->pinctrl_hsic_active);
  		}
  	}
  
***************
*** 519,526 ****
  	if (pdata.flags & CI_HDRC_PMQOS)
  		cpu_latency_qos_remove_request(&data->pm_qos_req);
  	data->ci_pdev = NULL;
- err_put:
- 	put_device(data->usbmisc_data->dev);
  	return ret;
  }
  
--- 513,518 ----
***************
*** 544,550 ****
  		if (data->hsic_pad_regulator)
  			regulator_disable(data->hsic_pad_regulator);
  	}
- 	put_device(data->usbmisc_data->dev);
  }
  
  static void ci_hdrc_imx_shutdown(struct platform_device *pdev)
--- 536,541 ----
diff -crB linux/drivers/usb/class/usblp.c ClockworkPi-linux/drivers/usb/class/usblp.c
*** linux/drivers/usb/class/usblp.c	2025-01-18 12:32:06.937827490 -0500
--- ClockworkPi-linux/drivers/usb/class/usblp.c	2025-01-18 12:30:24.007091502 -0500
***************
*** 1337,1348 ****
  	if (protocol < USBLP_FIRST_PROTOCOL || protocol > USBLP_LAST_PROTOCOL)
  		return -EINVAL;
  
- 	alts = usblp->protocol[protocol].alt_setting;
- 	if (alts < 0)
- 		return -EINVAL;
- 
  	/* Don't unnecessarily set the interface if there's a single alt. */
  	if (usblp->intf->num_altsetting > 1) {
  		r = usb_set_interface(usblp->dev, usblp->ifnum, alts);
  		if (r < 0) {
  			printk(KERN_ERR "usblp: can't set desired altsetting %d on interface %d\n",
--- 1337,1347 ----
  	if (protocol < USBLP_FIRST_PROTOCOL || protocol > USBLP_LAST_PROTOCOL)
  		return -EINVAL;
  
  	/* Don't unnecessarily set the interface if there's a single alt. */
  	if (usblp->intf->num_altsetting > 1) {
+ 		alts = usblp->protocol[protocol].alt_setting;
+ 		if (alts < 0)
+ 			return -EINVAL;
  		r = usb_set_interface(usblp->dev, usblp->ifnum, alts);
  		if (r < 0) {
  			printk(KERN_ERR "usblp: can't set desired altsetting %d on interface %d\n",
diff -crB linux/drivers/usb/core/hub.c ClockworkPi-linux/drivers/usb/core/hub.c
*** linux/drivers/usb/core/hub.c	2025-01-18 12:32:06.945827398 -0500
--- ClockworkPi-linux/drivers/usb/core/hub.c	2025-01-18 12:30:24.019091344 -0500
***************
*** 2633,2645 ****
  		err = sysfs_create_link(&udev->dev.kobj,
  				&port_dev->dev.kobj, "port");
  		if (err)
! 			goto out_del_dev;
  
  		err = sysfs_create_link(&port_dev->dev.kobj,
  				&udev->dev.kobj, "device");
  		if (err) {
  			sysfs_remove_link(&udev->dev.kobj, "port");
! 			goto out_del_dev;
  		}
  
  		if (!test_and_set_bit(port1, hub->child_usage_bits))
--- 2633,2645 ----
  		err = sysfs_create_link(&udev->dev.kobj,
  				&port_dev->dev.kobj, "port");
  		if (err)
! 			goto fail;
  
  		err = sysfs_create_link(&port_dev->dev.kobj,
  				&udev->dev.kobj, "device");
  		if (err) {
  			sysfs_remove_link(&udev->dev.kobj, "port");
! 			goto fail;
  		}
  
  		if (!test_and_set_bit(port1, hub->child_usage_bits))
***************
*** 2651,2658 ****
  	pm_runtime_put_sync_autosuspend(&udev->dev);
  	return err;
  
- out_del_dev:
- 	device_del(&udev->dev);
  fail:
  	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
  	pm_runtime_disable(&udev->dev);
--- 2651,2656 ----
diff -crB linux/drivers/usb/core/port.c ClockworkPi-linux/drivers/usb/core/port.c
*** linux/drivers/usb/core/port.c	2025-01-18 12:32:06.945827398 -0500
--- ClockworkPi-linux/drivers/usb/core/port.c	2025-01-18 12:30:24.023091292 -0500
***************
*** 451,461 ****
  static void usb_port_shutdown(struct device *dev)
  {
  	struct usb_port *port_dev = to_usb_port(dev);
- 	struct usb_device *udev = port_dev->child;
  
! 	if (udev && !udev->port_is_suspended) {
! 		usb_disable_usb2_hardware_lpm(udev);
! 		usb_unlocked_disable_lpm(udev);
  	}
  }
  
--- 451,460 ----
  static void usb_port_shutdown(struct device *dev)
  {
  	struct usb_port *port_dev = to_usb_port(dev);
  
! 	if (port_dev->child) {
! 		usb_disable_usb2_hardware_lpm(port_dev->child);
! 		usb_unlocked_disable_lpm(port_dev->child);
  	}
  }
  
diff -crB linux/drivers/usb/dwc3/core.h ClockworkPi-linux/drivers/usb/dwc3/core.h
*** linux/drivers/usb/dwc3/core.h	2025-01-18 12:32:06.957827260 -0500
--- ClockworkPi-linux/drivers/usb/dwc3/core.h	2025-01-18 12:30:24.039091082 -0500
***************
*** 457,463 ****
  #define DWC3_DCTL_TRGTULST_SS_INACT	(DWC3_DCTL_TRGTULST(6))
  
  /* These apply for core versions 1.94a and later */
- #define DWC3_DCTL_NYET_THRES_MASK	(0xf << 20)
  #define DWC3_DCTL_NYET_THRES(n)		(((n) & 0xf) << 20)
  
  #define DWC3_DCTL_KEEP_CONNECT		BIT(19)
--- 457,462 ----
diff -crB linux/drivers/usb/dwc3/dwc3-am62.c ClockworkPi-linux/drivers/usb/dwc3/dwc3-am62.c
*** linux/drivers/usb/dwc3/dwc3-am62.c	2025-01-18 12:32:06.961827214 -0500
--- ClockworkPi-linux/drivers/usb/dwc3/dwc3-am62.c	2025-01-18 12:30:24.039091082 -0500
***************
*** 284,290 ****
  
  	pm_runtime_put_sync(dev);
  	pm_runtime_disable(dev);
- 	pm_runtime_dont_use_autosuspend(dev);
  	pm_runtime_set_suspended(dev);
  }
  
--- 284,289 ----
diff -crB linux/drivers/usb/dwc3/gadget.c ClockworkPi-linux/drivers/usb/dwc3/gadget.c
*** linux/drivers/usb/dwc3/gadget.c	2025-01-18 12:32:06.965827168 -0500
--- ClockworkPi-linux/drivers/usb/dwc3/gadget.c	2025-01-18 12:30:24.043091029 -0500
***************
*** 4208,4217 ****
  		WARN_ONCE(DWC3_VER_IS_PRIOR(DWC3, 240A) && dwc->has_lpm_erratum,
  				"LPM Erratum not available on dwc3 revisions < 2.40a\n");
  
! 		if (dwc->has_lpm_erratum && !DWC3_VER_IS_PRIOR(DWC3, 240A)) {
! 			reg &= ~DWC3_DCTL_NYET_THRES_MASK;
  			reg |= DWC3_DCTL_NYET_THRES(dwc->lpm_nyet_threshold);
- 		}
  
  		dwc3_gadget_dctl_write_safe(dwc, reg);
  	} else {
--- 4208,4215 ----
  		WARN_ONCE(DWC3_VER_IS_PRIOR(DWC3, 240A) && dwc->has_lpm_erratum,
  				"LPM Erratum not available on dwc3 revisions < 2.40a\n");
  
! 		if (dwc->has_lpm_erratum && !DWC3_VER_IS_PRIOR(DWC3, 240A))
  			reg |= DWC3_DCTL_NYET_THRES(dwc->lpm_nyet_threshold);
  
  		dwc3_gadget_dctl_write_safe(dwc, reg);
  	} else {
diff -crB linux/drivers/usb/gadget/configfs.c ClockworkPi-linux/drivers/usb/gadget/configfs.c
*** linux/drivers/usb/gadget/configfs.c	2025-01-18 12:32:06.973827076 -0500
--- ClockworkPi-linux/drivers/usb/gadget/configfs.c	2025-01-18 12:30:24.051090924 -0500
***************
*** 824,838 ****
  {
  	struct gadget_string *string = to_gadget_string(item);
  	int size = min(sizeof(string->string), len + 1);
- 	ssize_t cpy_len;
  
  	if (len > USB_MAX_STRING_LEN)
  		return -EINVAL;
  
! 	cpy_len = strscpy(string->string, page, size);
! 	if (cpy_len > 0 && string->string[cpy_len - 1] == '\n')
! 		string->string[cpy_len - 1] = 0;
! 	return len;
  }
  CONFIGFS_ATTR(gadget_string_, s);
  
--- 824,834 ----
  {
  	struct gadget_string *string = to_gadget_string(item);
  	int size = min(sizeof(string->string), len + 1);
  
  	if (len > USB_MAX_STRING_LEN)
  		return -EINVAL;
  
! 	return strscpy(string->string, page, size);
  }
  CONFIGFS_ATTR(gadget_string_, s);
  
diff -crB linux/drivers/usb/gadget/function/f_fs.c ClockworkPi-linux/drivers/usb/gadget/function/f_fs.c
*** linux/drivers/usb/gadget/function/f_fs.c	2025-01-18 12:32:06.973827076 -0500
--- ClockworkPi-linux/drivers/usb/gadget/function/f_fs.c	2025-01-18 12:30:24.059090819 -0500
***************
*** 1810,1816 ****
  	struct usb_gadget_strings **lang;
  	int first_id;
  
! 	if ((ffs->state != FFS_ACTIVE
  		 || test_and_set_bit(FFS_FL_BOUND, &ffs->flags)))
  		return -EBADFD;
  
--- 1810,1816 ----
  	struct usb_gadget_strings **lang;
  	int first_id;
  
! 	if (WARN_ON(ffs->state != FFS_ACTIVE
  		 || test_and_set_bit(FFS_FL_BOUND, &ffs->flags)))
  		return -EBADFD;
  
diff -crB linux/drivers/usb/gadget/function/f_uac2.c ClockworkPi-linux/drivers/usb/gadget/function/f_uac2.c
*** linux/drivers/usb/gadget/function/f_uac2.c	2025-01-18 12:32:06.981826984 -0500
--- ClockworkPi-linux/drivers/usb/gadget/function/f_uac2.c	2025-01-18 12:30:24.071090662 -0500
***************
*** 1176,1182 ****
  		uac2->as_in_alt = 0;
  	}
  
- 	std_ac_if_desc.bNumEndpoints = 0;
  	if (FUOUT_EN(uac2_opts) || FUIN_EN(uac2_opts)) {
  		uac2->int_ep = usb_ep_autoconfig(gadget, &fs_ep_int_desc);
  		if (!uac2->int_ep) {
--- 1176,1181 ----
diff -crB linux/drivers/usb/gadget/function/u_serial.c ClockworkPi-linux/drivers/usb/gadget/function/u_serial.c
*** linux/drivers/usb/gadget/function/u_serial.c	2025-01-18 12:32:06.985826938 -0500
--- ClockworkPi-linux/drivers/usb/gadget/function/u_serial.c	2025-01-18 12:30:24.075090609 -0500
***************
*** 1398,1407 ****
  	/* REVISIT as above: how best to track this? */
  	port->port_line_coding = gser->port_line_coding;
  
- 	/* disable endpoints, aborting down any active I/O */
- 	usb_ep_disable(gser->out);
- 	usb_ep_disable(gser->in);
- 
  	port->port_usb = NULL;
  	gser->ioport = NULL;
  	if (port->port.count > 0) {
--- 1398,1403 ----
***************
*** 1413,1418 ****
--- 1409,1418 ----
  	spin_unlock(&port->port_lock);
  	spin_unlock_irqrestore(&serial_port_lock, flags);
  
+ 	/* disable endpoints, aborting down any active I/O */
+ 	usb_ep_disable(gser->out);
+ 	usb_ep_disable(gser->in);
+ 
  	/* finally, free any unused/unusable I/O buffers */
  	spin_lock_irqsave(&port->port_lock, flags);
  	if (port->port.count == 0)
diff -crB linux/drivers/usb/gadget/Kconfig ClockworkPi-linux/drivers/usb/gadget/Kconfig
*** linux/drivers/usb/gadget/Kconfig	2025-01-18 12:32:06.969827122 -0500
--- ClockworkPi-linux/drivers/usb/gadget/Kconfig	2025-01-18 12:30:24.051090924 -0500
***************
*** 210,217 ****
  
  config USB_F_MIDI2
  	tristate
- 	select SND_UMP
- 	select SND_UMP_LEGACY_RAWMIDI
  
  config USB_F_HID
  	tristate
--- 210,215 ----
***************
*** 446,451 ****
--- 444,451 ----
  	depends on USB_CONFIGFS
  	depends on SND
  	select USB_LIBCOMPOSITE
+ 	select SND_UMP
+ 	select SND_UMP_LEGACY_RAWMIDI
  	select USB_F_MIDI2
  	help
  	  The MIDI 2.0 function driver provides the generic emulated
diff -crB linux/drivers/usb/serial/cp210x.c ClockworkPi-linux/drivers/usb/serial/cp210x.c
*** linux/drivers/usb/serial/cp210x.c	2025-01-18 12:32:07.097825653 -0500
--- ClockworkPi-linux/drivers/usb/serial/cp210x.c	2025-01-18 12:30:24.251088299 -0500
***************
*** 223,229 ****
  	{ USB_DEVICE(0x19CF, 0x3000) }, /* Parrot NMEA GPS Flight Recorder */
  	{ USB_DEVICE(0x1ADB, 0x0001) }, /* Schweitzer Engineering C662 Cable */
  	{ USB_DEVICE(0x1B1C, 0x1C00) }, /* Corsair USB Dongle */
- 	{ USB_DEVICE(0x1B93, 0x1013) }, /* Phoenix Contact UPS Device */
  	{ USB_DEVICE(0x1BA4, 0x0002) },	/* Silicon Labs 358x factory default */
  	{ USB_DEVICE(0x1BE3, 0x07A6) }, /* WAGO 750-923 USB Service Cable */
  	{ USB_DEVICE(0x1D6F, 0x0010) }, /* Seluxit ApS RF Dongle */
--- 223,228 ----
diff -crB linux/drivers/usb/serial/option.c ClockworkPi-linux/drivers/usb/serial/option.c
*** linux/drivers/usb/serial/option.c	2025-01-18 12:32:07.109825515 -0500
--- ClockworkPi-linux/drivers/usb/serial/option.c	2025-01-18 12:30:24.271088037 -0500
***************
*** 621,627 ****
  
  /* MeiG Smart Technology products */
  #define MEIGSMART_VENDOR_ID			0x2dee
! /* MeiG Smart SRM815/SRM825L based on Qualcomm 315 */
  #define MEIGSMART_PRODUCT_SRM825L		0x4d22
  /* MeiG Smart SLM320 based on UNISOC UIS8910 */
  #define MEIGSMART_PRODUCT_SLM320		0x4d41
--- 621,627 ----
  
  /* MeiG Smart Technology products */
  #define MEIGSMART_VENDOR_ID			0x2dee
! /* MeiG Smart SRM825L based on Qualcomm 315 */
  #define MEIGSMART_PRODUCT_SRM825L		0x4d22
  /* MeiG Smart SLM320 based on UNISOC UIS8910 */
  #define MEIGSMART_PRODUCT_SLM320		0x4d41
***************
*** 2405,2411 ****
  	{ USB_DEVICE_AND_INTERFACE_INFO(UNISOC_VENDOR_ID, LUAT_PRODUCT_AIR720U, 0xff, 0, 0) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGSMART_VENDOR_ID, MEIGSMART_PRODUCT_SLM320, 0xff, 0, 0) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGSMART_VENDOR_ID, MEIGSMART_PRODUCT_SLM770A, 0xff, 0, 0) },
- 	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGSMART_VENDOR_ID, MEIGSMART_PRODUCT_SRM825L, 0xff, 0, 0) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGSMART_VENDOR_ID, MEIGSMART_PRODUCT_SRM825L, 0xff, 0xff, 0x30) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGSMART_VENDOR_ID, MEIGSMART_PRODUCT_SRM825L, 0xff, 0xff, 0x40) },
  	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGSMART_VENDOR_ID, MEIGSMART_PRODUCT_SRM825L, 0xff, 0xff, 0x60) },
--- 2405,2410 ----
***************
*** 2413,2419 ****
  	  .driver_info = NCTRL(1) },
  	{ USB_DEVICE_INTERFACE_CLASS(0x1bbb, 0x0640, 0xff),			/* TCL IK512 ECM */
  	  .driver_info = NCTRL(3) },
- 	{ USB_DEVICE_INTERFACE_CLASS(0x2949, 0x8700, 0xff) },			/* Neoway N723-EA */
  	{ } /* Terminating entry */
  };
  MODULE_DEVICE_TABLE(usb, option_ids);
--- 2412,2417 ----
diff -crB linux/drivers/usb/storage/unusual_devs.h ClockworkPi-linux/drivers/usb/storage/unusual_devs.h
*** linux/drivers/usb/storage/unusual_devs.h	2025-01-18 12:32:07.117825424 -0500
--- ClockworkPi-linux/drivers/usb/storage/unusual_devs.h	2025-01-18 12:30:24.287087827 -0500
***************
*** 255,267 ****
  		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
  		US_FL_MAX_SECTORS_64 ),
  
- /* Added by Lubomir Rintel <lkundrak@v3.sk>, a very fine chap */
- UNUSUAL_DEV(  0x0421, 0x06c2, 0x0000, 0x0406,
- 		"Nokia",
- 		"Nokia 208",
- 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
- 		US_FL_MAX_SECTORS_64 ),
- 
  #ifdef NO_SDDR09
  UNUSUAL_DEV(  0x0436, 0x0005, 0x0100, 0x0100,
  		"Microtech",
--- 255,260 ----
diff -crB linux/drivers/usb/typec/tcpm/maxim_contaminant.c ClockworkPi-linux/drivers/usb/typec/tcpm/maxim_contaminant.c
*** linux/drivers/usb/typec/tcpm/maxim_contaminant.c	2025-01-18 12:32:07.125825332 -0500
--- ClockworkPi-linux/drivers/usb/typec/tcpm/maxim_contaminant.c	2025-01-18 12:30:24.295087722 -0500
***************
*** 137,143 ****
  
  		mv = max_contaminant_read_adc_mv(chip, channel, sleep_msec, raw, true);
  		if (mv < 0)
! 			return mv;
  
  		/* OVP enable */
  		ret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, CCOVPDIS, 0);
--- 137,143 ----
  
  		mv = max_contaminant_read_adc_mv(chip, channel, sleep_msec, raw, true);
  		if (mv < 0)
! 			return ret;
  
  		/* OVP enable */
  		ret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, CCOVPDIS, 0);
***************
*** 159,165 ****
  
  	mv = max_contaminant_read_adc_mv(chip, channel, sleep_msec, raw, true);
  	if (mv < 0)
! 		return mv;
  	/* Disable current source */
  	ret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, SBURPCTRL, 0);
  	if (ret < 0)
--- 159,165 ----
  
  	mv = max_contaminant_read_adc_mv(chip, channel, sleep_msec, raw, true);
  	if (mv < 0)
! 		return ret;
  	/* Disable current source */
  	ret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, SBURPCTRL, 0);
  	if (ret < 0)
diff -crB linux/drivers/video/backlight/Kconfig ClockworkPi-linux/drivers/video/backlight/Kconfig
*** linux/drivers/video/backlight/Kconfig	2025-01-18 12:32:07.153825011 -0500
--- ClockworkPi-linux/drivers/video/backlight/Kconfig	2025-01-18 12:30:24.327087302 -0500
***************
*** 479,484 ****
--- 479,490 ----
  	  If you have a LCD backlight adjustable by LED class driver, say Y
  	  to enable this driver.
  
+ config BACKLIGHT_OCP8178
+ 	tristate "OCP8178 Backlight Driver"
+ 	depends on GPIOLIB
+ 	help
+ 	  If you have an OCP8178, say Y to enable the backlight driver.
+ 
  endif # BACKLIGHT_CLASS_DEVICE
  
  endmenu
diff -crB linux/drivers/video/backlight/Makefile ClockworkPi-linux/drivers/video/backlight/Makefile
*** linux/drivers/video/backlight/Makefile	2025-01-18 12:32:07.153825011 -0500
--- ClockworkPi-linux/drivers/video/backlight/Makefile	2025-01-18 12:30:24.327087302 -0500
***************
*** 59,61 ****
--- 59,62 ----
  obj-$(CONFIG_BACKLIGHT_ARCXCNN) 	+= arcxcnn_bl.o
  obj-$(CONFIG_BACKLIGHT_RAVE_SP)		+= rave-sp-backlight.o
  obj-$(CONFIG_BACKLIGHT_LED)		+= led_bl.o
+ obj-$(CONFIG_BACKLIGHT_OCP8178)		+= ocp8178_bl.o
Only in ClockworkPi-linux/drivers/video/backlight: ocp8178_bl.c
diff -crB linux/fs/afs/afs.h ClockworkPi-linux/fs/afs/afs.h
*** linux/fs/afs/afs.h	2025-01-18 12:32:07.321823083 -0500
--- ClockworkPi-linux/fs/afs/afs.h	2025-01-18 12:30:24.491085150 -0500
***************
*** 10,16 ****
  
  #include <linux/in.h>
  
! #define AFS_MAXCELLNAME		253  	/* Maximum length of a cell name (DNS limited) */
  #define AFS_MAXVOLNAME		64  	/* Maximum length of a volume name */
  #define AFS_MAXNSERVERS		8   	/* Maximum servers in a basic volume record */
  #define AFS_NMAXNSERVERS	13  	/* Maximum servers in a N/U-class volume record */
--- 10,16 ----
  
  #include <linux/in.h>
  
! #define AFS_MAXCELLNAME		256  	/* Maximum length of a cell name */
  #define AFS_MAXVOLNAME		64  	/* Maximum length of a volume name */
  #define AFS_MAXNSERVERS		8   	/* Maximum servers in a basic volume record */
  #define AFS_NMAXNSERVERS	13  	/* Maximum servers in a N/U-class volume record */
diff -crB linux/fs/afs/afs_vl.h ClockworkPi-linux/fs/afs/afs_vl.h
*** linux/fs/afs/afs_vl.h	2025-01-18 12:32:07.321823083 -0500
--- ClockworkPi-linux/fs/afs/afs_vl.h	2025-01-18 12:30:24.495085097 -0500
***************
*** 13,19 ****
  #define AFS_VL_PORT		7003	/* volume location service port */
  #define VL_SERVICE		52	/* RxRPC service ID for the Volume Location service */
  #define YFS_VL_SERVICE		2503	/* Service ID for AuriStor upgraded VL service */
- #define YFS_VL_MAXCELLNAME	256  	/* Maximum length of a cell name in YFS protocol */
  
  enum AFSVL_Operations {
  	VLGETENTRYBYID		= 503,	/* AFS Get VLDB entry by ID */
--- 13,18 ----
diff -crB linux/fs/afs/vl_alias.c ClockworkPi-linux/fs/afs/vl_alias.c
*** linux/fs/afs/vl_alias.c	2025-01-18 12:32:07.329822991 -0500
--- ClockworkPi-linux/fs/afs/vl_alias.c	2025-01-18 12:30:24.499085045 -0500
***************
*** 302,308 ****
  static int yfs_check_canonical_cell_name(struct afs_cell *cell, struct key *key)
  {
  	struct afs_cell *master;
- 	size_t name_len;
  	char *cell_name;
  
  	cell_name = afs_vl_get_cell_name(cell, key);
--- 302,307 ----
***************
*** 314,324 ****
  		return 0;
  	}
  
! 	name_len = strlen(cell_name);
! 	if (!name_len || name_len > AFS_MAXCELLNAME)
! 		master = ERR_PTR(-EOPNOTSUPP);
! 	else
! 		master = afs_lookup_cell(cell->net, cell_name, name_len, NULL, false);
  	kfree(cell_name);
  	if (IS_ERR(master))
  		return PTR_ERR(master);
--- 313,320 ----
  		return 0;
  	}
  
! 	master = afs_lookup_cell(cell->net, cell_name, strlen(cell_name),
! 				 NULL, false);
  	kfree(cell_name);
  	if (IS_ERR(master))
  		return PTR_ERR(master);
diff -crB linux/fs/afs/vlclient.c ClockworkPi-linux/fs/afs/vlclient.c
*** linux/fs/afs/vlclient.c	2025-01-18 12:32:07.329822991 -0500
--- ClockworkPi-linux/fs/afs/vlclient.c	2025-01-18 12:30:24.499085045 -0500
***************
*** 671,677 ****
  			return ret;
  
  		namesz = ntohl(call->tmp);
! 		if (namesz > YFS_VL_MAXCELLNAME)
  			return afs_protocol_error(call, afs_eproto_cellname_len);
  		paddedsz = (namesz + 3) & ~3;
  		call->count = namesz;
--- 671,677 ----
  			return ret;
  
  		namesz = ntohl(call->tmp);
! 		if (namesz > AFS_MAXCELLNAME)
  			return afs_protocol_error(call, afs_eproto_cellname_len);
  		paddedsz = (namesz + 3) & ~3;
  		call->count = namesz;
diff -crB linux/fs/btrfs/scrub.c ClockworkPi-linux/fs/btrfs/scrub.c
*** linux/fs/btrfs/scrub.c	2025-01-18 12:32:07.365822578 -0500
--- ClockworkPi-linux/fs/btrfs/scrub.c	2025-01-18 12:30:24.535084572 -0500
***************
*** 1538,1547 ****
  	u64 extent_gen;
  	int ret;
  
- 	if (unlikely(!extent_root)) {
- 		btrfs_err(fs_info, "no valid extent root for scrub");
- 		return -EUCLEAN;
- 	}
  	memset(stripe->sectors, 0, sizeof(struct scrub_sector_verification) *
  				   stripe->nr_sectors);
  	scrub_stripe_reset_bitmaps(stripe);
--- 1538,1543 ----
diff -crB linux/fs/erofs/zdata.c ClockworkPi-linux/fs/erofs/zdata.c
*** linux/fs/erofs/zdata.c	2025-01-18 12:32:07.413822027 -0500
--- ClockworkPi-linux/fs/erofs/zdata.c	2025-01-18 12:30:24.587083890 -0500
***************
*** 1483,1495 ****
  		goto out;
  
  	lock_page(page);
! 	if (likely(page->mapping == mc)) {
  		WRITE_ONCE(pcl->compressed_bvecs[nr].page, page);
  
- 		/*
- 		 * The cached folio is still in managed cache but without
- 		 * a valid `->private` pcluster hint.  Let's reconnect them.
- 		 */
  		if (!PagePrivate(page)) {
  			/*
  			 * impossible to be !PagePrivate(page) for
--- 1483,1496 ----
  		goto out;
  
  	lock_page(page);
! 
! 	/* only true if page reclaim goes wrong, should never happen */
! 	DBG_BUGON(justfound && PagePrivate(page));
! 
! 	/* the page is still in manage cache */
! 	if (page->mapping == mc) {
  		WRITE_ONCE(pcl->compressed_bvecs[nr].page, page);
  
  		if (!PagePrivate(page)) {
  			/*
  			 * impossible to be !PagePrivate(page) for
***************
*** 1503,1526 ****
  			SetPagePrivate(page);
  		}
  
! 		if (likely(page->private == (unsigned long)pcl)) {
! 			/* don't submit cache I/Os again if already uptodate */
! 			if (PageUptodate(page)) {
! 				unlock_page(page);
! 				page = NULL;
! 
! 			}
! 			goto out;
  		}
! 		/*
! 		 * Already linked with another pcluster, which only appears in
! 		 * crafted images by fuzzers for now.  But handle this anyway.
! 		 */
! 		tocache = false;	/* use temporary short-lived pages */
! 	} else {
! 		DBG_BUGON(1); /* referenced managed folios can't be truncated */
! 		tocache = true;
  	}
  	unlock_page(page);
  	put_page(page);
  out_allocpage:
--- 1504,1525 ----
  			SetPagePrivate(page);
  		}
  
! 		/* no need to submit io if it is already up-to-date */
! 		if (PageUptodate(page)) {
! 			unlock_page(page);
! 			page = NULL;
  		}
! 		goto out;
  	}
+ 
+ 	/*
+ 	 * the managed page has been truncated, it's unsafe to
+ 	 * reuse this one, let's allocate a new cache-managed page.
+ 	 */
+ 	DBG_BUGON(page->mapping);
+ 	DBG_BUGON(!justfound);
+ 
+ 	tocache = true;
  	unlock_page(page);
  	put_page(page);
  out_allocpage:
***************
*** 1678,1688 ****
  		end = cur + pcl->pclusterpages;
  
  		do {
! 			struct page *page = NULL;
  
  			if (bio && (cur != last_index + 1 ||
  				    last_bdev != mdev.m_bdev)) {
! drain_io:
  				submit_bio(bio);
  				if (memstall) {
  					psi_memstall_leave(&pflags);
--- 1677,1692 ----
  		end = cur + pcl->pclusterpages;
  
  		do {
! 			struct page *page;
! 
! 			page = pickup_page_for_submission(pcl, i++,
! 					&f->pagepool, mc);
! 			if (!page)
! 				continue;
  
  			if (bio && (cur != last_index + 1 ||
  				    last_bdev != mdev.m_bdev)) {
! submit_bio_retry:
  				submit_bio(bio);
  				if (memstall) {
  					psi_memstall_leave(&pflags);
***************
*** 1691,1703 ****
  				bio = NULL;
  			}
  
- 			if (!page) {
- 				page = pickup_page_for_submission(pcl, i++,
- 						&f->pagepool, mc);
- 				if (!page)
- 					continue;
- 			}
- 
  			if (unlikely(PageWorkingset(page)) && !memstall) {
  				psi_memstall_enter(&pflags);
  				memstall = 1;
--- 1695,1700 ----
***************
*** 1718,1724 ****
  			}
  
  			if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE)
! 				goto drain_io;
  
  			last_index = cur;
  			bypass = false;
--- 1715,1721 ----
  			}
  
  			if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE)
! 				goto submit_bio_retry;
  
  			last_index = cur;
  			bypass = false;
***************
*** 1730,1739 ****
  			move_to_bypass_jobqueue(pcl, qtail, owned_head);
  	} while (owned_head != Z_EROFS_PCLUSTER_TAIL);
  
! 	if (bio)
  		submit_bio(bio);
! 	if (memstall)
! 		psi_memstall_leave(&pflags);
  
  	/*
  	 * although background is preferred, no one is pending for submission.
--- 1727,1737 ----
  			move_to_bypass_jobqueue(pcl, qtail, owned_head);
  	} while (owned_head != Z_EROFS_PCLUSTER_TAIL);
  
! 	if (bio) {
  		submit_bio(bio);
! 		if (memstall)
! 			psi_memstall_leave(&pflags);
! 	}
  
  	/*
  	 * although background is preferred, no one is pending for submission.
diff -crB linux/fs/exfat/dir.c ClockworkPi-linux/fs/exfat/dir.c
*** linux/fs/exfat/dir.c	2025-01-18 12:32:07.417821981 -0500
--- ClockworkPi-linux/fs/exfat/dir.c	2025-01-18 12:30:24.587083890 -0500
***************
*** 125,131 ****
  			type = exfat_get_entry_type(ep);
  			if (type == TYPE_UNUSED) {
  				brelse(bh);
! 				goto out;
  			}
  
  			if (type != TYPE_FILE && type != TYPE_DIR) {
--- 125,131 ----
  			type = exfat_get_entry_type(ep);
  			if (type == TYPE_UNUSED) {
  				brelse(bh);
! 				break;
  			}
  
  			if (type != TYPE_FILE && type != TYPE_DIR) {
***************
*** 189,195 ****
  		}
  	}
  
- out:
  	dir_entry->namebuf.lfn[0] = '\0';
  	*cpos = EXFAT_DEN_TO_B(dentry);
  	return 0;
--- 189,194 ----
diff -crB linux/fs/exfat/fatent.c ClockworkPi-linux/fs/exfat/fatent.c
*** linux/fs/exfat/fatent.c	2025-01-18 12:32:07.417821981 -0500
--- ClockworkPi-linux/fs/exfat/fatent.c	2025-01-18 12:30:24.591083837 -0500
***************
*** 216,231 ****
  
  			if (err)
  				goto dec_used_clus;
- 
- 			if (num_clusters >= sbi->num_clusters - EXFAT_FIRST_CLUSTER) {
- 				/*
- 				 * The cluster chain includes a loop, scan the
- 				 * bitmap to get the number of used clusters.
- 				 */
- 				exfat_count_used_clusters(sb, &sbi->used_clusters);
- 
- 				return 0;
- 			}
  		} while (clu != EXFAT_EOF_CLUSTER);
  	}
  
--- 216,221 ----
diff -crB linux/fs/f2fs/super.c ClockworkPi-linux/fs/f2fs/super.c
*** linux/fs/f2fs/super.c	2025-01-18 12:32:07.449821614 -0500
--- ClockworkPi-linux/fs/f2fs/super.c	2025-01-18 12:30:24.623083417 -0500
***************
*** 4931,4936 ****
--- 4931,4939 ----
  	err = register_shrinker(&f2fs_shrinker_info, "f2fs-shrinker");
  	if (err)
  		goto free_sysfs;
+ 	err = register_filesystem(&f2fs_fs_type);
+ 	if (err)
+ 		goto free_shrinker;
  	f2fs_create_root_stats();
  	err = f2fs_init_post_read_processing();
  	if (err)
***************
*** 4953,4964 ****
  	err = f2fs_create_casefold_cache();
  	if (err)
  		goto free_compress_cache;
- 	err = register_filesystem(&f2fs_fs_type);
- 	if (err)
- 		goto free_casefold_cache;
  	return 0;
- free_casefold_cache:
- 	f2fs_destroy_casefold_cache();
  free_compress_cache:
  	f2fs_destroy_compress_cache();
  free_compress_mempool:
--- 4956,4962 ----
***************
*** 4973,4978 ****
--- 4971,4978 ----
  	f2fs_destroy_post_read_processing();
  free_root_stats:
  	f2fs_destroy_root_stats();
+ 	unregister_filesystem(&f2fs_fs_type);
+ free_shrinker:
  	unregister_shrinker(&f2fs_shrinker_info);
  free_sysfs:
  	f2fs_exit_sysfs();
***************
*** 4996,5002 ****
  
  static void __exit exit_f2fs_fs(void)
  {
- 	unregister_filesystem(&f2fs_fs_type);
  	f2fs_destroy_casefold_cache();
  	f2fs_destroy_compress_cache();
  	f2fs_destroy_compress_mempool();
--- 4996,5001 ----
***************
*** 5005,5010 ****
--- 5004,5010 ----
  	f2fs_destroy_iostat_processing();
  	f2fs_destroy_post_read_processing();
  	f2fs_destroy_root_stats();
+ 	unregister_filesystem(&f2fs_fs_type);
  	unregister_shrinker(&f2fs_shrinker_info);
  	f2fs_exit_sysfs();
  	f2fs_destroy_garbage_collection_cache();
diff -crB linux/fs/jbd2/commit.c ClockworkPi-linux/fs/jbd2/commit.c
*** linux/fs/jbd2/commit.c	2025-01-18 12:32:07.489821155 -0500
--- ClockworkPi-linux/fs/jbd2/commit.c	2025-01-18 12:30:24.663082892 -0500
***************
*** 777,785 ****
  	/*
  	 * If the journal is not located on the file system device,
  	 * then we must flush the file system device before we issue
! 	 * the commit record and update the journal tail sequence.
  	 */
! 	if ((commit_transaction->t_need_data_flush || update_tail) &&
  	    (journal->j_fs_dev != journal->j_dev) &&
  	    (journal->j_flags & JBD2_BARRIER))
  		blkdev_issue_flush(journal->j_fs_dev);
--- 777,785 ----
  	/*
  	 * If the journal is not located on the file system device,
  	 * then we must flush the file system device before we issue
! 	 * the commit record
  	 */
! 	if (commit_transaction->t_need_data_flush &&
  	    (journal->j_fs_dev != journal->j_dev) &&
  	    (journal->j_flags & JBD2_BARRIER))
  		blkdev_issue_flush(journal->j_fs_dev);
diff -crB linux/fs/jbd2/revoke.c ClockworkPi-linux/fs/jbd2/revoke.c
*** linux/fs/jbd2/revoke.c	2025-01-18 12:32:07.493821109 -0500
--- ClockworkPi-linux/fs/jbd2/revoke.c	2025-01-18 12:30:24.667082840 -0500
***************
*** 654,660 ****
  	set_buffer_jwrite(descriptor);
  	BUFFER_TRACE(descriptor, "write");
  	set_buffer_dirty(descriptor);
! 	write_dirty_buffer(descriptor, JBD2_JOURNAL_REQ_FLAGS);
  }
  #endif
  
--- 654,660 ----
  	set_buffer_jwrite(descriptor);
  	BUFFER_TRACE(descriptor, "write");
  	set_buffer_dirty(descriptor);
! 	write_dirty_buffer(descriptor, REQ_SYNC);
  }
  #endif
  
diff -crB linux/fs/Kconfig ClockworkPi-linux/fs/Kconfig
*** linux/fs/Kconfig	2025-01-18 12:32:07.313823175 -0500
--- ClockworkPi-linux/fs/Kconfig	2025-01-18 12:30:24.487085202 -0500
***************
*** 253,259 ****
  config ARCH_SUPPORTS_HUGETLBFS
  	def_bool n
  
! menuconfig HUGETLBFS
  	bool "HugeTLB file system support"
  	depends on X86 || IA64 || SPARC64 || ARCH_SUPPORTS_HUGETLBFS || BROKEN
  	depends on (SYSFS || SYSCTL)
--- 253,259 ----
  config ARCH_SUPPORTS_HUGETLBFS
  	def_bool n
  
! config HUGETLBFS
  	bool "HugeTLB file system support"
  	depends on X86 || IA64 || SPARC64 || ARCH_SUPPORTS_HUGETLBFS || BROKEN
  	depends on (SYSFS || SYSCTL)
***************
*** 265,281 ****
  
  	  If unsure, say N.
  
- if HUGETLBFS
- config HUGETLB_PAGE_OPTIMIZE_VMEMMAP_DEFAULT_ON
- 	bool "HugeTLB Vmemmap Optimization (HVO) defaults to on"
- 	default n
- 	depends on HUGETLB_PAGE_OPTIMIZE_VMEMMAP
- 	help
- 	  The HugeTLB Vmemmap Optimization (HVO) defaults to off. Say Y here to
- 	  enable HVO by default. It can be disabled via hugetlb_free_vmemmap=off
- 	  (boot command line) or hugetlb_optimize_vmemmap (sysctl).
- endif # HUGETLBFS
- 
  config HUGETLB_PAGE
  	def_bool HUGETLBFS
  
--- 265,270 ----
***************
*** 284,292 ****
  	depends on ARCH_WANT_OPTIMIZE_HUGETLB_VMEMMAP
  	depends on SPARSEMEM_VMEMMAP
  
! config HUGETLB_PMD_PAGE_TABLE_SHARING
! 	def_bool HUGETLB_PAGE
! 	depends on ARCH_WANT_HUGE_PMD_SHARE && SPLIT_PMD_PTLOCKS
  
  config ARCH_HAS_GIGANTIC_PAGE
  	bool
--- 273,286 ----
  	depends on ARCH_WANT_OPTIMIZE_HUGETLB_VMEMMAP
  	depends on SPARSEMEM_VMEMMAP
  
! config HUGETLB_PAGE_OPTIMIZE_VMEMMAP_DEFAULT_ON
! 	bool "HugeTLB Vmemmap Optimization (HVO) defaults to on"
! 	default n
! 	depends on HUGETLB_PAGE_OPTIMIZE_VMEMMAP
! 	help
! 	  The HugeTLB VmemmapvOptimization (HVO) defaults to off. Say Y here to
! 	  enable HVO by default. It can be disabled via hugetlb_free_vmemmap=off
! 	  (boot command line) or hugetlb_optimize_vmemmap (sysctl).
  
  config ARCH_HAS_GIGANTIC_PAGE
  	bool
diff -crB linux/fs/overlayfs/copy_up.c ClockworkPi-linux/fs/overlayfs/copy_up.c
*** linux/fs/overlayfs/copy_up.c	2025-01-18 12:32:07.657819227 -0500
--- ClockworkPi-linux/fs/overlayfs/copy_up.c	2025-01-18 12:30:25.135076700 -0500
***************
*** 371,383 ****
  	return err;
  }
  
! struct ovl_fh *ovl_encode_real_fh(struct ovl_fs *ofs, struct inode *realinode,
  				  bool is_upper)
  {
  	struct ovl_fh *fh;
  	int fh_type, dwords;
  	int buflen = MAX_HANDLE_SZ;
! 	uuid_t *uuid = &realinode->i_sb->s_uuid;
  	int err;
  
  	/* Make sure the real fid stays 32bit aligned */
--- 371,383 ----
  	return err;
  }
  
! struct ovl_fh *ovl_encode_real_fh(struct ovl_fs *ofs, struct dentry *real,
  				  bool is_upper)
  {
  	struct ovl_fh *fh;
  	int fh_type, dwords;
  	int buflen = MAX_HANDLE_SZ;
! 	uuid_t *uuid = &real->d_sb->s_uuid;
  	int err;
  
  	/* Make sure the real fid stays 32bit aligned */
***************
*** 394,401 ****
  	 * the price or reconnecting the dentry.
  	 */
  	dwords = buflen >> 2;
! 	fh_type = exportfs_encode_inode_fh(realinode, (void *)fh->fb.fid,
! 					   &dwords, NULL, 0);
  	buflen = (dwords << 2);
  
  	err = -EIO;
--- 394,400 ----
  	 * the price or reconnecting the dentry.
  	 */
  	dwords = buflen >> 2;
! 	fh_type = exportfs_encode_fh(real, (void *)fh->fb.fid, &dwords, 0);
  	buflen = (dwords << 2);
  
  	err = -EIO;
***************
*** 427,455 ****
  	return ERR_PTR(err);
  }
  
! struct ovl_fh *ovl_get_origin_fh(struct ovl_fs *ofs, struct dentry *origin)
  {
  	/*
  	 * When lower layer doesn't support export operations store a 'null' fh,
  	 * so we can use the overlay.origin xattr to distignuish between a copy
  	 * up and a pure upper inode.
  	 */
! 	if (!ovl_can_decode_fh(origin->d_sb))
! 		return NULL;
! 
! 	return ovl_encode_real_fh(ofs, d_inode(origin), false);
! }
! 
! int ovl_set_origin_fh(struct ovl_fs *ofs, const struct ovl_fh *fh,
! 		      struct dentry *upper)
! {
! 	int err;
  
  	/*
  	 * Do not fail when upper doesn't support xattrs.
  	 */
  	err = ovl_check_setxattr(ofs, upper, OVL_XATTR_ORIGIN, fh->buf,
  				 fh ? fh->fb.len : 0, 0);
  
  	/* Ignore -EPERM from setting "user.*" on symlink/special */
  	return err == -EPERM ? 0 : err;
--- 426,454 ----
  	return ERR_PTR(err);
  }
  
! int ovl_set_origin(struct ovl_fs *ofs, struct dentry *lower,
! 		   struct dentry *upper)
  {
+ 	const struct ovl_fh *fh = NULL;
+ 	int err;
+ 
  	/*
  	 * When lower layer doesn't support export operations store a 'null' fh,
  	 * so we can use the overlay.origin xattr to distignuish between a copy
  	 * up and a pure upper inode.
  	 */
! 	if (ovl_can_decode_fh(lower->d_sb)) {
! 		fh = ovl_encode_real_fh(ofs, lower, false);
! 		if (IS_ERR(fh))
! 			return PTR_ERR(fh);
! 	}
  
  	/*
  	 * Do not fail when upper doesn't support xattrs.
  	 */
  	err = ovl_check_setxattr(ofs, upper, OVL_XATTR_ORIGIN, fh->buf,
  				 fh ? fh->fb.len : 0, 0);
+ 	kfree(fh);
  
  	/* Ignore -EPERM from setting "user.*" on symlink/special */
  	return err == -EPERM ? 0 : err;
***************
*** 462,468 ****
  	const struct ovl_fh *fh;
  	int err;
  
! 	fh = ovl_encode_real_fh(ofs, d_inode(upper), true);
  	if (IS_ERR(fh))
  		return PTR_ERR(fh);
  
--- 461,467 ----
  	const struct ovl_fh *fh;
  	int err;
  
! 	fh = ovl_encode_real_fh(ofs, upper, true);
  	if (IS_ERR(fh))
  		return PTR_ERR(fh);
  
***************
*** 477,483 ****
   *
   * Caller must hold i_mutex on indexdir.
   */
! static int ovl_create_index(struct dentry *dentry, const struct ovl_fh *fh,
  			    struct dentry *upper)
  {
  	struct ovl_fs *ofs = OVL_FS(dentry->d_sb);
--- 476,482 ----
   *
   * Caller must hold i_mutex on indexdir.
   */
! static int ovl_create_index(struct dentry *dentry, struct dentry *origin,
  			    struct dentry *upper)
  {
  	struct ovl_fs *ofs = OVL_FS(dentry->d_sb);
***************
*** 503,509 ****
  	if (WARN_ON(ovl_test_flag(OVL_INDEX, d_inode(dentry))))
  		return -EIO;
  
! 	err = ovl_get_index_name_fh(fh, &name);
  	if (err)
  		return err;
  
--- 502,508 ----
  	if (WARN_ON(ovl_test_flag(OVL_INDEX, d_inode(dentry))))
  		return -EIO;
  
! 	err = ovl_get_index_name(ofs, origin, &name);
  	if (err)
  		return err;
  
***************
*** 542,548 ****
  	struct dentry *destdir;
  	struct qstr destname;
  	struct dentry *workdir;
- 	const struct ovl_fh *origin_fh;
  	bool origin;
  	bool indexed;
  	bool metacopy;
--- 541,546 ----
***************
*** 639,645 ****
  	 * hard link.
  	 */
  	if (c->origin) {
! 		err = ovl_set_origin_fh(ofs, c->origin_fh, temp);
  		if (err)
  			return err;
  	}
--- 637,643 ----
  	 * hard link.
  	 */
  	if (c->origin) {
! 		err = ovl_set_origin(ofs, c->lowerpath.dentry, temp);
  		if (err)
  			return err;
  	}
***************
*** 751,757 ****
  		goto cleanup;
  
  	if (S_ISDIR(c->stat.mode) && c->indexed) {
! 		err = ovl_create_index(c->dentry, c->origin_fh, temp);
  		if (err)
  			goto cleanup;
  	}
--- 749,755 ----
  		goto cleanup;
  
  	if (S_ISDIR(c->stat.mode) && c->indexed) {
! 		err = ovl_create_index(c->dentry, c->lowerpath.dentry, temp);
  		if (err)
  			goto cleanup;
  	}
***************
*** 863,870 ****
  {
  	int err;
  	struct ovl_fs *ofs = OVL_FS(c->dentry->d_sb);
- 	struct dentry *origin = c->lowerpath.dentry;
- 	struct ovl_fh *fh = NULL;
  	bool to_index = false;
  
  	/*
--- 861,866 ----
***************
*** 881,905 ****
  			to_index = true;
  	}
  
! 	if (S_ISDIR(c->stat.mode) || c->stat.nlink == 1 || to_index) {
! 		fh = ovl_get_origin_fh(ofs, origin);
! 		if (IS_ERR(fh))
! 			return PTR_ERR(fh);
! 
! 		/* origin_fh may be NULL */
! 		c->origin_fh = fh;
  		c->origin = true;
- 	}
  
  	if (to_index) {
  		c->destdir = ovl_indexdir(c->dentry->d_sb);
! 		err = ovl_get_index_name(ofs, origin, &c->destname);
  		if (err)
! 			goto out_free_fh;
  	} else if (WARN_ON(!c->parent)) {
  		/* Disconnected dentry must be copied up to index dir */
! 		err = -EIO;
! 		goto out_free_fh;
  	} else {
  		/*
  		 * Mark parent "impure" because it may now contain non-pure
--- 877,893 ----
  			to_index = true;
  	}
  
! 	if (S_ISDIR(c->stat.mode) || c->stat.nlink == 1 || to_index)
  		c->origin = true;
  
  	if (to_index) {
  		c->destdir = ovl_indexdir(c->dentry->d_sb);
! 		err = ovl_get_index_name(ofs, c->lowerpath.dentry, &c->destname);
  		if (err)
! 			return err;
  	} else if (WARN_ON(!c->parent)) {
  		/* Disconnected dentry must be copied up to index dir */
! 		return -EIO;
  	} else {
  		/*
  		 * Mark parent "impure" because it may now contain non-pure
***************
*** 907,913 ****
  		 */
  		err = ovl_set_impure(c->parent, c->destdir);
  		if (err)
! 			goto out_free_fh;
  	}
  
  	/* Should we copyup with O_TMPFILE or with workdir? */
--- 895,901 ----
  		 */
  		err = ovl_set_impure(c->parent, c->destdir);
  		if (err)
! 			return err;
  	}
  
  	/* Should we copyup with O_TMPFILE or with workdir? */
***************
*** 939,946 ****
  out:
  	if (to_index)
  		kfree(c->destname.name);
- out_free_fh:
- 	kfree(fh);
  	return err;
  }
  
--- 927,932 ----
diff -crB linux/fs/overlayfs/export.c ClockworkPi-linux/fs/overlayfs/export.c
*** linux/fs/overlayfs/export.c	2025-01-18 12:32:07.657819227 -0500
--- ClockworkPi-linux/fs/overlayfs/export.c	2025-01-18 12:30:25.139076648 -0500
***************
*** 181,217 ****
   *
   * Return 0 for upper file handle, > 0 for lower file handle or < 0 on error.
   */
! static int ovl_check_encode_origin(struct inode *inode)
  {
! 	struct ovl_fs *ofs = OVL_FS(inode->i_sb);
  	bool decodable = ofs->config.nfs_export;
- 	struct dentry *dentry;
- 	int err;
  
  	/* No upper layer? */
  	if (!ovl_upper_mnt(ofs))
  		return 1;
  
  	/* Lower file handle for non-upper non-decodable */
! 	if (!ovl_inode_upper(inode) && !decodable)
  		return 1;
  
  	/* Upper file handle for pure upper */
! 	if (!ovl_inode_lower(inode))
  		return 0;
  
  	/*
  	 * Root is never indexed, so if there's an upper layer, encode upper for
  	 * root.
  	 */
! 	if (inode == d_inode(inode->i_sb->s_root))
  		return 0;
  
  	/*
  	 * Upper decodable file handle for non-indexed upper.
  	 */
! 	if (ovl_inode_upper(inode) && decodable &&
! 	    !ovl_test_flag(OVL_INDEX, inode))
  		return 0;
  
  	/*
--- 181,215 ----
   *
   * Return 0 for upper file handle, > 0 for lower file handle or < 0 on error.
   */
! static int ovl_check_encode_origin(struct dentry *dentry)
  {
! 	struct ovl_fs *ofs = OVL_FS(dentry->d_sb);
  	bool decodable = ofs->config.nfs_export;
  
  	/* No upper layer? */
  	if (!ovl_upper_mnt(ofs))
  		return 1;
  
  	/* Lower file handle for non-upper non-decodable */
! 	if (!ovl_dentry_upper(dentry) && !decodable)
  		return 1;
  
  	/* Upper file handle for pure upper */
! 	if (!ovl_dentry_lower(dentry))
  		return 0;
  
  	/*
  	 * Root is never indexed, so if there's an upper layer, encode upper for
  	 * root.
  	 */
! 	if (dentry == dentry->d_sb->s_root)
  		return 0;
  
  	/*
  	 * Upper decodable file handle for non-indexed upper.
  	 */
! 	if (ovl_dentry_upper(dentry) && decodable &&
! 	    !ovl_test_flag(OVL_INDEX, d_inode(dentry)))
  		return 0;
  
  	/*
***************
*** 220,242 ****
  	 * ovl_connect_layer() will try to make origin's layer "connected" by
  	 * copying up a "connectable" ancestor.
  	 */
! 	if (!decodable || !S_ISDIR(inode->i_mode))
! 		return 1;
! 
! 	dentry = d_find_any_alias(inode);
! 	if (!dentry)
! 		return -ENOENT;
! 
! 	err = ovl_connect_layer(dentry);
! 	dput(dentry);
! 	if (err < 0)
! 		return err;
  
  	/* Lower file handle for indexed and non-upper dir/non-dir */
  	return 1;
  }
  
! static int ovl_dentry_to_fid(struct ovl_fs *ofs, struct inode *inode,
  			     u32 *fid, int buflen)
  {
  	struct ovl_fh *fh = NULL;
--- 218,231 ----
  	 * ovl_connect_layer() will try to make origin's layer "connected" by
  	 * copying up a "connectable" ancestor.
  	 */
! 	if (d_is_dir(dentry) && decodable)
! 		return ovl_connect_layer(dentry);
  
  	/* Lower file handle for indexed and non-upper dir/non-dir */
  	return 1;
  }
  
! static int ovl_dentry_to_fid(struct ovl_fs *ofs, struct dentry *dentry,
  			     u32 *fid, int buflen)
  {
  	struct ovl_fh *fh = NULL;
***************
*** 247,259 ****
  	 * Check if we should encode a lower or upper file handle and maybe
  	 * copy up an ancestor to make lower file handle connectable.
  	 */
! 	err = enc_lower = ovl_check_encode_origin(inode);
  	if (enc_lower < 0)
  		goto fail;
  
  	/* Encode an upper or lower file handle */
! 	fh = ovl_encode_real_fh(ofs, enc_lower ? ovl_inode_lower(inode) :
! 				ovl_inode_upper(inode), !enc_lower);
  	if (IS_ERR(fh))
  		return PTR_ERR(fh);
  
--- 236,248 ----
  	 * Check if we should encode a lower or upper file handle and maybe
  	 * copy up an ancestor to make lower file handle connectable.
  	 */
! 	err = enc_lower = ovl_check_encode_origin(dentry);
  	if (enc_lower < 0)
  		goto fail;
  
  	/* Encode an upper or lower file handle */
! 	fh = ovl_encode_real_fh(ofs, enc_lower ? ovl_dentry_lower(dentry) :
! 				ovl_dentry_upper(dentry), !enc_lower);
  	if (IS_ERR(fh))
  		return PTR_ERR(fh);
  
***************
*** 267,274 ****
  	return err;
  
  fail:
! 	pr_warn_ratelimited("failed to encode file handle (ino=%lu, err=%i)\n",
! 			    inode->i_ino, err);
  	goto out;
  }
  
--- 256,263 ----
  	return err;
  
  fail:
! 	pr_warn_ratelimited("failed to encode file handle (%pd2, err=%i)\n",
! 			    dentry, err);
  	goto out;
  }
  
***************
*** 276,288 ****
  			 struct inode *parent)
  {
  	struct ovl_fs *ofs = OVL_FS(inode->i_sb);
  	int bytes, buflen = *max_len << 2;
  
  	/* TODO: encode connectable file handles */
  	if (parent)
  		return FILEID_INVALID;
  
! 	bytes = ovl_dentry_to_fid(ofs, inode, fid, buflen);
  	if (bytes <= 0)
  		return FILEID_INVALID;
  
--- 265,283 ----
  			 struct inode *parent)
  {
  	struct ovl_fs *ofs = OVL_FS(inode->i_sb);
+ 	struct dentry *dentry;
  	int bytes, buflen = *max_len << 2;
  
  	/* TODO: encode connectable file handles */
  	if (parent)
  		return FILEID_INVALID;
  
! 	dentry = d_find_any_alias(inode);
! 	if (!dentry)
! 		return FILEID_INVALID;
! 
! 	bytes = ovl_dentry_to_fid(ofs, dentry, fid, buflen);
! 	dput(dentry);
  	if (bytes <= 0)
  		return FILEID_INVALID;
  
diff -crB linux/fs/overlayfs/namei.c ClockworkPi-linux/fs/overlayfs/namei.c
*** linux/fs/overlayfs/namei.c	2025-01-18 12:32:07.657819227 -0500
--- ClockworkPi-linux/fs/overlayfs/namei.c	2025-01-18 12:30:25.139076648 -0500
***************
*** 507,525 ****
  	return err;
  }
  
- int ovl_verify_set_fh(struct ovl_fs *ofs, struct dentry *dentry,
- 		      enum ovl_xattr ox, const struct ovl_fh *fh,
- 		      bool is_upper, bool set)
- {
- 	int err;
- 
- 	err = ovl_verify_fh(ofs, dentry, ox, fh);
- 	if (set && err == -ENODATA)
- 		err = ovl_setxattr(ofs, dentry, ox, fh->buf, fh->fb.len);
- 
- 	return err;
- }
- 
  /*
   * Verify that @real dentry matches the file handle stored in xattr @name.
   *
--- 507,512 ----
***************
*** 528,549 ****
   *
   * Return 0 on match, -ESTALE on mismatch, -ENODATA on no xattr, < 0 on error.
   */
! int ovl_verify_origin_xattr(struct ovl_fs *ofs, struct dentry *dentry,
! 			    enum ovl_xattr ox, struct dentry *real,
! 			    bool is_upper, bool set)
  {
  	struct inode *inode;
  	struct ovl_fh *fh;
  	int err;
  
! 	fh = ovl_encode_real_fh(ofs, d_inode(real), is_upper);
  	err = PTR_ERR(fh);
  	if (IS_ERR(fh)) {
  		fh = NULL;
  		goto fail;
  	}
  
! 	err = ovl_verify_set_fh(ofs, dentry, ox, fh, is_upper, set);
  	if (err)
  		goto fail;
  
--- 515,538 ----
   *
   * Return 0 on match, -ESTALE on mismatch, -ENODATA on no xattr, < 0 on error.
   */
! int ovl_verify_set_fh(struct ovl_fs *ofs, struct dentry *dentry,
! 		      enum ovl_xattr ox, struct dentry *real, bool is_upper,
! 		      bool set)
  {
  	struct inode *inode;
  	struct ovl_fh *fh;
  	int err;
  
! 	fh = ovl_encode_real_fh(ofs, real, is_upper);
  	err = PTR_ERR(fh);
  	if (IS_ERR(fh)) {
  		fh = NULL;
  		goto fail;
  	}
  
! 	err = ovl_verify_fh(ofs, dentry, ox, fh);
! 	if (set && err == -ENODATA)
! 		err = ovl_setxattr(ofs, dentry, ox, fh->buf, fh->fb.len);
  	if (err)
  		goto fail;
  
***************
*** 696,702 ****
  	goto out;
  }
  
! int ovl_get_index_name_fh(const struct ovl_fh *fh, struct qstr *name)
  {
  	char *n, *s;
  
--- 684,690 ----
  	goto out;
  }
  
! static int ovl_get_index_name_fh(struct ovl_fh *fh, struct qstr *name)
  {
  	char *n, *s;
  
***************
*** 732,738 ****
  	struct ovl_fh *fh;
  	int err;
  
! 	fh = ovl_encode_real_fh(ofs, d_inode(origin), false);
  	if (IS_ERR(fh))
  		return PTR_ERR(fh);
  
--- 720,726 ----
  	struct ovl_fh *fh;
  	int err;
  
! 	fh = ovl_encode_real_fh(ofs, origin, false);
  	if (IS_ERR(fh))
  		return PTR_ERR(fh);
  
***************
*** 885,911 ****
  static int ovl_fix_origin(struct ovl_fs *ofs, struct dentry *dentry,
  			  struct dentry *lower, struct dentry *upper)
  {
- 	const struct ovl_fh *fh;
  	int err;
  
  	if (ovl_check_origin_xattr(ofs, upper))
  		return 0;
  
- 	fh = ovl_get_origin_fh(ofs, lower);
- 	if (IS_ERR(fh))
- 		return PTR_ERR(fh);
- 
  	err = ovl_want_write(dentry);
  	if (err)
! 		goto out;
  
! 	err = ovl_set_origin_fh(ofs, fh, upper);
  	if (!err)
  		err = ovl_set_impure(dentry->d_parent, upper->d_parent);
  
  	ovl_drop_write(dentry);
- out:
- 	kfree(fh);
  	return err;
  }
  
--- 873,892 ----
  static int ovl_fix_origin(struct ovl_fs *ofs, struct dentry *dentry,
  			  struct dentry *lower, struct dentry *upper)
  {
  	int err;
  
  	if (ovl_check_origin_xattr(ofs, upper))
  		return 0;
  
  	err = ovl_want_write(dentry);
  	if (err)
! 		return err;
  
! 	err = ovl_set_origin(ofs, lower, upper);
  	if (!err)
  		err = ovl_set_impure(dentry->d_parent, upper->d_parent);
  
  	ovl_drop_write(dentry);
  	return err;
  }
  
diff -crB linux/fs/overlayfs/overlayfs.h ClockworkPi-linux/fs/overlayfs/overlayfs.h
*** linux/fs/overlayfs/overlayfs.h	2025-01-18 12:32:07.657819227 -0500
--- ClockworkPi-linux/fs/overlayfs/overlayfs.h	2025-01-18 12:30:25.139076648 -0500
***************
*** 632,646 ****
  int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh, bool connected,
  			struct dentry *upperdentry, struct ovl_path **stackp);
  int ovl_verify_set_fh(struct ovl_fs *ofs, struct dentry *dentry,
! 		      enum ovl_xattr ox, const struct ovl_fh *fh,
! 		      bool is_upper, bool set);
! int ovl_verify_origin_xattr(struct ovl_fs *ofs, struct dentry *dentry,
! 			    enum ovl_xattr ox, struct dentry *real,
! 			    bool is_upper, bool set);
  struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index,
  			       bool connected);
  int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
- int ovl_get_index_name_fh(const struct ovl_fh *fh, struct qstr *name);
  int ovl_get_index_name(struct ovl_fs *ofs, struct dentry *origin,
  		       struct qstr *name);
  struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);
--- 632,642 ----
  int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh, bool connected,
  			struct dentry *upperdentry, struct ovl_path **stackp);
  int ovl_verify_set_fh(struct ovl_fs *ofs, struct dentry *dentry,
! 		      enum ovl_xattr ox, struct dentry *real, bool is_upper,
! 		      bool set);
  struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index,
  			       bool connected);
  int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
  int ovl_get_index_name(struct ovl_fs *ofs, struct dentry *origin,
  		       struct qstr *name);
  struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);
***************
*** 652,675 ****
  			  unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
- static inline int ovl_verify_origin_fh(struct ovl_fs *ofs, struct dentry *upper,
- 				       const struct ovl_fh *fh, bool set)
- {
- 	return ovl_verify_set_fh(ofs, upper, OVL_XATTR_ORIGIN, fh, false, set);
- }
- 
  static inline int ovl_verify_origin(struct ovl_fs *ofs, struct dentry *upper,
  				    struct dentry *origin, bool set)
  {
! 	return ovl_verify_origin_xattr(ofs, upper, OVL_XATTR_ORIGIN, origin,
! 				       false, set);
  }
  
  static inline int ovl_verify_upper(struct ovl_fs *ofs, struct dentry *index,
  				   struct dentry *upper, bool set)
  {
! 	return ovl_verify_origin_xattr(ofs, index, OVL_XATTR_UPPER, upper,
! 				       true, set);
  }
  
  /* readdir.c */
--- 648,664 ----
  			  unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
  static inline int ovl_verify_origin(struct ovl_fs *ofs, struct dentry *upper,
  				    struct dentry *origin, bool set)
  {
! 	return ovl_verify_set_fh(ofs, upper, OVL_XATTR_ORIGIN, origin,
! 				 false, set);
  }
  
  static inline int ovl_verify_upper(struct ovl_fs *ofs, struct dentry *index,
  				   struct dentry *upper, bool set)
  {
! 	return ovl_verify_set_fh(ofs, index, OVL_XATTR_UPPER, upper, true, set);
  }
  
  /* readdir.c */
***************
*** 832,842 ****
  int ovl_maybe_copy_up(struct dentry *dentry, int flags);
  int ovl_copy_xattr(struct super_block *sb, const struct path *path, struct dentry *new);
  int ovl_set_attr(struct ovl_fs *ofs, struct dentry *upper, struct kstat *stat);
! struct ovl_fh *ovl_encode_real_fh(struct ovl_fs *ofs, struct inode *realinode,
  				  bool is_upper);
! struct ovl_fh *ovl_get_origin_fh(struct ovl_fs *ofs, struct dentry *origin);
! int ovl_set_origin_fh(struct ovl_fs *ofs, const struct ovl_fh *fh,
! 		      struct dentry *upper);
  
  /* export.c */
  extern const struct export_operations ovl_export_operations;
--- 821,830 ----
  int ovl_maybe_copy_up(struct dentry *dentry, int flags);
  int ovl_copy_xattr(struct super_block *sb, const struct path *path, struct dentry *new);
  int ovl_set_attr(struct ovl_fs *ofs, struct dentry *upper, struct kstat *stat);
! struct ovl_fh *ovl_encode_real_fh(struct ovl_fs *ofs, struct dentry *real,
  				  bool is_upper);
! int ovl_set_origin(struct ovl_fs *ofs, struct dentry *lower,
! 		   struct dentry *upper);
  
  /* export.c */
  extern const struct export_operations ovl_export_operations;
diff -crB linux/fs/overlayfs/super.c ClockworkPi-linux/fs/overlayfs/super.c
*** linux/fs/overlayfs/super.c	2025-01-18 12:32:07.657819227 -0500
--- ClockworkPi-linux/fs/overlayfs/super.c	2025-01-18 12:30:25.139076648 -0500
***************
*** 879,898 ****
  {
  	struct vfsmount *mnt = ovl_upper_mnt(ofs);
  	struct dentry *indexdir;
- 	struct dentry *origin = ovl_lowerstack(oe)->dentry;
- 	const struct ovl_fh *fh;
  	int err;
  
- 	fh = ovl_get_origin_fh(ofs, origin);
- 	if (IS_ERR(fh))
- 		return PTR_ERR(fh);
- 
  	err = mnt_want_write(mnt);
  	if (err)
! 		goto out_free_fh;
  
  	/* Verify lower root is upper root origin */
! 	err = ovl_verify_origin_fh(ofs, upperpath->dentry, fh, true);
  	if (err) {
  		pr_err("failed to verify upper root origin\n");
  		goto out;
--- 879,893 ----
  {
  	struct vfsmount *mnt = ovl_upper_mnt(ofs);
  	struct dentry *indexdir;
  	int err;
  
  	err = mnt_want_write(mnt);
  	if (err)
! 		return err;
  
  	/* Verify lower root is upper root origin */
! 	err = ovl_verify_origin(ofs, upperpath->dentry,
! 				ovl_lowerstack(oe)->dentry, true);
  	if (err) {
  		pr_err("failed to verify upper root origin\n");
  		goto out;
***************
*** 924,933 ****
  		 * directory entries.
  		 */
  		if (ovl_check_origin_xattr(ofs, ofs->indexdir)) {
! 			err = ovl_verify_origin_xattr(ofs, ofs->indexdir,
! 						      OVL_XATTR_ORIGIN,
! 						      upperpath->dentry, true,
! 						      false);
  			if (err)
  				pr_err("failed to verify index dir 'origin' xattr\n");
  		}
--- 919,927 ----
  		 * directory entries.
  		 */
  		if (ovl_check_origin_xattr(ofs, ofs->indexdir)) {
! 			err = ovl_verify_set_fh(ofs, ofs->indexdir,
! 						OVL_XATTR_ORIGIN,
! 						upperpath->dentry, true, false);
  			if (err)
  				pr_err("failed to verify index dir 'origin' xattr\n");
  		}
***************
*** 945,952 ****
  
  out:
  	mnt_drop_write(mnt);
- out_free_fh:
- 	kfree(fh);
  	return err;
  }
  
--- 939,944 ----
diff -crB linux/fs/overlayfs/util.c ClockworkPi-linux/fs/overlayfs/util.c
*** linux/fs/overlayfs/util.c	2025-01-18 12:32:07.661819182 -0500
--- ClockworkPi-linux/fs/overlayfs/util.c	2025-01-18 12:30:25.139076648 -0500
***************
*** 976,993 ****
  	struct dentry *index = NULL;
  	struct inode *inode;
  	struct qstr name = { };
- 	bool got_write = false;
  	int err;
  
  	err = ovl_get_index_name(ofs, lowerdentry, &name);
  	if (err)
  		goto fail;
  
- 	err = ovl_want_write(dentry);
- 	if (err)
- 		goto fail;
- 
- 	got_write = true;
  	inode = d_inode(upperdentry);
  	if (!S_ISDIR(inode->i_mode) && inode->i_nlink != 1) {
  		pr_warn_ratelimited("cleanup linked index (%pd2, ino=%lu, nlink=%u)\n",
--- 976,987 ----
***************
*** 1025,1032 ****
  		goto fail;
  
  out:
- 	if (got_write)
- 		ovl_drop_write(dentry);
  	kfree(name.name);
  	dput(index);
  	return;
--- 1019,1024 ----
***************
*** 1097,1104 ****
  {
  	struct inode *inode = d_inode(dentry);
  
- 	ovl_drop_write(dentry);
- 
  	if (ovl_test_flag(OVL_INDEX, inode) && inode->i_nlink == 0) {
  		const struct cred *old_cred;
  
--- 1089,1094 ----
diff -crB linux/fs/smb/client/namespace.c ClockworkPi-linux/fs/smb/client/namespace.c
*** linux/fs/smb/client/namespace.c	2025-01-18 12:32:07.701818723 -0500
--- ClockworkPi-linux/fs/smb/client/namespace.c	2025-01-18 12:30:25.179076123 -0500
***************
*** 196,223 ****
  	struct smb3_fs_context tmp;
  	char *full_path;
  	struct vfsmount *mnt;
- 	struct cifs_sb_info *mntpt_sb;
- 	struct cifs_ses *ses;
  
  	if (IS_ROOT(mntpt))
  		return ERR_PTR(-ESTALE);
  
! 	mntpt_sb = CIFS_SB(mntpt->d_sb);
! 	ses = cifs_sb_master_tcon(mntpt_sb)->ses;
! 	cur_ctx = mntpt_sb->ctx;
! 
! 	/*
! 	 * At this point, the root session should be in the mntpt sb. We should
! 	 * bring the sb context passwords in sync with the root session's
! 	 * passwords. This would help prevent unnecessary retries and password
! 	 * swaps for automounts.
! 	 */
! 	mutex_lock(&ses->session_mutex);
! 	rc = smb3_sync_session_ctx_passwords(mntpt_sb, ses);
! 	mutex_unlock(&ses->session_mutex);
! 
! 	if (rc)
! 		return ERR_PTR(rc);
  
  	fc = fs_context_for_submount(path->mnt->mnt_sb->s_type, mntpt);
  	if (IS_ERR(fc))
--- 196,206 ----
  	struct smb3_fs_context tmp;
  	char *full_path;
  	struct vfsmount *mnt;
  
  	if (IS_ROOT(mntpt))
  		return ERR_PTR(-ESTALE);
  
! 	cur_ctx = CIFS_SB(mntpt->d_sb)->ctx;
  
  	fc = fs_context_for_submount(path->mnt->mnt_sb->s_type, mntpt);
  	if (IS_ERR(fc))
diff -crB linux/fs/smb/server/smb2pdu.c ClockworkPi-linux/fs/smb/server/smb2pdu.c
*** linux/fs/smb/server/smb2pdu.c	2025-01-18 12:32:07.721818493 -0500
--- ClockworkPi-linux/fs/smb/server/smb2pdu.c	2025-01-18 12:30:25.195075914 -0500
***************
*** 695,703 ****
  	struct smb2_hdr *rsp_hdr;
  	struct ksmbd_work *in_work = ksmbd_alloc_work_struct();
  
- 	if (!in_work)
- 		return;
- 
  	if (allocate_interim_rsp_buf(in_work)) {
  		pr_err("smb_allocate_rsp_buf failed!\n");
  		ksmbd_free_work_struct(in_work);
--- 695,700 ----
***************
*** 3989,4014 ****
  		posix_info->DeviceId = cpu_to_le32(ksmbd_kstat->kstat->rdev);
  		posix_info->HardLinks = cpu_to_le32(ksmbd_kstat->kstat->nlink);
  		posix_info->Mode = cpu_to_le32(ksmbd_kstat->kstat->mode & 0777);
- 		switch (ksmbd_kstat->kstat->mode & S_IFMT) {
- 		case S_IFDIR:
- 			posix_info->Mode |= cpu_to_le32(POSIX_TYPE_DIR << POSIX_FILETYPE_SHIFT);
- 			break;
- 		case S_IFLNK:
- 			posix_info->Mode |= cpu_to_le32(POSIX_TYPE_SYMLINK << POSIX_FILETYPE_SHIFT);
- 			break;
- 		case S_IFCHR:
- 			posix_info->Mode |= cpu_to_le32(POSIX_TYPE_CHARDEV << POSIX_FILETYPE_SHIFT);
- 			break;
- 		case S_IFBLK:
- 			posix_info->Mode |= cpu_to_le32(POSIX_TYPE_BLKDEV << POSIX_FILETYPE_SHIFT);
- 			break;
- 		case S_IFIFO:
- 			posix_info->Mode |= cpu_to_le32(POSIX_TYPE_FIFO << POSIX_FILETYPE_SHIFT);
- 			break;
- 		case S_IFSOCK:
- 			posix_info->Mode |= cpu_to_le32(POSIX_TYPE_SOCKET << POSIX_FILETYPE_SHIFT);
- 		}
- 
  		posix_info->Inode = cpu_to_le64(ksmbd_kstat->kstat->ino);
  		posix_info->DosAttributes =
  			S_ISDIR(ksmbd_kstat->kstat->mode) ?
--- 3986,3991 ----
***************
*** 5197,5222 ****
  	file_info->AllocationSize = cpu_to_le64(stat.blocks << 9);
  	file_info->HardLinks = cpu_to_le32(stat.nlink);
  	file_info->Mode = cpu_to_le32(stat.mode & 0777);
- 	switch (stat.mode & S_IFMT) {
- 	case S_IFDIR:
- 		file_info->Mode |= cpu_to_le32(POSIX_TYPE_DIR << POSIX_FILETYPE_SHIFT);
- 		break;
- 	case S_IFLNK:
- 		file_info->Mode |= cpu_to_le32(POSIX_TYPE_SYMLINK << POSIX_FILETYPE_SHIFT);
- 		break;
- 	case S_IFCHR:
- 		file_info->Mode |= cpu_to_le32(POSIX_TYPE_CHARDEV << POSIX_FILETYPE_SHIFT);
- 		break;
- 	case S_IFBLK:
- 		file_info->Mode |= cpu_to_le32(POSIX_TYPE_BLKDEV << POSIX_FILETYPE_SHIFT);
- 		break;
- 	case S_IFIFO:
- 		file_info->Mode |= cpu_to_le32(POSIX_TYPE_FIFO << POSIX_FILETYPE_SHIFT);
- 		break;
- 	case S_IFSOCK:
- 		file_info->Mode |= cpu_to_le32(POSIX_TYPE_SOCKET << POSIX_FILETYPE_SHIFT);
- 	}
- 
  	file_info->DeviceId = cpu_to_le32(stat.rdev);
  
  	/*
--- 5174,5179 ----
diff -crB linux/fs/smb/server/smb2pdu.h ClockworkPi-linux/fs/smb/server/smb2pdu.h
*** linux/fs/smb/server/smb2pdu.h	2025-01-18 12:32:07.721818493 -0500
--- ClockworkPi-linux/fs/smb/server/smb2pdu.h	2025-01-18 12:30:25.195075914 -0500
***************
*** 500,513 ****
  	return buf + 4;
  }
  
- #define POSIX_TYPE_FILE		0
- #define POSIX_TYPE_DIR		1
- #define POSIX_TYPE_SYMLINK	2
- #define POSIX_TYPE_CHARDEV	3
- #define POSIX_TYPE_BLKDEV	4
- #define POSIX_TYPE_FIFO		5
- #define POSIX_TYPE_SOCKET	6
- 
- #define POSIX_FILETYPE_SHIFT	12
- 
  #endif	/* _SMB2PDU_H */
--- 500,503 ----
diff -crB linux/fs/smb/server/vfs.c ClockworkPi-linux/fs/smb/server/vfs.c
*** linux/fs/smb/server/vfs.c	2025-01-18 12:32:07.725818447 -0500
--- ClockworkPi-linux/fs/smb/server/vfs.c	2025-01-18 12:30:25.199075861 -0500
***************
*** 1259,1266 ****
  					      filepath,
  					      flags,
  					      path);
- 			if (!is_last)
- 				next[0] = '/';
  			if (err)
  				goto out2;
  			else if (is_last)
--- 1259,1264 ----
***************
*** 1268,1273 ****
--- 1266,1272 ----
  			path_put(parent_path);
  			*parent_path = *path;
  
+ 			next[0] = '/';
  			remain_len -= filename_len + 1;
  		}
  
diff -crB linux/.git/config ClockworkPi-linux/.git/config
*** linux/.git/config	2025-01-18 12:31:53.849979023 -0500
--- ClockworkPi-linux/.git/config	2025-01-18 12:30:11.551256473 -0500
***************
*** 4,10 ****
  	bare = false
  	logallrefupdates = true
  [remote "origin"]
! 	url = https://github.com/raspberrypi/linux
  	fetch = +refs/heads/rpi-6.6.y:refs/remotes/origin/rpi-6.6.y
  [branch "rpi-6.6.y"]
  	remote = origin
--- 4,10 ----
  	bare = false
  	logallrefupdates = true
  [remote "origin"]
! 	url = https://github.com/ak-rex/ClockworkPi-linux
  	fetch = +refs/heads/rpi-6.6.y:refs/remotes/origin/rpi-6.6.y
  [branch "rpi-6.6.y"]
  	remote = origin
Binary files linux/.git/index and ClockworkPi-linux/.git/index differ
diff -crB linux/.git/logs/HEAD ClockworkPi-linux/.git/logs/HEAD
*** linux/.git/logs/HEAD	2025-01-18 12:31:53.849979023 -0500
--- ClockworkPi-linux/.git/logs/HEAD	2025-01-18 12:30:11.547256526 -0500
***************
*** 1 ****
! 0000000000000000000000000000000000000000 545cb717f0ad24d3353ad6c1c19741970e8d9d50 Rex <rex@linux.com> 1737221513 -0500	clone: from https://github.com/raspberrypi/linux
--- 1 ----
! 0000000000000000000000000000000000000000 c5f9b7ef2c006fa7d15ba8a505a3d584c4d92903 Rex <rex@linux.com> 1737221411 -0500	clone: from https://github.com/ak-rex/ClockworkPi-linux
diff -crB linux/.git/logs/refs/heads/rpi-6.6.y ClockworkPi-linux/.git/logs/refs/heads/rpi-6.6.y
*** linux/.git/logs/refs/heads/rpi-6.6.y	2025-01-18 12:31:53.849979023 -0500
--- ClockworkPi-linux/.git/logs/refs/heads/rpi-6.6.y	2025-01-18 12:30:11.547256526 -0500
***************
*** 1 ****
! 0000000000000000000000000000000000000000 545cb717f0ad24d3353ad6c1c19741970e8d9d50 Rex <rex@linux.com> 1737221513 -0500	clone: from https://github.com/raspberrypi/linux
--- 1 ----
! 0000000000000000000000000000000000000000 c5f9b7ef2c006fa7d15ba8a505a3d584c4d92903 Rex <rex@linux.com> 1737221411 -0500	clone: from https://github.com/ak-rex/ClockworkPi-linux
diff -crB linux/.git/logs/refs/remotes/origin/HEAD ClockworkPi-linux/.git/logs/refs/remotes/origin/HEAD
*** linux/.git/logs/refs/remotes/origin/HEAD	2025-01-18 12:31:53.849979023 -0500
--- ClockworkPi-linux/.git/logs/refs/remotes/origin/HEAD	2025-01-18 12:30:11.547256526 -0500
***************
*** 1 ****
! 0000000000000000000000000000000000000000 545cb717f0ad24d3353ad6c1c19741970e8d9d50 Rex <rex@linux.com> 1737221513 -0500	clone: from https://github.com/raspberrypi/linux
--- 1 ----
! 0000000000000000000000000000000000000000 c5f9b7ef2c006fa7d15ba8a505a3d584c4d92903 Rex <rex@linux.com> 1737221411 -0500	clone: from https://github.com/ak-rex/ClockworkPi-linux
Only in ClockworkPi-linux/.git/objects/pack: pack-762f0887b475330a98a6bd1d69a957235b435efc.idx
Only in ClockworkPi-linux/.git/objects/pack: pack-762f0887b475330a98a6bd1d69a957235b435efc.pack
Only in linux/.git/objects/pack: pack-a2885c70bfe0b89e380a09f00c36de247b98782f.idx
Only in linux/.git/objects/pack: pack-a2885c70bfe0b89e380a09f00c36de247b98782f.pack
diff -crB linux/.git/packed-refs ClockworkPi-linux/.git/packed-refs
*** linux/.git/packed-refs	2025-01-18 12:31:53.845979070 -0500
--- ClockworkPi-linux/.git/packed-refs	2025-01-18 12:30:11.547256526 -0500
***************
*** 1,2 ****
  # pack-refs with: peeled fully-peeled sorted 
! 545cb717f0ad24d3353ad6c1c19741970e8d9d50 refs/remotes/origin/rpi-6.6.y
--- 1,2 ----
  # pack-refs with: peeled fully-peeled sorted 
! c5f9b7ef2c006fa7d15ba8a505a3d584c4d92903 refs/remotes/origin/rpi-6.6.y
diff -crB linux/.git/refs/heads/rpi-6.6.y ClockworkPi-linux/.git/refs/heads/rpi-6.6.y
*** linux/.git/refs/heads/rpi-6.6.y	2025-01-18 12:31:53.849979023 -0500
--- ClockworkPi-linux/.git/refs/heads/rpi-6.6.y	2025-01-18 12:30:11.547256526 -0500
***************
*** 1 ****
! 545cb717f0ad24d3353ad6c1c19741970e8d9d50
--- 1 ----
! c5f9b7ef2c006fa7d15ba8a505a3d584c4d92903
diff -crB linux/.git/shallow ClockworkPi-linux/.git/shallow
*** linux/.git/shallow	2025-01-18 12:30:40.186881304 -0500
--- ClockworkPi-linux/.git/shallow	2025-01-18 12:28:58.736279474 -0500
***************
*** 1 ****
! 545cb717f0ad24d3353ad6c1c19741970e8d9d50
--- 1 ----
! c5f9b7ef2c006fa7d15ba8a505a3d584c4d92903
diff -crB linux/include/linux/hugetlb.h ClockworkPi-linux/include/linux/hugetlb.h
*** linux/include/linux/hugetlb.h	2025-01-18 12:32:08.089814272 -0500
--- ClockworkPi-linux/include/linux/hugetlb.h	2025-01-18 12:30:25.499071929 -0500
***************
*** 1239,1245 ****
  }
  #endif
  
! #ifdef CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING
  static inline bool hugetlb_pmd_shared(pte_t *pte)
  {
  	return page_count(virt_to_page(pte)) > 1;
--- 1239,1245 ----
  }
  #endif
  
! #ifdef CONFIG_ARCH_WANT_HUGE_PMD_SHARE
  static inline bool hugetlb_pmd_shared(pte_t *pte)
  {
  	return page_count(virt_to_page(pte)) > 1;
***************
*** 1275,1281 ****
  static inline pte_t *
  hugetlb_walk(struct vm_area_struct *vma, unsigned long addr, unsigned long sz)
  {
! #if defined(CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING) && defined(CONFIG_LOCKDEP)
  	struct hugetlb_vma_lock *vma_lock = vma->vm_private_data;
  
  	/*
--- 1275,1282 ----
  static inline pte_t *
  hugetlb_walk(struct vm_area_struct *vma, unsigned long addr, unsigned long sz)
  {
! #if defined(CONFIG_HUGETLB_PAGE) && \
! 	defined(CONFIG_ARCH_WANT_HUGE_PMD_SHARE) && defined(CONFIG_LOCKDEP)
  	struct hugetlb_vma_lock *vma_lock = vma->vm_private_data;
  
  	/*
diff -crB linux/include/linux/mm.h ClockworkPi-linux/include/linux/mm.h
*** linux/include/linux/mm.h	2025-01-18 12:32:08.185813172 -0500
--- ClockworkPi-linux/include/linux/mm.h	2025-01-18 12:30:25.591070723 -0500
***************
*** 3031,3037 ****
  	if (!pmd_ptlock_init(ptdesc))
  		return false;
  	__folio_set_pgtable(folio);
- 	ptdesc_pmd_pts_init(ptdesc);
  	lruvec_stat_add_folio(folio, NR_PAGETABLE);
  	return true;
  }
--- 3031,3036 ----
diff -crB linux/include/linux/mm_types.h ClockworkPi-linux/include/linux/mm_types.h
*** linux/include/linux/mm_types.h	2025-01-18 12:32:08.189813126 -0500
--- ClockworkPi-linux/include/linux/mm_types.h	2025-01-18 12:30:25.591070723 -0500
***************
*** 398,409 ****
   * @pmd_huge_pte:     Protected by ptdesc->ptl, used for THPs.
   * @__page_mapping:   Aliases with page->mapping. Unused for page tables.
   * @pt_mm:            Used for x86 pgds.
!  * @pt_frag_refcount: For fragmented page table tracking. Powerpc only.
!  * @pt_share_count:   Used for HugeTLB PMD page table share count.
   * @_pt_pad_2:        Padding to ensure proper alignment.
   * @ptl:              Lock for the page table.
   * @__page_type:      Same as page->page_type. Unused for page tables.
!  * @_refcount:        Same as page refcount.
   * @pt_memcg_data:    Memcg data. Tracked for page tables here.
   *
   * This struct overlays struct page for now. Do not modify without a good
--- 398,408 ----
   * @pmd_huge_pte:     Protected by ptdesc->ptl, used for THPs.
   * @__page_mapping:   Aliases with page->mapping. Unused for page tables.
   * @pt_mm:            Used for x86 pgds.
!  * @pt_frag_refcount: For fragmented page table tracking. Powerpc and s390 only.
   * @_pt_pad_2:        Padding to ensure proper alignment.
   * @ptl:              Lock for the page table.
   * @__page_type:      Same as page->page_type. Unused for page tables.
!  * @_refcount:        Same as page refcount. Used for s390 page tables.
   * @pt_memcg_data:    Memcg data. Tracked for page tables here.
   *
   * This struct overlays struct page for now. Do not modify without a good
***************
*** 425,433 ****
  	union {
  		struct mm_struct *pt_mm;
  		atomic_t pt_frag_refcount;
- #ifdef CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING
- 		atomic_t pt_share_count;
- #endif
  	};
  
  	union {
--- 424,429 ----
***************
*** 472,503 ****
  	const struct page *:		(const struct ptdesc *)(p),	\
  	struct page *:			(struct ptdesc *)(p)))
  
- #ifdef CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING
- static inline void ptdesc_pmd_pts_init(struct ptdesc *ptdesc)
- {
- 	atomic_set(&ptdesc->pt_share_count, 0);
- }
- 
- static inline void ptdesc_pmd_pts_inc(struct ptdesc *ptdesc)
- {
- 	atomic_inc(&ptdesc->pt_share_count);
- }
- 
- static inline void ptdesc_pmd_pts_dec(struct ptdesc *ptdesc)
- {
- 	atomic_dec(&ptdesc->pt_share_count);
- }
- 
- static inline int ptdesc_pmd_pts_count(struct ptdesc *ptdesc)
- {
- 	return atomic_read(&ptdesc->pt_share_count);
- }
- #else
- static inline void ptdesc_pmd_pts_init(struct ptdesc *ptdesc)
- {
- }
- #endif
- 
  /*
   * Used for sizing the vmemmap region on some architectures
   */
--- 468,473 ----
diff -crB linux/include/linux/numa.h ClockworkPi-linux/include/linux/numa.h
*** linux/include/linux/numa.h	2025-01-18 12:32:08.213812851 -0500
--- ClockworkPi-linux/include/linux/numa.h	2025-01-18 12:30:25.615070409 -0500
***************
*** 15,25 ****
  #define	NUMA_NO_NODE	(-1)
  #define	NUMA_NO_MEMBLK	(-1)
  
- static inline bool numa_valid_node(int nid)
- {
- 	return nid >= 0 && nid < MAX_NUMNODES;
- }
- 
  /* optionally keep NUMA memory info available post init */
  #ifdef CONFIG_NUMA_KEEP_MEMINFO
  #define __initdata_or_meminfo
--- 15,20 ----
diff -crB linux/include/net/inet_connection_sock.h ClockworkPi-linux/include/net/inet_connection_sock.h
*** linux/include/net/inet_connection_sock.h	2025-01-18 12:32:08.837805700 -0500
--- ClockworkPi-linux/include/net/inet_connection_sock.h	2025-01-18 12:30:25.783068207 -0500
***************
*** 282,288 ****
  
  static inline int inet_csk_reqsk_queue_is_full(const struct sock *sk)
  {
! 	return inet_csk_reqsk_queue_len(sk) > READ_ONCE(sk->sk_max_ack_backlog);
  }
  
  bool inet_csk_reqsk_queue_drop(struct sock *sk, struct request_sock *req);
--- 282,288 ----
  
  static inline int inet_csk_reqsk_queue_is_full(const struct sock *sk)
  {
! 	return inet_csk_reqsk_queue_len(sk) >= sk->sk_max_ack_backlog;
  }
  
  bool inet_csk_reqsk_queue_drop(struct sock *sk, struct request_sock *req);
diff -crB linux/include/uapi/linux/media/raspberrypi/pisp_be_config.h ClockworkPi-linux/include/uapi/linux/media/raspberrypi/pisp_be_config.h
*** linux/include/uapi/linux/media/raspberrypi/pisp_be_config.h	2025-01-18 12:32:09.221801302 -0500
--- ClockworkPi-linux/include/uapi/linux/media/raspberrypi/pisp_be_config.h	2025-01-18 12:30:25.935066215 -0500
***************
*** 716,721 ****
--- 716,728 ----
  /**
   * struct pisp_be_config - RaspberryPi PiSP Back End Processing configuration
   *
+  * @input_buffer:		Input buffer addresses
+  * @tdn_input_buffer:		TDN input buffer addresses
+  * @stitch_input_buffer:	Stitch input buffer addresses
+  * @tdn_output_buffer:		TDN output buffer addresses
+  * @stitch_output_buffer:	Stitch output buffer addresses
+  * @output_buffer:		Output buffers addresses
+  * @hog_buffer:			HOG buffer addresses
   * @global:			Global PiSP configuration
   * @input_format:		Input image format
   * @decompress:			Decompress configuration
***************
*** 754,763 ****
   * @output_format:		Output format configuration
   * @hog:			HOG configuration
   * @axi:			AXI bus configuration
   */
  struct pisp_be_config {
! 	/* For backward compatibility */
! 	uint8_t pad0[112];
  	/* Processing configuration: */
  	struct pisp_be_global_config global;
  	struct pisp_image_format_config input_format;
--- 761,788 ----
   * @output_format:		Output format configuration
   * @hog:			HOG configuration
   * @axi:			AXI bus configuration
+  * @lsc_extra:			LSC extra info
+  * @cac_extra:			CAC extra info
+  * @downscale_extra:		Downscaler extra info
+  * @resample_extra:		Resample extra info
+  * @crop:			Crop configuration
+  * @hog_format:			HOG format info
+  * @dirty_flags_bayer:		Bayer enable dirty flags
+  *				(:c:type:`pisp_be_bayer_enable`)
+  * @dirty_flags_rgb:		RGB enable dirty flags
+  *				(:c:type:`pisp_be_rgb_enable`)
+  * @dirty_flags_extra:		Extra dirty flags
   */
  struct pisp_be_config {
! 	/* I/O configuration: */
! 	struct pisp_be_input_buffer_config input_buffer;
! 	struct pisp_be_tdn_input_buffer_config tdn_input_buffer;
! 	struct pisp_be_stitch_input_buffer_config stitch_input_buffer;
! 	struct pisp_be_tdn_output_buffer_config tdn_output_buffer;
! 	struct pisp_be_stitch_output_buffer_config stitch_output_buffer;
! 	struct pisp_be_output_buffer_config
! 				output_buffer[PISP_BACK_END_NUM_OUTPUTS];
! 	struct pisp_be_hog_buffer_config hog_buffer;
  	/* Processing configuration: */
  	struct pisp_be_global_config global;
  	struct pisp_image_format_config input_format;
***************
*** 798,805 ****
  				output_format[PISP_BACK_END_NUM_OUTPUTS];
  	struct pisp_be_hog_config hog;
  	struct pisp_be_axi_config axi;
! 	/* For backward compatibility */
! 	uint8_t pad1[84];
  } __attribute__((packed));
  
  /**
--- 823,839 ----
  				output_format[PISP_BACK_END_NUM_OUTPUTS];
  	struct pisp_be_hog_config hog;
  	struct pisp_be_axi_config axi;
! 	/* Non-register fields: */
! 	struct pisp_be_lsc_extra lsc_extra;
! 	struct pisp_be_cac_extra cac_extra;
! 	struct pisp_be_downscale_extra
! 				downscale_extra[PISP_BACK_END_NUM_OUTPUTS];
! 	struct pisp_be_resample_extra resample_extra[PISP_BACK_END_NUM_OUTPUTS];
! 	struct pisp_be_crop_config crop;
! 	struct pisp_image_format_config hog_format;
! 	__u32 dirty_flags_bayer; /* these use pisp_be_bayer_enable */
! 	__u32 dirty_flags_rgb; /* use pisp_be_rgb_enable */
! 	__u32 dirty_flags_extra; /* these use pisp_be_dirty_t */
  } __attribute__((packed));
  
  /**
diff -crB linux/include/ufs/ufshcd.h ClockworkPi-linux/include/ufs/ufshcd.h
*** linux/include/ufs/ufshcd.h	2025-01-18 12:32:09.345799883 -0500
--- ClockworkPi-linux/include/ufs/ufshcd.h	2025-01-18 12:30:25.999065376 -0500
***************
*** 324,329 ****
--- 324,330 ----
   * @config_scaling_param: called to configure clock scaling parameters
   * @program_key: program or evict an inline encryption key
   * @event_notify: called to notify important events
+  * @reinit_notify: called to notify reinit of UFSHCD during max gear switch
   * @mcq_config_resource: called to configure MCQ platform resources
   * @get_hba_mac: called to get vendor specific mac value, mandatory for mcq mode
   * @op_runtime_config: called to config Operation and runtime regs Pointers
***************
*** 368,373 ****
--- 369,375 ----
  			       const union ufs_crypto_cfg_entry *cfg, int slot);
  	void	(*event_notify)(struct ufs_hba *hba,
  				enum ufs_event_type evt, void *data);
+ 	void	(*reinit_notify)(struct ufs_hba *);
  	int	(*mcq_config_resource)(struct ufs_hba *hba);
  	int	(*get_hba_mac)(struct ufs_hba *hba);
  	int	(*op_runtime_config)(struct ufs_hba *hba);
diff -crB linux/io_uring/io_uring.c ClockworkPi-linux/io_uring/io_uring.c
*** linux/io_uring/io_uring.c	2025-01-18 12:32:09.385799425 -0500
--- ClockworkPi-linux/io_uring/io_uring.c	2025-01-18 12:30:26.019065114 -0500
***************
*** 537,549 ****
  	}
  }
  
- static void io_eventfd_free(struct rcu_head *rcu)
- {
- 	struct io_ev_fd *ev_fd = container_of(rcu, struct io_ev_fd, rcu);
- 
- 	eventfd_ctx_put(ev_fd->cq_ev_fd);
- 	kfree(ev_fd);
- }
  
  static void io_eventfd_ops(struct rcu_head *rcu)
  {
--- 537,542 ----
***************
*** 557,564 ****
  	 * ordering in a race but if references are 0 we know we have to free
  	 * it regardless.
  	 */
! 	if (atomic_dec_and_test(&ev_fd->refs))
! 		call_rcu(&ev_fd->rcu, io_eventfd_free);
  }
  
  static void io_eventfd_signal(struct io_ring_ctx *ctx)
--- 550,559 ----
  	 * ordering in a race but if references are 0 we know we have to free
  	 * it regardless.
  	 */
! 	if (atomic_dec_and_test(&ev_fd->refs)) {
! 		eventfd_ctx_put(ev_fd->cq_ev_fd);
! 		kfree(ev_fd);
! 	}
  }
  
  static void io_eventfd_signal(struct io_ring_ctx *ctx)
diff -crB linux/io_uring/timeout.c ClockworkPi-linux/io_uring/timeout.c
*** linux/io_uring/timeout.c	2025-01-18 12:32:09.393799334 -0500
--- ClockworkPi-linux/io_uring/timeout.c	2025-01-18 12:30:26.023065062 -0500
***************
*** 413,424 ****
  
  	timeout->off = 0; /* noseq */
  	data = req->async_data;
- 	data->ts = *ts;
- 
  	list_add_tail(&timeout->list, &ctx->timeout_list);
  	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
  	data->timer.function = io_timeout_fn;
! 	hrtimer_start(&data->timer, timespec64_to_ktime(data->ts), mode);
  	return 0;
  }
  
--- 413,422 ----
  
  	timeout->off = 0; /* noseq */
  	data = req->async_data;
  	list_add_tail(&timeout->list, &ctx->timeout_list);
  	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
  	data->timer.function = io_timeout_fn;
! 	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
  	return 0;
  }
  
diff -crB linux/kernel/workqueue.c ClockworkPi-linux/kernel/workqueue.c
*** linux/kernel/workqueue.c	2025-01-18 12:32:09.549797548 -0500
--- ClockworkPi-linux/kernel/workqueue.c	2025-01-18 12:30:26.167063177 -0500
***************
*** 2541,2547 ****
  	struct pool_workqueue *pwq = get_work_pwq(work);
  	struct worker_pool *pool = worker->pool;
  	unsigned long work_data;
- 	int lockdep_start_depth, rcu_start_depth;
  #ifdef CONFIG_LOCKDEP
  	/*
  	 * It is permissible to free the struct work_struct from
--- 2541,2546 ----
***************
*** 2604,2611 ****
  	pwq->stats[PWQ_STAT_STARTED]++;
  	raw_spin_unlock_irq(&pool->lock);
  
- 	rcu_start_depth = rcu_preempt_depth();
- 	lockdep_start_depth = lockdep_depth(current);
  	lock_map_acquire(&pwq->wq->lockdep_map);
  	lock_map_acquire(&lockdep_map);
  	/*
--- 2603,2608 ----
***************
*** 2641,2654 ****
  	lock_map_release(&lockdep_map);
  	lock_map_release(&pwq->wq->lockdep_map);
  
! 	if (unlikely((worker->task && in_atomic()) ||
! 		     lockdep_depth(current) != lockdep_start_depth ||
! 		     rcu_preempt_depth() != rcu_start_depth)) {
! 		pr_err("BUG: workqueue leaked atomic, lock or RCU: %s[%d]\n"
! 		       "     preempt=0x%08x lock=%d->%d RCU=%d->%d workfn=%ps\n",
! 		       current->comm, task_pid_nr(current), preempt_count(),
! 		       lockdep_start_depth, lockdep_depth(current),
! 		       rcu_start_depth, rcu_preempt_depth(),
  		       worker->current_func);
  		debug_show_held_locks(current);
  		dump_stack();
--- 2638,2647 ----
  	lock_map_release(&lockdep_map);
  	lock_map_release(&pwq->wq->lockdep_map);
  
! 	if (unlikely(in_atomic() || lockdep_depth(current) > 0)) {
! 		pr_err("BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\n"
! 		       "     last function: %ps\n",
! 		       current->comm, preempt_count(), task_pid_nr(current),
  		       worker->current_func);
  		debug_show_held_locks(current);
  		dump_stack();
***************
*** 2947,2973 ****
   * check_flush_dependency - check for flush dependency sanity
   * @target_wq: workqueue being flushed
   * @target_work: work item being flushed (NULL for workqueue flushes)
-  * @from_cancel: are we called from the work cancel path
   *
   * %current is trying to flush the whole @target_wq or @target_work on it.
!  * If this is not the cancel path (which implies work being flushed is either
!  * already running, or will not be at all), check if @target_wq doesn't have
!  * %WQ_MEM_RECLAIM and verify that %current is not reclaiming memory or running
!  * on a workqueue which doesn't have %WQ_MEM_RECLAIM as that can break forward-
!  * progress guarantee leading to a deadlock.
   */
  static void check_flush_dependency(struct workqueue_struct *target_wq,
! 				   struct work_struct *target_work,
! 				   bool from_cancel)
  {
! 	work_func_t target_func;
  	struct worker *worker;
  
! 	if (from_cancel || target_wq->flags & WQ_MEM_RECLAIM)
  		return;
  
  	worker = current_wq_worker();
- 	target_func = target_work ? target_work->func : NULL;
  
  	WARN_ONCE(current->flags & PF_MEMALLOC,
  		  "workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps",
--- 2940,2962 ----
   * check_flush_dependency - check for flush dependency sanity
   * @target_wq: workqueue being flushed
   * @target_work: work item being flushed (NULL for workqueue flushes)
   *
   * %current is trying to flush the whole @target_wq or @target_work on it.
!  * If @target_wq doesn't have %WQ_MEM_RECLAIM, verify that %current is not
!  * reclaiming memory or running on a workqueue which doesn't have
!  * %WQ_MEM_RECLAIM as that can break forward-progress guarantee leading to
!  * a deadlock.
   */
  static void check_flush_dependency(struct workqueue_struct *target_wq,
! 				   struct work_struct *target_work)
  {
! 	work_func_t target_func = target_work ? target_work->func : NULL;
  	struct worker *worker;
  
! 	if (target_wq->flags & WQ_MEM_RECLAIM)
  		return;
  
  	worker = current_wq_worker();
  
  	WARN_ONCE(current->flags & PF_MEMALLOC,
  		  "workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps",
***************
*** 3133,3151 ****
  	return wait;
  }
  
- static void touch_wq_lockdep_map(struct workqueue_struct *wq)
- {
- 	lock_map_acquire(&wq->lockdep_map);
- 	lock_map_release(&wq->lockdep_map);
- }
- 
- static void touch_work_lockdep_map(struct work_struct *work,
- 				   struct workqueue_struct *wq)
- {
- 	lock_map_acquire(&work->lockdep_map);
- 	lock_map_release(&work->lockdep_map);
- }
- 
  /**
   * __flush_workqueue - ensure that any scheduled work has run to completion.
   * @wq: workqueue to flush
--- 3122,3127 ----
***************
*** 3165,3171 ****
  	if (WARN_ON(!wq_online))
  		return;
  
! 	touch_wq_lockdep_map(wq);
  
  	mutex_lock(&wq->mutex);
  
--- 3141,3148 ----
  	if (WARN_ON(!wq_online))
  		return;
  
! 	lock_map_acquire(&wq->lockdep_map);
! 	lock_map_release(&wq->lockdep_map);
  
  	mutex_lock(&wq->mutex);
  
***************
*** 3212,3218 ****
  		list_add_tail(&this_flusher.list, &wq->flusher_overflow);
  	}
  
! 	check_flush_dependency(wq, NULL, false);
  
  	mutex_unlock(&wq->mutex);
  
--- 3189,3195 ----
  		list_add_tail(&this_flusher.list, &wq->flusher_overflow);
  	}
  
! 	check_flush_dependency(wq, NULL);
  
  	mutex_unlock(&wq->mutex);
  
***************
*** 3364,3370 ****
  	struct worker *worker = NULL;
  	struct worker_pool *pool;
  	struct pool_workqueue *pwq;
- 	struct workqueue_struct *wq;
  
  	might_sleep();
  
--- 3341,3346 ----
***************
*** 3388,3401 ****
  		pwq = worker->current_pwq;
  	}
  
! 	wq = pwq->wq;
! 	check_flush_dependency(wq, work, from_cancel);
  
  	insert_wq_barrier(pwq, barr, work, worker);
  	raw_spin_unlock_irq(&pool->lock);
  
- 	touch_work_lockdep_map(work, wq);
- 
  	/*
  	 * Force a lock recursion deadlock when using flush_work() inside a
  	 * single-threaded or rescuer equipped workqueue.
--- 3364,3374 ----
  		pwq = worker->current_pwq;
  	}
  
! 	check_flush_dependency(pwq->wq, work);
  
  	insert_wq_barrier(pwq, barr, work, worker);
  	raw_spin_unlock_irq(&pool->lock);
  
  	/*
  	 * Force a lock recursion deadlock when using flush_work() inside a
  	 * single-threaded or rescuer equipped workqueue.
***************
*** 3405,3413 ****
  	 * workqueues the deadlock happens when the rescuer stalls, blocking
  	 * forward progress.
  	 */
! 	if (!from_cancel && (wq->saved_max_active == 1 || wq->rescuer))
! 		touch_wq_lockdep_map(wq);
! 
  	rcu_read_unlock();
  	return true;
  already_gone:
--- 3378,3388 ----
  	 * workqueues the deadlock happens when the rescuer stalls, blocking
  	 * forward progress.
  	 */
! 	if (!from_cancel &&
! 	    (pwq->wq->saved_max_active == 1 || pwq->wq->rescuer)) {
! 		lock_map_acquire(&pwq->wq->lockdep_map);
! 		lock_map_release(&pwq->wq->lockdep_map);
! 	}
  	rcu_read_unlock();
  	return true;
  already_gone:
***************
*** 3426,3431 ****
--- 3401,3409 ----
  	if (WARN_ON(!work->func))
  		return false;
  
+ 	lock_map_acquire(&work->lockdep_map);
+ 	lock_map_release(&work->lockdep_map);
+ 
  	if (start_flush_work(work, &barr, from_cancel)) {
  		wait_for_completion(&barr.done);
  		destroy_work_on_stack(&barr.work);
diff -crB linux/Makefile ClockworkPi-linux/Makefile
*** linux/Makefile	2025-01-18 12:31:55.261962554 -0500
--- ClockworkPi-linux/Makefile	2025-01-18 12:30:12.779240085 -0500
***************
*** 1,7 ****
  # SPDX-License-Identifier: GPL-2.0
  VERSION = 6
  PATCHLEVEL = 6
! SUBLEVEL = 72
  EXTRAVERSION =
  NAME = Pingun Aangedreven
  
--- 1,7 ----
  # SPDX-License-Identifier: GPL-2.0
  VERSION = 6
  PATCHLEVEL = 6
! SUBLEVEL = 70
  EXTRAVERSION =
  NAME = Pingun Aangedreven
  
diff -crB linux/mm/hugetlb.c ClockworkPi-linux/mm/hugetlb.c
*** linux/mm/hugetlb.c	2025-01-18 12:32:09.701795809 -0500
--- ClockworkPi-linux/mm/hugetlb.c	2025-01-18 12:30:26.271061816 -0500
***************
*** 6907,6913 ****
  	return 0;
  }
  
! #ifdef CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING
  static unsigned long page_table_shareable(struct vm_area_struct *svma,
  				struct vm_area_struct *vma,
  				unsigned long addr, pgoff_t idx)
--- 6907,6913 ----
  	return 0;
  }
  
! #ifdef CONFIG_ARCH_WANT_HUGE_PMD_SHARE
  static unsigned long page_table_shareable(struct vm_area_struct *svma,
  				struct vm_area_struct *vma,
  				unsigned long addr, pgoff_t idx)
***************
*** 7014,7020 ****
  			spte = hugetlb_walk(svma, saddr,
  					    vma_mmu_pagesize(svma));
  			if (spte) {
! 				ptdesc_pmd_pts_inc(virt_to_ptdesc(spte));
  				break;
  			}
  		}
--- 7014,7020 ----
  			spte = hugetlb_walk(svma, saddr,
  					    vma_mmu_pagesize(svma));
  			if (spte) {
! 				get_page(virt_to_page(spte));
  				break;
  			}
  		}
***************
*** 7029,7035 ****
  				(pmd_t *)((unsigned long)spte & PAGE_MASK));
  		mm_inc_nr_pmds(mm);
  	} else {
! 		ptdesc_pmd_pts_dec(virt_to_ptdesc(spte));
  	}
  	spin_unlock(&mm->page_table_lock);
  out:
--- 7029,7035 ----
  				(pmd_t *)((unsigned long)spte & PAGE_MASK));
  		mm_inc_nr_pmds(mm);
  	} else {
! 		put_page(virt_to_page(spte));
  	}
  	spin_unlock(&mm->page_table_lock);
  out:
***************
*** 7041,7046 ****
--- 7041,7050 ----
  /*
   * unmap huge page backed by shared pte.
   *
+  * Hugetlb pte page is ref counted at the time of mapping.  If pte is shared
+  * indicated by page_count > 1, unmap is achieved by clearing pud and
+  * decrementing the ref count. If count == 1, the pte page is not shared.
+  *
   * Called with page table lock held.
   *
   * returns: 1 successfully unmapped a shared pte page
***************
*** 7049,7073 ****
  int huge_pmd_unshare(struct mm_struct *mm, struct vm_area_struct *vma,
  					unsigned long addr, pte_t *ptep)
  {
- 	unsigned long sz = huge_page_size(hstate_vma(vma));
  	pgd_t *pgd = pgd_offset(mm, addr);
  	p4d_t *p4d = p4d_offset(pgd, addr);
  	pud_t *pud = pud_offset(p4d, addr);
  
  	i_mmap_assert_write_locked(vma->vm_file->f_mapping);
  	hugetlb_vma_assert_locked(vma);
! 	if (sz != PMD_SIZE)
! 		return 0;
! 	if (!ptdesc_pmd_pts_count(virt_to_ptdesc(ptep)))
  		return 0;
  
  	pud_clear(pud);
! 	ptdesc_pmd_pts_dec(virt_to_ptdesc(ptep));
  	mm_dec_nr_pmds(mm);
  	return 1;
  }
  
! #else /* !CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING */
  
  pte_t *huge_pmd_share(struct mm_struct *mm, struct vm_area_struct *vma,
  		      unsigned long addr, pud_t *pud)
--- 7053,7075 ----
  int huge_pmd_unshare(struct mm_struct *mm, struct vm_area_struct *vma,
  					unsigned long addr, pte_t *ptep)
  {
  	pgd_t *pgd = pgd_offset(mm, addr);
  	p4d_t *p4d = p4d_offset(pgd, addr);
  	pud_t *pud = pud_offset(p4d, addr);
  
  	i_mmap_assert_write_locked(vma->vm_file->f_mapping);
  	hugetlb_vma_assert_locked(vma);
! 	BUG_ON(page_count(virt_to_page(ptep)) == 0);
! 	if (page_count(virt_to_page(ptep)) == 1)
  		return 0;
  
  	pud_clear(pud);
! 	put_page(virt_to_page(ptep));
  	mm_dec_nr_pmds(mm);
  	return 1;
  }
  
! #else /* !CONFIG_ARCH_WANT_HUGE_PMD_SHARE */
  
  pte_t *huge_pmd_share(struct mm_struct *mm, struct vm_area_struct *vma,
  		      unsigned long addr, pud_t *pud)
***************
*** 7090,7096 ****
  {
  	return false;
  }
! #endif /* CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING */
  
  #ifdef CONFIG_ARCH_WANT_GENERAL_HUGETLB
  pte_t *huge_pte_alloc(struct mm_struct *mm, struct vm_area_struct *vma,
--- 7092,7098 ----
  {
  	return false;
  }
! #endif /* CONFIG_ARCH_WANT_HUGE_PMD_SHARE */
  
  #ifdef CONFIG_ARCH_WANT_GENERAL_HUGETLB
  pte_t *huge_pte_alloc(struct mm_struct *mm, struct vm_area_struct *vma,
***************
*** 7188,7194 ****
  /* See description above.  Architectures can provide their own version. */
  __weak unsigned long hugetlb_mask_last_page(struct hstate *h)
  {
! #ifdef CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING
  	if (huge_page_size(h) == PMD_SIZE)
  		return PUD_SIZE - PMD_SIZE;
  #endif
--- 7190,7196 ----
  /* See description above.  Architectures can provide their own version. */
  __weak unsigned long hugetlb_mask_last_page(struct hstate *h)
  {
! #ifdef CONFIG_ARCH_WANT_HUGE_PMD_SHARE
  	if (huge_page_size(h) == PMD_SIZE)
  		return PUD_SIZE - PMD_SIZE;
  #endif
diff -crB linux/mm/memblock.c ClockworkPi-linux/mm/memblock.c
*** linux/mm/memblock.c	2025-01-18 12:32:09.709795717 -0500
--- ClockworkPi-linux/mm/memblock.c	2025-01-18 12:30:26.283061659 -0500
***************
*** 754,760 ****
  
  	/* calculate lose page */
  	for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {
! 		if (!numa_valid_node(nid))
  			nr_pages += end_pfn - start_pfn;
  	}
  
--- 754,760 ----
  
  	/* calculate lose page */
  	for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {
! 		if (nid == NUMA_NO_NODE)
  			nr_pages += end_pfn - start_pfn;
  	}
  
***************
*** 1043,1049 ****
  		return false;
  
  	/* only memory regions are associated with nodes, check it */
! 	if (numa_valid_node(nid) && nid != m_nid)
  		return true;
  
  	/* skip hotpluggable memory regions if needed */
--- 1043,1049 ----
  		return false;
  
  	/* only memory regions are associated with nodes, check it */
! 	if (nid != NUMA_NO_NODE && nid != m_nid)
  		return true;
  
  	/* skip hotpluggable memory regions if needed */
***************
*** 1100,1105 ****
--- 1100,1109 ----
  	int idx_a = *idx & 0xffffffff;
  	int idx_b = *idx >> 32;
  
+ 	if (WARN_ONCE(nid == MAX_NUMNODES,
+ 	"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\n"))
+ 		nid = NUMA_NO_NODE;
+ 
  	for (; idx_a < type_a->cnt; idx_a++) {
  		struct memblock_region *m = &type_a->regions[idx_a];
  
***************
*** 1193,1198 ****
--- 1197,1205 ----
  	int idx_a = *idx & 0xffffffff;
  	int idx_b = *idx >> 32;
  
+ 	if (WARN_ONCE(nid == MAX_NUMNODES, "Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\n"))
+ 		nid = NUMA_NO_NODE;
+ 
  	if (*idx == (u64)ULLONG_MAX) {
  		idx_a = type_a->cnt - 1;
  		if (type_b != NULL)
***************
*** 1278,1284 ****
  
  		if (PFN_UP(r->base) >= PFN_DOWN(r->base + r->size))
  			continue;
! 		if (!numa_valid_node(nid) || nid == r_nid)
  			break;
  	}
  	if (*idx >= type->cnt) {
--- 1285,1291 ----
  
  		if (PFN_UP(r->base) >= PFN_DOWN(r->base + r->size))
  			continue;
! 		if (nid == MAX_NUMNODES || nid == r_nid)
  			break;
  	}
  	if (*idx >= type->cnt) {
***************
*** 1423,1428 ****
--- 1430,1438 ----
  	enum memblock_flags flags = choose_memblock_flags();
  	phys_addr_t found;
  
+ 	if (WARN_ONCE(nid == MAX_NUMNODES, "Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\n"))
+ 		nid = NUMA_NO_NODE;
+ 
  	if (!align) {
  		/* Can't use WARNs this early in boot on powerpc */
  		dump_stack();
***************
*** 1435,1441 ****
  	if (found && !memblock_reserve(found, size))
  		goto done;
  
! 	if (numa_valid_node(nid) && !exact_nid) {
  		found = memblock_find_in_range_node(size, align, start,
  						    end, NUMA_NO_NODE,
  						    flags);
--- 1445,1451 ----
  	if (found && !memblock_reserve(found, size))
  		goto done;
  
! 	if (nid != NUMA_NO_NODE && !exact_nid) {
  		found = memblock_find_in_range_node(size, align, start,
  						    end, NUMA_NO_NODE,
  						    flags);
***************
*** 1955,1961 ****
  		end = base + size - 1;
  		flags = rgn->flags;
  #ifdef CONFIG_NUMA
! 		if (numa_valid_node(memblock_get_region_node(rgn)))
  			snprintf(nid_buf, sizeof(nid_buf), " on node %d",
  				 memblock_get_region_node(rgn));
  #endif
--- 1965,1971 ----
  		end = base + size - 1;
  		flags = rgn->flags;
  #ifdef CONFIG_NUMA
! 		if (memblock_get_region_node(rgn) != MAX_NUMNODES)
  			snprintf(nid_buf, sizeof(nid_buf), " on node %d",
  				 memblock_get_region_node(rgn));
  #endif
***************
*** 2144,2150 ****
  		start = region->base;
  		end = start + region->size;
  
! 		if (!numa_valid_node(nid))
  			nid = early_pfn_to_nid(PFN_DOWN(start));
  
  		reserve_bootmem_region(start, end, nid);
--- 2154,2160 ----
  		start = region->base;
  		end = start + region->size;
  
! 		if (nid == NUMA_NO_NODE || nid >= MAX_NUMNODES)
  			nid = early_pfn_to_nid(PFN_DOWN(start));
  
  		reserve_bootmem_region(start, end, nid);
***************
*** 2233,2239 ****
  
  		seq_printf(m, "%4d: ", i);
  		seq_printf(m, "%pa..%pa ", &reg->base, &end);
! 		if (numa_valid_node(nid))
  			seq_printf(m, "%4d ", nid);
  		else
  			seq_printf(m, "%4c ", 'x');
--- 2243,2249 ----
  
  		seq_printf(m, "%4d: ", i);
  		seq_printf(m, "%pa..%pa ", &reg->base, &end);
! 		if (nid != MAX_NUMNODES)
  			seq_printf(m, "%4d ", nid);
  		else
  			seq_printf(m, "%4c ", 'x');
diff -crB linux/net/802/psnap.c ClockworkPi-linux/net/802/psnap.c
*** linux/net/802/psnap.c	2025-01-18 12:32:09.749795259 -0500
--- ClockworkPi-linux/net/802/psnap.c	2025-01-18 12:30:26.319061187 -0500
***************
*** 55,65 ****
  		goto drop;
  
  	rcu_read_lock();
! 	proto = find_snap_client(skb->data);
  	if (proto) {
  		/* Pass the frame on. */
  		skb_pull_rcsum(skb, 5);
- 		skb_reset_transport_header(skb);
  		rc = proto->rcvfunc(skb, dev, &snap_packet_type, orig_dev);
  	}
  	rcu_read_unlock();
--- 55,65 ----
  		goto drop;
  
  	rcu_read_lock();
! 	proto = find_snap_client(skb_transport_header(skb));
  	if (proto) {
  		/* Pass the frame on. */
+ 		skb->transport_header += 5;
  		skb_pull_rcsum(skb, 5);
  		rc = proto->rcvfunc(skb, dev, &snap_packet_type, orig_dev);
  	}
  	rcu_read_unlock();
diff -crB linux/net/bluetooth/hci_sync.c ClockworkPi-linux/net/bluetooth/hci_sync.c
*** linux/net/bluetooth/hci_sync.c	2025-01-18 12:32:09.777794939 -0500
--- ClockworkPi-linux/net/bluetooth/hci_sync.c	2025-01-18 12:30:26.347060821 -0500
***************
*** 1049,1057 ****
  
  static int hci_set_random_addr_sync(struct hci_dev *hdev, bdaddr_t *rpa)
  {
! 	/* If a random_addr has been set we're advertising or initiating an LE
! 	 * connection we can't go ahead and change the random address at this
! 	 * time. This is because the eventual initiator address used for the
  	 * subsequently created connection will be undefined (some
  	 * controllers use the new address and others the one we had
  	 * when the operation started).
--- 1049,1057 ----
  
  static int hci_set_random_addr_sync(struct hci_dev *hdev, bdaddr_t *rpa)
  {
! 	/* If we're advertising or initiating an LE connection we can't
! 	 * go ahead and change the random address at this time. This is
! 	 * because the eventual initiator address used for the
  	 * subsequently created connection will be undefined (some
  	 * controllers use the new address and others the one we had
  	 * when the operation started).
***************
*** 1059,1067 ****
  	 * In this kind of scenario skip the update and let the random
  	 * address be updated at the next cycle.
  	 */
! 	if (bacmp(&hdev->random_addr, BDADDR_ANY) &&
! 	    (hci_dev_test_flag(hdev, HCI_LE_ADV) ||
! 	    hci_lookup_le_connect(hdev))) {
  		bt_dev_dbg(hdev, "Deferring random address update");
  		hci_dev_set_flag(hdev, HCI_RPA_EXPIRED);
  		return 0;
--- 1059,1066 ----
  	 * In this kind of scenario skip the update and let the random
  	 * address be updated at the next cycle.
  	 */
! 	if (hci_dev_test_flag(hdev, HCI_LE_ADV) ||
! 	    hci_lookup_le_connect(hdev)) {
  		bt_dev_dbg(hdev, "Deferring random address update");
  		hci_dev_set_flag(hdev, HCI_RPA_EXPIRED);
  		return 0;
diff -crB linux/net/bluetooth/mgmt.c ClockworkPi-linux/net/bluetooth/mgmt.c
*** linux/net/bluetooth/mgmt.c	2025-01-18 12:32:09.785794847 -0500
--- ClockworkPi-linux/net/bluetooth/mgmt.c	2025-01-18 12:30:26.355060716 -0500
***************
*** 7589,7612 ****
  	mgmt_event(MGMT_EV_DEVICE_ADDED, hdev, &ev, sizeof(ev), sk);
  }
  
- static void add_device_complete(struct hci_dev *hdev, void *data, int err)
- {
- 	struct mgmt_pending_cmd *cmd = data;
- 	struct mgmt_cp_add_device *cp = cmd->param;
- 
- 	if (!err) {
- 		device_added(cmd->sk, hdev, &cp->addr.bdaddr, cp->addr.type,
- 			     cp->action);
- 		device_flags_changed(NULL, hdev, &cp->addr.bdaddr,
- 				     cp->addr.type, hdev->conn_flags,
- 				     PTR_UINT(cmd->user_data));
- 	}
- 
- 	mgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_ADD_DEVICE,
- 			  mgmt_status(err), &cp->addr, sizeof(cp->addr));
- 	mgmt_pending_free(cmd);
- }
- 
  static int add_device_sync(struct hci_dev *hdev, void *data)
  {
  	return hci_update_passive_scan_sync(hdev);
--- 7589,7594 ----
***************
*** 7615,7621 ****
  static int add_device(struct sock *sk, struct hci_dev *hdev,
  		      void *data, u16 len)
  {
- 	struct mgmt_pending_cmd *cmd;
  	struct mgmt_cp_add_device *cp = data;
  	u8 auto_conn, addr_type;
  	struct hci_conn_params *params;
--- 7597,7602 ----
***************
*** 7696,7719 ****
  			current_flags = params->flags;
  	}
  
! 	cmd = mgmt_pending_new(sk, MGMT_OP_ADD_DEVICE, hdev, data, len);
! 	if (!cmd) {
! 		err = -ENOMEM;
  		goto unlock;
- 	}
- 
- 	cmd->user_data = UINT_PTR(current_flags);
- 
- 	err = hci_cmd_sync_queue(hdev, add_device_sync, cmd,
- 				 add_device_complete);
- 	if (err < 0) {
- 		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,
- 					MGMT_STATUS_FAILED, &cp->addr,
- 					sizeof(cp->addr));
- 		mgmt_pending_free(cmd);
- 	}
- 
- 	goto unlock;
  
  added:
  	device_added(sk, hdev, &cp->addr.bdaddr, cp->addr.type, cp->action);
--- 7677,7685 ----
  			current_flags = params->flags;
  	}
  
! 	err = hci_cmd_sync_queue(hdev, add_device_sync, NULL, NULL);
! 	if (err < 0)
  		goto unlock;
  
  added:
  	device_added(sk, hdev, &cp->addr.bdaddr, cp->addr.type, cp->action);
diff -crB linux/net/core/link_watch.c ClockworkPi-linux/net/core/link_watch.c
*** linux/net/core/link_watch.c	2025-01-18 12:32:09.825794389 -0500
--- ClockworkPi-linux/net/core/link_watch.c	2025-01-18 12:30:26.395060193 -0500
***************
*** 42,59 ****
  	 * first check whether lower is indeed the source of its down state.
  	 */
  	if (!netif_carrier_ok(dev)) {
  		struct net_device *peer;
- 		int iflink;
  
  		/* If called from netdev_run_todo()/linkwatch_sync_dev(),
  		 * dev_net(dev) can be already freed, and RTNL is not held.
  		 */
! 		if (dev->reg_state <= NETREG_REGISTERED)
! 			iflink = dev_get_iflink(dev);
! 		else
! 			iflink = dev->ifindex;
! 
! 		if (iflink == dev->ifindex)
  			return IF_OPER_DOWN;
  
  		ASSERT_RTNL();
--- 42,55 ----
  	 * first check whether lower is indeed the source of its down state.
  	 */
  	if (!netif_carrier_ok(dev)) {
+ 		int iflink = dev_get_iflink(dev);
  		struct net_device *peer;
  
  		/* If called from netdev_run_todo()/linkwatch_sync_dev(),
  		 * dev_net(dev) can be already freed, and RTNL is not held.
  		 */
! 		if (dev->reg_state == NETREG_UNREGISTERED ||
! 		    iflink == dev->ifindex)
  			return IF_OPER_DOWN;
  
  		ASSERT_RTNL();
diff -crB linux/net/ipv4/tcp_ipv4.c ClockworkPi-linux/net/ipv4/tcp_ipv4.c
*** linux/net/ipv4/tcp_ipv4.c	2025-01-18 12:32:09.889793657 -0500
--- ClockworkPi-linux/net/ipv4/tcp_ipv4.c	2025-01-18 12:30:26.459059355 -0500
***************
*** 832,838 ****
  	sock_net_set(ctl_sk, net);
  	if (sk) {
  		ctl_sk->sk_mark = (sk->sk_state == TCP_TIME_WAIT) ?
! 				   inet_twsk(sk)->tw_mark : READ_ONCE(sk->sk_mark);
  		ctl_sk->sk_priority = (sk->sk_state == TCP_TIME_WAIT) ?
  				   inet_twsk(sk)->tw_priority : sk->sk_priority;
  		transmit_time = tcp_transmit_time(sk);
--- 832,838 ----
  	sock_net_set(ctl_sk, net);
  	if (sk) {
  		ctl_sk->sk_mark = (sk->sk_state == TCP_TIME_WAIT) ?
! 				   inet_twsk(sk)->tw_mark : sk->sk_mark;
  		ctl_sk->sk_priority = (sk->sk_state == TCP_TIME_WAIT) ?
  				   inet_twsk(sk)->tw_priority : sk->sk_priority;
  		transmit_time = tcp_transmit_time(sk);
diff -crB linux/net/mptcp/ctrl.c ClockworkPi-linux/net/mptcp/ctrl.c
*** linux/net/mptcp/ctrl.c	2025-01-18 12:32:09.957792879 -0500
--- ClockworkPi-linux/net/mptcp/ctrl.c	2025-01-18 12:30:26.527058465 -0500
***************
*** 87,101 ****
  }
  
  #ifdef CONFIG_SYSCTL
! static int mptcp_set_scheduler(char *scheduler, const char *name)
  {
  	struct mptcp_sched_ops *sched;
  	int ret = 0;
  
  	rcu_read_lock();
  	sched = mptcp_sched_find(name);
  	if (sched)
! 		strscpy(scheduler, name, MPTCP_SCHED_NAME_MAX);
  	else
  		ret = -ENOENT;
  	rcu_read_unlock();
--- 87,102 ----
  }
  
  #ifdef CONFIG_SYSCTL
! static int mptcp_set_scheduler(const struct net *net, const char *name)
  {
+ 	struct mptcp_pernet *pernet = mptcp_get_pernet(net);
  	struct mptcp_sched_ops *sched;
  	int ret = 0;
  
  	rcu_read_lock();
  	sched = mptcp_sched_find(name);
  	if (sched)
! 		strscpy(pernet->scheduler, name, MPTCP_SCHED_NAME_MAX);
  	else
  		ret = -ENOENT;
  	rcu_read_unlock();
***************
*** 106,112 ****
  static int proc_scheduler(struct ctl_table *ctl, int write,
  			  void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	char (*scheduler)[MPTCP_SCHED_NAME_MAX] = ctl->data;
  	char val[MPTCP_SCHED_NAME_MAX];
  	struct ctl_table tbl = {
  		.data = val,
--- 107,113 ----
  static int proc_scheduler(struct ctl_table *ctl, int write,
  			  void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	const struct net *net = current->nsproxy->net_ns;
  	char val[MPTCP_SCHED_NAME_MAX];
  	struct ctl_table tbl = {
  		.data = val,
***************
*** 114,124 ****
  	};
  	int ret;
  
! 	strscpy(val, *scheduler, MPTCP_SCHED_NAME_MAX);
  
  	ret = proc_dostring(&tbl, write, buffer, lenp, ppos);
  	if (write && ret == 0)
! 		ret = mptcp_set_scheduler(*scheduler, val);
  
  	return ret;
  }
--- 115,125 ----
  	};
  	int ret;
  
! 	strscpy(val, mptcp_get_scheduler(net), MPTCP_SCHED_NAME_MAX);
  
  	ret = proc_dostring(&tbl, write, buffer, lenp, ppos);
  	if (write && ret == 0)
! 		ret = mptcp_set_scheduler(net, val);
  
  	return ret;
  }
diff -crB linux/net/netfilter/nf_conntrack_core.c ClockworkPi-linux/net/netfilter/nf_conntrack_core.c
*** linux/net/netfilter/nf_conntrack_core.c	2025-01-18 12:32:10.561785974 -0500
--- ClockworkPi-linux/net/netfilter/nf_conntrack_core.c	2025-01-18 12:30:26.547058203 -0500
***************
*** 2568,2582 ****
  	struct hlist_nulls_head *hash;
  	unsigned int nr_slots, i;
  
! 	if (*sizep > (INT_MAX / sizeof(struct hlist_nulls_head)))
  		return NULL;
  
  	BUILD_BUG_ON(sizeof(struct hlist_nulls_head) != sizeof(struct hlist_head));
  	nr_slots = *sizep = roundup(*sizep, PAGE_SIZE / sizeof(struct hlist_nulls_head));
  
- 	if (nr_slots > (INT_MAX / sizeof(struct hlist_nulls_head)))
- 		return NULL;
- 
  	hash = kvcalloc(nr_slots, sizeof(struct hlist_nulls_head), GFP_KERNEL);
  
  	if (hash && nulls)
--- 2568,2579 ----
  	struct hlist_nulls_head *hash;
  	unsigned int nr_slots, i;
  
! 	if (*sizep > (UINT_MAX / sizeof(struct hlist_nulls_head)))
  		return NULL;
  
  	BUILD_BUG_ON(sizeof(struct hlist_nulls_head) != sizeof(struct hlist_head));
  	nr_slots = *sizep = roundup(*sizep, PAGE_SIZE / sizeof(struct hlist_nulls_head));
  
  	hash = kvcalloc(nr_slots, sizeof(struct hlist_nulls_head), GFP_KERNEL);
  
  	if (hash && nulls)
diff -crB linux/net/netfilter/nf_tables_api.c ClockworkPi-linux/net/netfilter/nf_tables_api.c
*** linux/net/netfilter/nf_tables_api.c	2025-01-18 12:32:10.829782910 -0500
--- ClockworkPi-linux/net/netfilter/nf_tables_api.c	2025-01-18 12:30:26.559058046 -0500
***************
*** 8375,8381 ****
  }
  
  static void __nft_unregister_flowtable_net_hooks(struct net *net,
- 						 struct nft_flowtable *flowtable,
  						 struct list_head *hook_list,
  					         bool release_netdev)
  {
--- 8375,8380 ----
***************
*** 8383,8390 ****
  
  	list_for_each_entry_safe(hook, next, hook_list, list) {
  		nf_unregister_net_hook(net, &hook->ops);
- 		flowtable->data.type->setup(&flowtable->data, hook->ops.dev,
- 					    FLOW_BLOCK_UNBIND);
  		if (release_netdev) {
  			list_del(&hook->list);
  			kfree_rcu(hook, rcu);
--- 8382,8387 ----
***************
*** 8393,8402 ****
  }
  
  static void nft_unregister_flowtable_net_hooks(struct net *net,
- 					       struct nft_flowtable *flowtable,
  					       struct list_head *hook_list)
  {
! 	__nft_unregister_flowtable_net_hooks(net, flowtable, hook_list, false);
  }
  
  static int nft_register_flowtable_net_hooks(struct net *net,
--- 8390,8398 ----
  }
  
  static void nft_unregister_flowtable_net_hooks(struct net *net,
  					       struct list_head *hook_list)
  {
! 	__nft_unregister_flowtable_net_hooks(net, hook_list, false);
  }
  
  static int nft_register_flowtable_net_hooks(struct net *net,
***************
*** 9032,9037 ****
--- 9028,9035 ----
  
  	flowtable->data.type->free(&flowtable->data);
  	list_for_each_entry_safe(hook, next, &flowtable->hook_list, list) {
+ 		flowtable->data.type->setup(&flowtable->data, hook->ops.dev,
+ 					    FLOW_BLOCK_UNBIND);
  		list_del_rcu(&hook->list);
  		kfree_rcu(hook, rcu);
  	}
***************
*** 10401,10407 ****
  							   &nft_trans_flowtable_hooks(trans),
  							   trans->msg_type);
  				nft_unregister_flowtable_net_hooks(net,
- 								   nft_trans_flowtable(trans),
  								   &nft_trans_flowtable_hooks(trans));
  			} else {
  				list_del_rcu(&nft_trans_flowtable(trans)->list);
--- 10399,10404 ----
***************
*** 10410,10416 ****
  							   NULL,
  							   trans->msg_type);
  				nft_unregister_flowtable_net_hooks(net,
- 						nft_trans_flowtable(trans),
  						&nft_trans_flowtable(trans)->hook_list);
  			}
  			break;
--- 10407,10412 ----
***************
*** 10663,10675 ****
  		case NFT_MSG_NEWFLOWTABLE:
  			if (nft_trans_flowtable_update(trans)) {
  				nft_unregister_flowtable_net_hooks(net,
- 						nft_trans_flowtable(trans),
  						&nft_trans_flowtable_hooks(trans));
  			} else {
  				nft_use_dec_restore(&trans->ctx.table->use);
  				list_del_rcu(&nft_trans_flowtable(trans)->list);
  				nft_unregister_flowtable_net_hooks(net,
- 						nft_trans_flowtable(trans),
  						&nft_trans_flowtable(trans)->hook_list);
  			}
  			break;
--- 10659,10669 ----
***************
*** 11230,11237 ****
  	list_for_each_entry(chain, &table->chains, list)
  		__nf_tables_unregister_hook(net, table, chain, true);
  	list_for_each_entry(flowtable, &table->flowtables, list)
! 		__nft_unregister_flowtable_net_hooks(net, flowtable,
! 						     &flowtable->hook_list,
  						     true);
  }
  
--- 11224,11230 ----
  	list_for_each_entry(chain, &table->chains, list)
  		__nf_tables_unregister_hook(net, table, chain, true);
  	list_for_each_entry(flowtable, &table->flowtables, list)
! 		__nft_unregister_flowtable_net_hooks(net, &flowtable->hook_list,
  						     true);
  }
  
diff -crB linux/net/sched/cls_flow.c ClockworkPi-linux/net/sched/cls_flow.c
*** linux/net/sched/cls_flow.c	2025-01-18 12:32:11.253778067 -0500
--- ClockworkPi-linux/net/sched/cls_flow.c	2025-01-18 12:30:26.619057261 -0500
***************
*** 356,363 ****
  	[TCA_FLOW_KEYS]		= { .type = NLA_U32 },
  	[TCA_FLOW_MODE]		= { .type = NLA_U32 },
  	[TCA_FLOW_BASECLASS]	= { .type = NLA_U32 },
! 	[TCA_FLOW_RSHIFT]	= NLA_POLICY_MAX(NLA_U32,
! 						 31 /* BITS_PER_U32 - 1 */),
  	[TCA_FLOW_ADDEND]	= { .type = NLA_U32 },
  	[TCA_FLOW_MASK]		= { .type = NLA_U32 },
  	[TCA_FLOW_XOR]		= { .type = NLA_U32 },
--- 356,362 ----
  	[TCA_FLOW_KEYS]		= { .type = NLA_U32 },
  	[TCA_FLOW_MODE]		= { .type = NLA_U32 },
  	[TCA_FLOW_BASECLASS]	= { .type = NLA_U32 },
! 	[TCA_FLOW_RSHIFT]	= { .type = NLA_U32 },
  	[TCA_FLOW_ADDEND]	= { .type = NLA_U32 },
  	[TCA_FLOW_MASK]		= { .type = NLA_U32 },
  	[TCA_FLOW_XOR]		= { .type = NLA_U32 },
diff -crB linux/net/sched/sch_cake.c ClockworkPi-linux/net/sched/sch_cake.c
*** linux/net/sched/sch_cake.c	2025-01-18 12:32:11.257778021 -0500
--- ClockworkPi-linux/net/sched/sch_cake.c	2025-01-18 12:30:26.623057208 -0500
***************
*** 644,706 ****
  	return (flow_mode & CAKE_FLOW_DUAL_DST) == CAKE_FLOW_DUAL_DST;
  }
  
- static void cake_dec_srchost_bulk_flow_count(struct cake_tin_data *q,
- 					     struct cake_flow *flow,
- 					     int flow_mode)
- {
- 	if (likely(cake_dsrc(flow_mode) &&
- 		   q->hosts[flow->srchost].srchost_bulk_flow_count))
- 		q->hosts[flow->srchost].srchost_bulk_flow_count--;
- }
- 
- static void cake_inc_srchost_bulk_flow_count(struct cake_tin_data *q,
- 					     struct cake_flow *flow,
- 					     int flow_mode)
- {
- 	if (likely(cake_dsrc(flow_mode) &&
- 		   q->hosts[flow->srchost].srchost_bulk_flow_count < CAKE_QUEUES))
- 		q->hosts[flow->srchost].srchost_bulk_flow_count++;
- }
- 
- static void cake_dec_dsthost_bulk_flow_count(struct cake_tin_data *q,
- 					     struct cake_flow *flow,
- 					     int flow_mode)
- {
- 	if (likely(cake_ddst(flow_mode) &&
- 		   q->hosts[flow->dsthost].dsthost_bulk_flow_count))
- 		q->hosts[flow->dsthost].dsthost_bulk_flow_count--;
- }
- 
- static void cake_inc_dsthost_bulk_flow_count(struct cake_tin_data *q,
- 					     struct cake_flow *flow,
- 					     int flow_mode)
- {
- 	if (likely(cake_ddst(flow_mode) &&
- 		   q->hosts[flow->dsthost].dsthost_bulk_flow_count < CAKE_QUEUES))
- 		q->hosts[flow->dsthost].dsthost_bulk_flow_count++;
- }
- 
- static u16 cake_get_flow_quantum(struct cake_tin_data *q,
- 				 struct cake_flow *flow,
- 				 int flow_mode)
- {
- 	u16 host_load = 1;
- 
- 	if (cake_dsrc(flow_mode))
- 		host_load = max(host_load,
- 				q->hosts[flow->srchost].srchost_bulk_flow_count);
- 
- 	if (cake_ddst(flow_mode))
- 		host_load = max(host_load,
- 				q->hosts[flow->dsthost].dsthost_bulk_flow_count);
- 
- 	/* The get_random_u16() is a way to apply dithering to avoid
- 	 * accumulating roundoff errors
- 	 */
- 	return (q->flow_quantum * quantum_div[host_load] +
- 		get_random_u16()) >> 16;
- }
- 
  static u32 cake_hash(struct cake_tin_data *q, const struct sk_buff *skb,
  		     int flow_mode, u16 flow_override, u16 host_override)
  {
--- 644,649 ----
***************
*** 847,854 ****
  		allocate_dst = cake_ddst(flow_mode);
  
  		if (q->flows[outer_hash + k].set == CAKE_SET_BULK) {
! 			cake_dec_srchost_bulk_flow_count(q, &q->flows[outer_hash + k], flow_mode);
! 			cake_dec_dsthost_bulk_flow_count(q, &q->flows[outer_hash + k], flow_mode);
  		}
  found:
  		/* reserve queue for future packets in same flow */
--- 790,799 ----
  		allocate_dst = cake_ddst(flow_mode);
  
  		if (q->flows[outer_hash + k].set == CAKE_SET_BULK) {
! 			if (allocate_src)
! 				q->hosts[q->flows[reduced_hash].srchost].srchost_bulk_flow_count--;
! 			if (allocate_dst)
! 				q->hosts[q->flows[reduced_hash].dsthost].dsthost_bulk_flow_count--;
  		}
  found:
  		/* reserve queue for future packets in same flow */
***************
*** 873,882 ****
  			q->hosts[outer_hash + k].srchost_tag = srchost_hash;
  found_src:
  			srchost_idx = outer_hash + k;
- 			q->flows[reduced_hash].srchost = srchost_idx;
- 
  			if (q->flows[reduced_hash].set == CAKE_SET_BULK)
! 				cake_inc_srchost_bulk_flow_count(q, &q->flows[reduced_hash], flow_mode);
  		}
  
  		if (allocate_dst) {
--- 818,826 ----
  			q->hosts[outer_hash + k].srchost_tag = srchost_hash;
  found_src:
  			srchost_idx = outer_hash + k;
  			if (q->flows[reduced_hash].set == CAKE_SET_BULK)
! 				q->hosts[srchost_idx].srchost_bulk_flow_count++;
! 			q->flows[reduced_hash].srchost = srchost_idx;
  		}
  
  		if (allocate_dst) {
***************
*** 897,906 ****
  			q->hosts[outer_hash + k].dsthost_tag = dsthost_hash;
  found_dst:
  			dsthost_idx = outer_hash + k;
- 			q->flows[reduced_hash].dsthost = dsthost_idx;
- 
  			if (q->flows[reduced_hash].set == CAKE_SET_BULK)
! 				cake_inc_dsthost_bulk_flow_count(q, &q->flows[reduced_hash], flow_mode);
  		}
  	}
  
--- 841,849 ----
  			q->hosts[outer_hash + k].dsthost_tag = dsthost_hash;
  found_dst:
  			dsthost_idx = outer_hash + k;
  			if (q->flows[reduced_hash].set == CAKE_SET_BULK)
! 				q->hosts[dsthost_idx].dsthost_bulk_flow_count++;
! 			q->flows[reduced_hash].dsthost = dsthost_idx;
  		}
  	}
  
***************
*** 1913,1918 ****
--- 1856,1865 ----
  
  	/* flowchain */
  	if (!flow->set || flow->set == CAKE_SET_DECAYING) {
+ 		struct cake_host *srchost = &b->hosts[flow->srchost];
+ 		struct cake_host *dsthost = &b->hosts[flow->dsthost];
+ 		u16 host_load = 1;
+ 
  		if (!flow->set) {
  			list_add_tail(&flow->flowchain, &b->new_flows);
  		} else {
***************
*** 1922,1929 ****
  		flow->set = CAKE_SET_SPARSE;
  		b->sparse_flow_count++;
  
! 		flow->deficit = cake_get_flow_quantum(b, flow, q->flow_mode);
  	} else if (flow->set == CAKE_SET_SPARSE_WAIT) {
  		/* this flow was empty, accounted as a sparse flow, but actually
  		 * in the bulk rotation.
  		 */
--- 1869,1886 ----
  		flow->set = CAKE_SET_SPARSE;
  		b->sparse_flow_count++;
  
! 		if (cake_dsrc(q->flow_mode))
! 			host_load = max(host_load, srchost->srchost_bulk_flow_count);
! 
! 		if (cake_ddst(q->flow_mode))
! 			host_load = max(host_load, dsthost->dsthost_bulk_flow_count);
! 
! 		flow->deficit = (b->flow_quantum *
! 				 quantum_div[host_load]) >> 16;
  	} else if (flow->set == CAKE_SET_SPARSE_WAIT) {
+ 		struct cake_host *srchost = &b->hosts[flow->srchost];
+ 		struct cake_host *dsthost = &b->hosts[flow->dsthost];
+ 
  		/* this flow was empty, accounted as a sparse flow, but actually
  		 * in the bulk rotation.
  		 */
***************
*** 1931,1938 ****
  		b->sparse_flow_count--;
  		b->bulk_flow_count++;
  
! 		cake_inc_srchost_bulk_flow_count(b, flow, q->flow_mode);
! 		cake_inc_dsthost_bulk_flow_count(b, flow, q->flow_mode);
  	}
  
  	if (q->buffer_used > q->buffer_max_used)
--- 1888,1899 ----
  		b->sparse_flow_count--;
  		b->bulk_flow_count++;
  
! 		if (cake_dsrc(q->flow_mode))
! 			srchost->srchost_bulk_flow_count++;
! 
! 		if (cake_ddst(q->flow_mode))
! 			dsthost->dsthost_bulk_flow_count++;
! 
  	}
  
  	if (q->buffer_used > q->buffer_max_used)
***************
*** 1989,1999 ****
--- 1950,1962 ----
  {
  	struct cake_sched_data *q = qdisc_priv(sch);
  	struct cake_tin_data *b = &q->tins[q->cur_tin];
+ 	struct cake_host *srchost, *dsthost;
  	ktime_t now = ktime_get();
  	struct cake_flow *flow;
  	struct list_head *head;
  	bool first_flow = true;
  	struct sk_buff *skb;
+ 	u16 host_load;
  	u64 delay;
  	u32 len;
  
***************
*** 2093,2098 ****
--- 2056,2066 ----
  	q->cur_flow = flow - b->flows;
  	first_flow = false;
  
+ 	/* triple isolation (modified DRR++) */
+ 	srchost = &b->hosts[flow->srchost];
+ 	dsthost = &b->hosts[flow->dsthost];
+ 	host_load = 1;
+ 
  	/* flow isolation (DRR++) */
  	if (flow->deficit <= 0) {
  		/* Keep all flows with deficits out of the sparse and decaying
***************
*** 2104,2111 ****
  				b->sparse_flow_count--;
  				b->bulk_flow_count++;
  
! 				cake_inc_srchost_bulk_flow_count(b, flow, q->flow_mode);
! 				cake_inc_dsthost_bulk_flow_count(b, flow, q->flow_mode);
  
  				flow->set = CAKE_SET_BULK;
  			} else {
--- 2072,2082 ----
  				b->sparse_flow_count--;
  				b->bulk_flow_count++;
  
! 				if (cake_dsrc(q->flow_mode))
! 					srchost->srchost_bulk_flow_count++;
! 
! 				if (cake_ddst(q->flow_mode))
! 					dsthost->dsthost_bulk_flow_count++;
  
  				flow->set = CAKE_SET_BULK;
  			} else {
***************
*** 2117,2123 ****
  			}
  		}
  
! 		flow->deficit += cake_get_flow_quantum(b, flow, q->flow_mode);
  		list_move_tail(&flow->flowchain, &b->old_flows);
  
  		goto retry;
--- 2088,2106 ----
  			}
  		}
  
! 		if (cake_dsrc(q->flow_mode))
! 			host_load = max(host_load, srchost->srchost_bulk_flow_count);
! 
! 		if (cake_ddst(q->flow_mode))
! 			host_load = max(host_load, dsthost->dsthost_bulk_flow_count);
! 
! 		WARN_ON(host_load > CAKE_QUEUES);
! 
! 		/* The get_random_u16() is a way to apply dithering to avoid
! 		 * accumulating roundoff errors
! 		 */
! 		flow->deficit += (b->flow_quantum * quantum_div[host_load] +
! 				  get_random_u16()) >> 16;
  		list_move_tail(&flow->flowchain, &b->old_flows);
  
  		goto retry;
***************
*** 2141,2148 ****
  				if (flow->set == CAKE_SET_BULK) {
  					b->bulk_flow_count--;
  
! 					cake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);
! 					cake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);
  
  					b->decaying_flow_count++;
  				} else if (flow->set == CAKE_SET_SPARSE ||
--- 2124,2134 ----
  				if (flow->set == CAKE_SET_BULK) {
  					b->bulk_flow_count--;
  
! 					if (cake_dsrc(q->flow_mode))
! 						srchost->srchost_bulk_flow_count--;
! 
! 					if (cake_ddst(q->flow_mode))
! 						dsthost->dsthost_bulk_flow_count--;
  
  					b->decaying_flow_count++;
  				} else if (flow->set == CAKE_SET_SPARSE ||
***************
*** 2160,2167 ****
  				else if (flow->set == CAKE_SET_BULK) {
  					b->bulk_flow_count--;
  
! 					cake_dec_srchost_bulk_flow_count(b, flow, q->flow_mode);
! 					cake_dec_dsthost_bulk_flow_count(b, flow, q->flow_mode);
  				} else
  					b->decaying_flow_count--;
  
--- 2146,2157 ----
  				else if (flow->set == CAKE_SET_BULK) {
  					b->bulk_flow_count--;
  
! 					if (cake_dsrc(q->flow_mode))
! 						srchost->srchost_bulk_flow_count--;
! 
! 					if (cake_ddst(q->flow_mode))
! 						dsthost->dsthost_bulk_flow_count--;
! 
  				} else
  					b->decaying_flow_count--;
  
diff -crB linux/net/sctp/sysctl.c ClockworkPi-linux/net/sctp/sysctl.c
*** linux/net/sctp/sysctl.c	2025-01-18 12:32:11.273777839 -0500
--- ClockworkPi-linux/net/sctp/sysctl.c	2025-01-18 12:30:26.639056999 -0500
***************
*** 391,398 ****
  static int proc_sctp_do_hmac_alg(struct ctl_table *ctl, int write,
  				 void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = container_of(ctl->data, struct net,
! 				       sctp.sctp_hmac_alg);
  	struct ctl_table tbl;
  	bool changed = false;
  	char *none = "none";
--- 391,397 ----
  static int proc_sctp_do_hmac_alg(struct ctl_table *ctl, int write,
  				 void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = current->nsproxy->net_ns;
  	struct ctl_table tbl;
  	bool changed = false;
  	char *none = "none";
***************
*** 437,443 ****
  static int proc_sctp_do_rto_min(struct ctl_table *ctl, int write,
  				void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = container_of(ctl->data, struct net, sctp.rto_min);
  	unsigned int min = *(unsigned int *) ctl->extra1;
  	unsigned int max = *(unsigned int *) ctl->extra2;
  	struct ctl_table tbl;
--- 436,442 ----
  static int proc_sctp_do_rto_min(struct ctl_table *ctl, int write,
  				void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = current->nsproxy->net_ns;
  	unsigned int min = *(unsigned int *) ctl->extra1;
  	unsigned int max = *(unsigned int *) ctl->extra2;
  	struct ctl_table tbl;
***************
*** 465,471 ****
  static int proc_sctp_do_rto_max(struct ctl_table *ctl, int write,
  				void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = container_of(ctl->data, struct net, sctp.rto_max);
  	unsigned int min = *(unsigned int *) ctl->extra1;
  	unsigned int max = *(unsigned int *) ctl->extra2;
  	struct ctl_table tbl;
--- 464,470 ----
  static int proc_sctp_do_rto_max(struct ctl_table *ctl, int write,
  				void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = current->nsproxy->net_ns;
  	unsigned int min = *(unsigned int *) ctl->extra1;
  	unsigned int max = *(unsigned int *) ctl->extra2;
  	struct ctl_table tbl;
***************
*** 503,509 ****
  static int proc_sctp_do_auth(struct ctl_table *ctl, int write,
  			     void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = container_of(ctl->data, struct net, sctp.auth_enable);
  	struct ctl_table tbl;
  	int new_value, ret;
  
--- 502,508 ----
  static int proc_sctp_do_auth(struct ctl_table *ctl, int write,
  			     void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = current->nsproxy->net_ns;
  	struct ctl_table tbl;
  	int new_value, ret;
  
***************
*** 532,538 ****
  static int proc_sctp_do_udp_port(struct ctl_table *ctl, int write,
  				 void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = container_of(ctl->data, struct net, sctp.udp_port);
  	unsigned int min = *(unsigned int *)ctl->extra1;
  	unsigned int max = *(unsigned int *)ctl->extra2;
  	struct ctl_table tbl;
--- 531,537 ----
  static int proc_sctp_do_udp_port(struct ctl_table *ctl, int write,
  				 void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = current->nsproxy->net_ns;
  	unsigned int min = *(unsigned int *)ctl->extra1;
  	unsigned int max = *(unsigned int *)ctl->extra2;
  	struct ctl_table tbl;
***************
*** 573,580 ****
  static int proc_sctp_do_probe_interval(struct ctl_table *ctl, int write,
  				       void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = container_of(ctl->data, struct net,
! 				       sctp.probe_interval);
  	struct ctl_table tbl;
  	int ret, new_value;
  
--- 572,578 ----
  static int proc_sctp_do_probe_interval(struct ctl_table *ctl, int write,
  				       void *buffer, size_t *lenp, loff_t *ppos)
  {
! 	struct net *net = current->nsproxy->net_ns;
  	struct ctl_table tbl;
  	int ret, new_value;
  
diff -crB linux/net/tls/tls_sw.c ClockworkPi-linux/net/tls/tls_sw.c
*** linux/net/tls/tls_sw.c	2025-01-18 12:32:11.309777428 -0500
--- ClockworkPi-linux/net/tls/tls_sw.c	2025-01-18 12:30:26.675056528 -0500
***************
*** 458,464 ****
  
  tx_err:
  	if (rc < 0 && rc != -EAGAIN)
! 		tls_err_abort(sk, rc);
  
  	return rc;
  }
--- 458,464 ----
  
  tx_err:
  	if (rc < 0 && rc != -EAGAIN)
! 		tls_err_abort(sk, -EBADMSG);
  
  	return rc;
  }
diff -crB linux/scripts/dtc/include-prefixes/arm/nxp/imx/imxrt1050.dtsi ClockworkPi-linux/scripts/dtc/include-prefixes/arm/nxp/imx/imxrt1050.dtsi
*** linux/scripts/dtc/include-prefixes/arm/nxp/imx/imxrt1050.dtsi	2025-01-18 12:31:55.509959665 -0500
--- ClockworkPi-linux/scripts/dtc/include-prefixes/arm/nxp/imx/imxrt1050.dtsi	2025-01-18 12:30:13.035236670 -0500
***************
*** 87,93 ****
  			reg = <0x402c0000 0x4000>;
  			interrupts = <110>;
  			clocks = <&clks IMXRT1050_CLK_IPG_PDOF>,
! 				<&clks IMXRT1050_CLK_AHB_PODF>,
  				<&clks IMXRT1050_CLK_USDHC1>;
  			clock-names = "ipg", "ahb", "per";
  			bus-width = <4>;
--- 87,93 ----
  			reg = <0x402c0000 0x4000>;
  			interrupts = <110>;
  			clocks = <&clks IMXRT1050_CLK_IPG_PDOF>,
! 				<&clks IMXRT1050_CLK_OSC>,
  				<&clks IMXRT1050_CLK_USDHC1>;
  			clock-names = "ipg", "ahb", "per";
  			bus-width = <4>;
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm/overlays: clockworkpi-devterm-overlay.dts
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm/overlays: clockworkpi-misc-cm5-overlay.dts
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm/overlays: clockworkpi-pmu-cm5-overlay.dts
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm/overlays: clockworkpi-uconsole-cm5-overlay.dts
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm/overlays: clockworkpi-uconsole-overlay.dts
diff -crB linux/scripts/dtc/include-prefixes/arm/overlays/Makefile ClockworkPi-linux/scripts/dtc/include-prefixes/arm/overlays/Makefile
*** linux/scripts/dtc/include-prefixes/arm/overlays/Makefile	2025-01-18 12:31:55.521959525 -0500
--- ClockworkPi-linux/scripts/dtc/include-prefixes/arm/overlays/Makefile	2025-01-18 12:30:13.047236511 -0500
***************
*** 40,45 ****
--- 40,50 ----
  	cap1106.dtbo \
  	chipdip-dac.dtbo \
  	cirrus-wm5102.dtbo \
+ 	clockworkpi-devterm.dtbo \
+ 	clockworkpi-misc-cm5.dtbo \
+ 	clockworkpi-pmu-cm5.dtbo \
+ 	clockworkpi-uconsole-cm5.dtbo \
+ 	clockworkpi-uconsole.dtbo \
  	cm-swap-i2c0.dtbo \
  	cma.dtbo \
  	crystalfontz-cfa050_pi_m.dtbo \
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm64/overlays: clockworkpi-devterm-overlay.dts
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm64/overlays: clockworkpi-misc-cm5-overlay.dts
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm64/overlays: clockworkpi-pmu-cm5-overlay.dts
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm64/overlays: clockworkpi-uconsole-cm5-overlay.dts
Only in ClockworkPi-linux/scripts/dtc/include-prefixes/arm64/overlays: clockworkpi-uconsole-overlay.dts
diff -crB linux/scripts/dtc/include-prefixes/arm64/overlays/Makefile ClockworkPi-linux/scripts/dtc/include-prefixes/arm64/overlays/Makefile
*** linux/scripts/dtc/include-prefixes/arm64/overlays/Makefile	2025-01-18 12:31:55.521959525 -0500
--- ClockworkPi-linux/scripts/dtc/include-prefixes/arm64/overlays/Makefile	2025-01-18 12:30:13.047236511 -0500
***************
*** 40,45 ****
--- 40,50 ----
  	cap1106.dtbo \
  	chipdip-dac.dtbo \
  	cirrus-wm5102.dtbo \
+ 	clockworkpi-devterm.dtbo \
+ 	clockworkpi-misc-cm5.dtbo \
+ 	clockworkpi-pmu-cm5.dtbo \
+ 	clockworkpi-uconsole-cm5.dtbo \
+ 	clockworkpi-uconsole.dtbo \
  	cm-swap-i2c0.dtbo \
  	cma.dtbo \
  	crystalfontz-cfa050_pi_m.dtbo \
diff -crB linux/scripts/dtc/include-prefixes/arm64/rockchip/rk3328.dtsi ClockworkPi-linux/scripts/dtc/include-prefixes/arm64/rockchip/rk3328.dtsi
*** linux/scripts/dtc/include-prefixes/arm64/rockchip/rk3328.dtsi	2025-01-18 12:31:56.009953840 -0500
--- ClockworkPi-linux/scripts/dtc/include-prefixes/arm64/rockchip/rk3328.dtsi	2025-01-18 12:30:13.551229797 -0500
***************
*** 304,310 ****
  
  			power-domain@RK3328_PD_HEVC {
  				reg = <RK3328_PD_HEVC>;
- 				clocks = <&cru SCLK_VENC_CORE>;
  				#power-domain-cells = <0>;
  			};
  			power-domain@RK3328_PD_VIDEO {
--- 304,309 ----
diff -crB linux/sound/soc/codecs/rt722-sdca.c ClockworkPi-linux/sound/soc/codecs/rt722-sdca.c
*** linux/sound/soc/codecs/rt722-sdca.c	2025-01-18 12:32:11.761772267 -0500
--- ClockworkPi-linux/sound/soc/codecs/rt722-sdca.c	2025-01-18 12:30:27.123050666 -0500
***************
*** 1466,1483 ****
  		0x008d);
  	/* check HP calibration FSM status */
  	for (loop_check = 0; loop_check < chk_cnt; loop_check++) {
- 		usleep_range(10000, 11000);
  		ret = rt722_sdca_index_read(rt722, RT722_VENDOR_CALI,
  			RT722_DAC_DC_CALI_CTL3, &calib_status);
! 		if (ret < 0)
  			dev_dbg(&rt722->slave->dev, "calibration failed!, ret=%d\n", ret);
  		if ((calib_status & 0x0040) == 0x0)
  			break;
  	}
- 
- 	if (loop_check == chk_cnt)
- 		dev_dbg(&rt722->slave->dev, "%s, calibration time-out!\n", __func__);
- 
  	/* Set ADC09 power entity floating control */
  	rt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_ADC0A_08_PDE_FLOAT_CTL,
  		0x2a12);
--- 1466,1478 ----
  		0x008d);
  	/* check HP calibration FSM status */
  	for (loop_check = 0; loop_check < chk_cnt; loop_check++) {
  		ret = rt722_sdca_index_read(rt722, RT722_VENDOR_CALI,
  			RT722_DAC_DC_CALI_CTL3, &calib_status);
! 		if (ret < 0 || loop_check == chk_cnt)
  			dev_dbg(&rt722->slave->dev, "calibration failed!, ret=%d\n", ret);
  		if ((calib_status & 0x0040) == 0x0)
  			break;
  	}
  	/* Set ADC09 power entity floating control */
  	rt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_ADC0A_08_PDE_FLOAT_CTL,
  		0x2a12);
diff -crB linux/sound/soc/mediatek/common/mtk-afe-platform-driver.c ClockworkPi-linux/sound/soc/mediatek/common/mtk-afe-platform-driver.c
*** linux/sound/soc/mediatek/common/mtk-afe-platform-driver.c	2025-01-18 12:32:17.949701916 -0500
--- ClockworkPi-linux/sound/soc/mediatek/common/mtk-afe-platform-driver.c	2025-01-18 12:30:27.579044705 -0500
***************
*** 120,127 ****
  	struct mtk_base_afe *afe = snd_soc_component_get_drvdata(component);
  
  	size = afe->mtk_afe_hardware->buffer_bytes_max;
! 	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, afe->dev, 0, size);
! 
  	return 0;
  }
  EXPORT_SYMBOL_GPL(mtk_afe_pcm_new);
--- 120,127 ----
  	struct mtk_base_afe *afe = snd_soc_component_get_drvdata(component);
  
  	size = afe->mtk_afe_hardware->buffer_bytes_max;
! 	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
! 				       afe->dev, size, size);
  	return 0;
  }
  EXPORT_SYMBOL_GPL(mtk_afe_pcm_new);
diff -crB linux/tools/include/linux/numa.h ClockworkPi-linux/tools/include/linux/numa.h
*** linux/tools/include/linux/numa.h	2025-01-18 12:32:18.445696302 -0500
--- ClockworkPi-linux/tools/include/linux/numa.h	2025-01-18 12:30:27.755042405 -0500
***************
*** 13,21 ****
  
  #define	NUMA_NO_NODE	(-1)
  
- static inline bool numa_valid_node(int nid)
- {
- 	return nid >= 0 && nid < MAX_NUMNODES;
- }
- 
  #endif /* _LINUX_NUMA_H */
--- 13,16 ----
diff -crB linux/tools/testing/selftests/alsa/Makefile ClockworkPi-linux/tools/testing/selftests/alsa/Makefile
*** linux/tools/testing/selftests/alsa/Makefile	2025-01-18 12:32:19.773681284 -0500
--- ClockworkPi-linux/tools/testing/selftests/alsa/Makefile	2025-01-18 12:30:28.163037075 -0500
***************
*** 23,27 ****
  $(OUTPUT)/libatest.so: conf.c alsa-local.h
  	$(CC) $(CFLAGS) -shared -fPIC $< $(LDLIBS) -o $@
  
! $(OUTPUT)/%: %.c $(OUTPUT)/libatest.so alsa-local.h
  	$(CC) $(CFLAGS) $< $(LDLIBS) -latest -o $@
--- 23,27 ----
  $(OUTPUT)/libatest.so: conf.c alsa-local.h
  	$(CC) $(CFLAGS) -shared -fPIC $< $(LDLIBS) -o $@
  
! $(OUTPUT)/%: %.c $(TEST_GEN_PROGS_EXTENDED) alsa-local.h
  	$(CC) $(CFLAGS) $< $(LDLIBS) -latest -o $@
